// Code generated by goa v3.5.2, DO NOT EDIT.
//
// sources service
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package sources

import (
	"context"

	sourcesviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/sources/views"
)

// Sources endpoint.
type Service interface {
	// ListSources implements List sources.
	ListSources(context.Context, *ListSourcesPayload) (res SourceCollection, err error)
	// GetSource implements Get source.
	GetSource(context.Context, *GetSourcePayload) (res *Source, err error)
	// ListFindingsBySource implements List findings by source.
	ListFindingsBySource(context.Context, *ListFindingsBySourcePayload) (res FindingCollection, err error)
	// GetSourceMTTR implements Get source MTTR.
	GetSourceMTTR(context.Context, *GetSourceMTTRPayload) (res float32, err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "sources"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [4]string{"List sources", "Get source", "List findings by source", "Get source MTTR"}

// ListSourcesPayload is the payload type of the sources service List sources
// method.
type ListSourcesPayload struct {
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
}

// SourceCollection is the result type of the sources service List sources
// method.
type SourceCollection []*Source

// GetSourcePayload is the payload type of the sources service Get source
// method.
type GetSourcePayload struct {
	// Source ID
	ID *string
}

// Source is the result type of the sources service Get source method.
type Source struct {
	// Source ID
	ID *string
	// Target ID
	TargetID *string
	// Source name
	Name *string
	// Source component
	Component *string
	// Source instance
	Instance *string
	// Source options
	Options *string
	// Time on which the source scanned the target
	Time *string
}

// ListFindingsBySourcePayload is the payload type of the sources service List
// findings by source method.
type ListFindingsBySourcePayload struct {
	// Source ID
	ID *string
	// Finding status filter. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Sorting criteria. Supported fields: score, -score (for descending order)
	SortBy *string
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
}

// FindingCollection is the result type of the sources service List findings by
// source method.
type FindingCollection []*Finding

// GetSourceMTTRPayload is the payload type of the sources service Get source
// MTTR method.
type GetSourceMTTRPayload struct {
	// Source ID
	ID *string
}

type Finding struct {
	// Finding ID
	ID *string
	// Issue
	Issue *Issue
	// Target
	Target *Target
	// Source
	Source *Sourcewithnotarget
	// Finding details
	Details *string
	// Finding impact details
	ImpactDetails *string
	// Finding status. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Finding severity score
	Score *float32
	// Other resources associated with the finding
	Resources []*ResourceGroup
}

type Issue struct {
	// Issue ID
	ID *string
	// Issue summary
	Summary *string
	// Common Weakness Enumeration ID
	CweID *int
	// Issue description
	Description *string
	// Recommendations to fix the issue
	Recommendations []string
	// Documentation reference for the issue
	ReferenceLinks []string
	// Labels associated with the issue
	Labels []string
}

type Target struct {
	// Target ID
	ID *string
	// Target identifier
	Identifier *string
	// List of teams associated with target
	Teams []string
	// List of tags associated with target
	Tags []string
}

type Sourcewithnotarget struct {
	// Source ID
	ID *string
	// Source name
	Name *string
	// Source component
	Component *string
	// Source instance
	Instance *string
	// Source options
	Options *string
	// Time on which the source scanned the target
	Time *string
}

type ResourceGroup struct {
	// Name of the resource group
	Name *string
	// Column names of the resource group in the order that should be rendered
	Attributes []string
	// List containing the resource rows as hashmap
	Resources []map[string]string
}

// NewSourceCollection initializes result type SourceCollection from viewed
// result type SourceCollection.
func NewSourceCollection(vres sourcesviews.SourceCollection) SourceCollection {
	return newSourceCollection(vres.Projected)
}

// NewViewedSourceCollection initializes viewed result type SourceCollection
// from result type SourceCollection using the given view.
func NewViewedSourceCollection(res SourceCollection, view string) sourcesviews.SourceCollection {
	p := newSourceCollectionView(res)
	return sourcesviews.SourceCollection{Projected: p, View: "default"}
}

// NewSource initializes result type Source from viewed result type Source.
func NewSource(vres *sourcesviews.Source) *Source {
	return newSource(vres.Projected)
}

// NewViewedSource initializes viewed result type Source from result type
// Source using the given view.
func NewViewedSource(res *Source, view string) *sourcesviews.Source {
	p := newSourceView(res)
	return &sourcesviews.Source{Projected: p, View: "default"}
}

// NewFindingCollection initializes result type FindingCollection from viewed
// result type FindingCollection.
func NewFindingCollection(vres sourcesviews.FindingCollection) FindingCollection {
	return newFindingCollection(vres.Projected)
}

// NewViewedFindingCollection initializes viewed result type FindingCollection
// from result type FindingCollection using the given view.
func NewViewedFindingCollection(res FindingCollection, view string) sourcesviews.FindingCollection {
	p := newFindingCollectionView(res)
	return sourcesviews.FindingCollection{Projected: p, View: "default"}
}

// newSourceCollection converts projected type SourceCollection to service type
// SourceCollection.
func newSourceCollection(vres sourcesviews.SourceCollectionView) SourceCollection {
	res := make(SourceCollection, len(vres))
	for i, n := range vres {
		res[i] = newSource(n)
	}
	return res
}

// newSourceCollectionView projects result type SourceCollection to projected
// type SourceCollectionView using the "default" view.
func newSourceCollectionView(res SourceCollection) sourcesviews.SourceCollectionView {
	vres := make(sourcesviews.SourceCollectionView, len(res))
	for i, n := range res {
		vres[i] = newSourceView(n)
	}
	return vres
}

// newSource converts projected type Source to service type Source.
func newSource(vres *sourcesviews.SourceView) *Source {
	res := &Source{
		ID:        vres.ID,
		TargetID:  vres.TargetID,
		Name:      vres.Name,
		Component: vres.Component,
		Instance:  vres.Instance,
		Options:   vres.Options,
		Time:      vres.Time,
	}
	return res
}

// newSourceView projects result type Source to projected type SourceView using
// the "default" view.
func newSourceView(res *Source) *sourcesviews.SourceView {
	vres := &sourcesviews.SourceView{
		ID:        res.ID,
		TargetID:  res.TargetID,
		Name:      res.Name,
		Component: res.Component,
		Instance:  res.Instance,
		Options:   res.Options,
		Time:      res.Time,
	}
	return vres
}

// newFindingCollection converts projected type FindingCollection to service
// type FindingCollection.
func newFindingCollection(vres sourcesviews.FindingCollectionView) FindingCollection {
	res := make(FindingCollection, len(vres))
	for i, n := range vres {
		res[i] = newFinding(n)
	}
	return res
}

// newFindingCollectionView projects result type FindingCollection to projected
// type FindingCollectionView using the "default" view.
func newFindingCollectionView(res FindingCollection) sourcesviews.FindingCollectionView {
	vres := make(sourcesviews.FindingCollectionView, len(res))
	for i, n := range res {
		vres[i] = newFindingView(n)
	}
	return vres
}

// newFinding converts projected type Finding to service type Finding.
func newFinding(vres *sourcesviews.FindingView) *Finding {
	res := &Finding{
		ID:            vres.ID,
		Details:       vres.Details,
		ImpactDetails: vres.ImpactDetails,
		Status:        vres.Status,
		Score:         vres.Score,
	}
	if vres.Target != nil {
		res.Target = transformSourcesviewsTargetViewToTarget(vres.Target)
	}
	if vres.Resources != nil {
		res.Resources = make([]*ResourceGroup, len(vres.Resources))
		for i, val := range vres.Resources {
			res.Resources[i] = transformSourcesviewsResourceGroupViewToResourceGroup(val)
		}
	}
	if vres.Issue != nil {
		res.Issue = newIssue(vres.Issue)
	}
	if vres.Source != nil {
		res.Source = newSourcewithnotarget(vres.Source)
	}
	return res
}

// newFindingView projects result type Finding to projected type FindingView
// using the "default" view.
func newFindingView(res *Finding) *sourcesviews.FindingView {
	vres := &sourcesviews.FindingView{
		ID:            res.ID,
		Details:       res.Details,
		ImpactDetails: res.ImpactDetails,
		Status:        res.Status,
		Score:         res.Score,
	}
	if res.Target != nil {
		vres.Target = transformTargetToSourcesviewsTargetView(res.Target)
	}
	if res.Resources != nil {
		vres.Resources = make([]*sourcesviews.ResourceGroupView, len(res.Resources))
		for i, val := range res.Resources {
			vres.Resources[i] = transformResourceGroupToSourcesviewsResourceGroupView(val)
		}
	}
	if res.Issue != nil {
		vres.Issue = newIssueView(res.Issue)
	}
	if res.Source != nil {
		vres.Source = newSourcewithnotargetView(res.Source)
	}
	return vres
}

// newIssue converts projected type Issue to service type Issue.
func newIssue(vres *sourcesviews.IssueView) *Issue {
	res := &Issue{
		ID:          vres.ID,
		Summary:     vres.Summary,
		CweID:       vres.CweID,
		Description: vres.Description,
	}
	if vres.Recommendations != nil {
		res.Recommendations = make([]string, len(vres.Recommendations))
		for i, val := range vres.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if vres.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(vres.ReferenceLinks))
		for i, val := range vres.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	if vres.Labels != nil {
		res.Labels = make([]string, len(vres.Labels))
		for i, val := range vres.Labels {
			res.Labels[i] = val
		}
	}
	return res
}

// newIssueView projects result type Issue to projected type IssueView using
// the "default" view.
func newIssueView(res *Issue) *sourcesviews.IssueView {
	vres := &sourcesviews.IssueView{
		ID:          res.ID,
		Summary:     res.Summary,
		CweID:       res.CweID,
		Description: res.Description,
	}
	if res.Recommendations != nil {
		vres.Recommendations = make([]string, len(res.Recommendations))
		for i, val := range res.Recommendations {
			vres.Recommendations[i] = val
		}
	}
	if res.ReferenceLinks != nil {
		vres.ReferenceLinks = make([]string, len(res.ReferenceLinks))
		for i, val := range res.ReferenceLinks {
			vres.ReferenceLinks[i] = val
		}
	}
	if res.Labels != nil {
		vres.Labels = make([]string, len(res.Labels))
		for i, val := range res.Labels {
			vres.Labels[i] = val
		}
	}
	return vres
}

// newTarget converts projected type Target to service type Target.
func newTarget(vres *sourcesviews.TargetView) *Target {
	res := &Target{
		ID:         vres.ID,
		Identifier: vres.Identifier,
	}
	if vres.Teams != nil {
		res.Teams = make([]string, len(vres.Teams))
		for i, val := range vres.Teams {
			res.Teams[i] = val
		}
	}
	if vres.Tags != nil {
		res.Tags = make([]string, len(vres.Tags))
		for i, val := range vres.Tags {
			res.Tags[i] = val
		}
	}
	return res
}

// newTargetView projects result type Target to projected type TargetView using
// the "default" view.
func newTargetView(res *Target) *sourcesviews.TargetView {
	vres := &sourcesviews.TargetView{
		ID:         res.ID,
		Identifier: res.Identifier,
	}
	if res.Teams != nil {
		vres.Teams = make([]string, len(res.Teams))
		for i, val := range res.Teams {
			vres.Teams[i] = val
		}
	}
	if res.Tags != nil {
		vres.Tags = make([]string, len(res.Tags))
		for i, val := range res.Tags {
			vres.Tags[i] = val
		}
	}
	return vres
}

// newSourcewithnotarget converts projected type Sourcewithnotarget to service
// type Sourcewithnotarget.
func newSourcewithnotarget(vres *sourcesviews.SourcewithnotargetView) *Sourcewithnotarget {
	res := &Sourcewithnotarget{
		ID:        vres.ID,
		Name:      vres.Name,
		Component: vres.Component,
		Instance:  vres.Instance,
		Options:   vres.Options,
		Time:      vres.Time,
	}
	return res
}

// newSourcewithnotargetView projects result type Sourcewithnotarget to
// projected type SourcewithnotargetView using the "default" view.
func newSourcewithnotargetView(res *Sourcewithnotarget) *sourcesviews.SourcewithnotargetView {
	vres := &sourcesviews.SourcewithnotargetView{
		ID:        res.ID,
		Name:      res.Name,
		Component: res.Component,
		Instance:  res.Instance,
		Options:   res.Options,
		Time:      res.Time,
	}
	return vres
}

// newResourceGroup converts projected type ResourceGroup to service type
// ResourceGroup.
func newResourceGroup(vres *sourcesviews.ResourceGroupView) *ResourceGroup {
	res := &ResourceGroup{
		Name: vres.Name,
	}
	if vres.Attributes != nil {
		res.Attributes = make([]string, len(vres.Attributes))
		for i, val := range vres.Attributes {
			res.Attributes[i] = val
		}
	}
	if vres.Resources != nil {
		res.Resources = make([]map[string]string, len(vres.Resources))
		for i, val := range vres.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}
	return res
}

// newResourceGroupView projects result type ResourceGroup to projected type
// ResourceGroupView using the "default" view.
func newResourceGroupView(res *ResourceGroup) *sourcesviews.ResourceGroupView {
	vres := &sourcesviews.ResourceGroupView{
		Name: res.Name,
	}
	if res.Attributes != nil {
		vres.Attributes = make([]string, len(res.Attributes))
		for i, val := range res.Attributes {
			vres.Attributes[i] = val
		}
	}
	if res.Resources != nil {
		vres.Resources = make([]map[string]string, len(res.Resources))
		for i, val := range res.Resources {
			vres.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				vres.Resources[i][tk] = tv
			}
		}
	}
	return vres
}

// transformSourcesviewsTargetViewToTarget builds a value of type *Target from
// a value of type *sourcesviews.TargetView.
func transformSourcesviewsTargetViewToTarget(v *sourcesviews.TargetView) *Target {
	if v == nil {
		return nil
	}
	res := &Target{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Teams != nil {
		res.Teams = make([]string, len(v.Teams))
		for i, val := range v.Teams {
			res.Teams[i] = val
		}
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// transformSourcesviewsResourceGroupViewToResourceGroup builds a value of type
// *ResourceGroup from a value of type *sourcesviews.ResourceGroupView.
func transformSourcesviewsResourceGroupViewToResourceGroup(v *sourcesviews.ResourceGroupView) *ResourceGroup {
	if v == nil {
		return nil
	}
	res := &ResourceGroup{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// transformTargetToSourcesviewsTargetView builds a value of type
// *sourcesviews.TargetView from a value of type *Target.
func transformTargetToSourcesviewsTargetView(v *Target) *sourcesviews.TargetView {
	if v == nil {
		return nil
	}
	res := &sourcesviews.TargetView{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Teams != nil {
		res.Teams = make([]string, len(v.Teams))
		for i, val := range v.Teams {
			res.Teams[i] = val
		}
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// transformResourceGroupToSourcesviewsResourceGroupView builds a value of type
// *sourcesviews.ResourceGroupView from a value of type *ResourceGroup.
func transformResourceGroupToSourcesviewsResourceGroupView(v *ResourceGroup) *sourcesviews.ResourceGroupView {
	if v == nil {
		return nil
	}
	res := &sourcesviews.ResourceGroupView{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}
