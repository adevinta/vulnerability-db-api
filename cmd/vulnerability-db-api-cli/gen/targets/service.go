// Code generated by goa v3.0.6, DO NOT EDIT.
//
// targets service
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package targets

import (
	"context"

	targetsviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/targets/views"
)

// Targets endpoint.
type Service interface {
	// ListTargets implements List targets.
	ListTargets(context.Context, *ListTargetsPayload) (res TargetCollection, err error)
	// TargetsSummary implements Targets summary.
	TargetsSummary(context.Context, *TargetsSummaryPayload) (res TargetSummaryCollection, err error)
	// GetTarget implements Get target.
	GetTarget(context.Context, *GetTargetPayload) (res *Target, err error)
	// CreateTarget implements Create target.
	CreateTarget(context.Context, *CreateTargetPayload) (res *Target, err error)
	// ListFindingsByTarget implements List findings by target.
	ListFindingsByTarget(context.Context, *ListFindingsByTargetPayload) (res FindingCollection, err error)
	// ListFindingsByTargetAndIssue implements List findings by target and issue.
	ListFindingsByTargetAndIssue(context.Context, *ListFindingsByTargetAndIssuePayload) (res *Finding, err error)
	// GetTargetMTTR implements Get target MTTR.
	GetTargetMTTR(context.Context, *GetTargetMTTRPayload) (res float32, err error)
	// DeleteTargetTag implements Delete target tag.
	DeleteTargetTag(context.Context, *DeleteTargetTagPayload) (err error)
	// DeleteTag implements Delete tag.
	DeleteTag(context.Context, *DeleteTagPayload) (err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "targets"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [9]string{"List targets", "Targets summary", "Get target", "Create target", "List findings by target", "List findings by target and issue", "Get target MTTR", "Delete target tag", "Delete tag"}

// ListTargetsPayload is the payload type of the targets service List targets
// method.
type ListTargetsPayload struct {
	// Targets tag filter
	Tag *string
	// Targets identifier filter
	Identifier *string
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
	// Exact match in identifier filter
	Identifiermatch *bool
	// A list of asset identifiers
	Identifiers *string
}

// TargetCollection is the result type of the targets service List targets
// method.
type TargetCollection []*Target

// TargetsSummaryPayload is the payload type of the targets service Targets
// summary method.
type TargetsSummaryPayload struct {
	// Targets tag filter
	Tag *string
	// Finding status filter. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Sorting criteria. Supported fields: score, findings_count (use - for
	// descending order. E.g.: -score)
	SortBy *string
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
	// A list of asset identifiers
	Identifiers *string
	// List of associated issues labels to filter by
	Labels *string
}

// TargetSummaryCollection is the result type of the targets service Targets
// summary method.
type TargetSummaryCollection []*TargetSummary

// GetTargetPayload is the payload type of the targets service Get target
// method.
type GetTargetPayload struct {
	// Target ID
	ID *string
}

// Target is the result type of the targets service Get target method.
type Target struct {
	// Target ID
	ID *string
	// Target identifier
	Identifier *string
	// List of tags associated with target
	Tags []string
}

// CreateTargetPayload is the payload type of the targets service Create target
// method.
type CreateTargetPayload struct {
	// Target Identifier
	Identifier *string
	// Target Tags
	Tags []string
}

// ListFindingsByTargetPayload is the payload type of the targets service List
// findings by target method.
type ListFindingsByTargetPayload struct {
	// Target ID
	ID *string
	// Finding status filter. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Sorting criteria. Supported fields: score, -score (for descending order)
	SortBy *string
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
	// List of labels to filter by
	Labels *string
}

// FindingCollection is the result type of the targets service List findings by
// target method.
type FindingCollection []*Finding

// ListFindingsByTargetAndIssuePayload is the payload type of the targets
// service List findings by target and issue method.
type ListFindingsByTargetAndIssuePayload struct {
	// Target ID
	TargetID *string
	// Issue ID
	IssueID *string
}

// Finding is the result type of the targets service List findings by target
// and issue method.
type Finding struct {
	// Finding ID
	ID *string
	// Issue
	Issue *Issue
	// Target
	Target *Target
	// Source
	Source *Sourcewithnotarget
	// Finding details
	Details *string
	// Finding impact details
	ImpactDetails *string
	// Finding status. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Finding severity score
	Score *float32
	// Other resources associated with the finding
	Resources []*ResourceGroup
}

// GetTargetMTTRPayload is the payload type of the targets service Get target
// MTTR method.
type GetTargetMTTRPayload struct {
	// Target ID
	ID *string
}

// DeleteTargetTagPayload is the payload type of the targets service Delete
// target tag method.
type DeleteTargetTagPayload struct {
	// Target ID
	TargetID *string
	// Tag
	Tag  *string
	Auth string
}

// DeleteTagPayload is the payload type of the targets service Delete tag
// method.
type DeleteTagPayload struct {
	// Tag
	Tag  *string
	Auth string
}

type TargetSummary struct {
	// Target ID
	TargetID *string
	// Target identifier
	Identifier *string
	// Number of findings for target
	FindingsCount *int
	// Number of issues for target
	IssuesCount *int
	// Max score for target
	MaxScore *float32
}

type Issue struct {
	// Issue ID
	ID *string
	// Issue summary
	Summary *string
	// Common Weakness Enumeration ID
	CweID *int
	// Issue description
	Description *string
	// Recommendations to fix the issue
	Recommendations []string
	// Documentation reference for the issue
	ReferenceLinks []string
	// Labels associated with the issue
	Labels []string
}

type Sourcewithnotarget struct {
	// Source ID
	ID *string
	// Source name
	Name *string
	// Source component
	Component *string
	// Source instance
	Instance *string
	// Source options
	Options *string
	// Time on which the source scanned the target
	Time *string
}

type ResourceGroup struct {
	// Name of the resource group
	Name *string
	// Column names of the resource group in the order that should be rendered
	Attributes []string
	// List containing the resource rows as hashmap
	Resources []map[string]string
}

// NewTargetCollection initializes result type TargetCollection from viewed
// result type TargetCollection.
func NewTargetCollection(vres targetsviews.TargetCollection) TargetCollection {
	var res TargetCollection
	switch vres.View {
	case "default", "":
		res = newTargetCollection(vres.Projected)
	}
	return res
}

// NewViewedTargetCollection initializes viewed result type TargetCollection
// from result type TargetCollection using the given view.
func NewViewedTargetCollection(res TargetCollection, view string) targetsviews.TargetCollection {
	var vres targetsviews.TargetCollection
	switch view {
	case "default", "":
		p := newTargetCollectionView(res)
		vres = targetsviews.TargetCollection{p, "default"}
	}
	return vres
}

// NewTargetSummaryCollection initializes result type TargetSummaryCollection
// from viewed result type TargetSummaryCollection.
func NewTargetSummaryCollection(vres targetsviews.TargetSummaryCollection) TargetSummaryCollection {
	var res TargetSummaryCollection
	switch vres.View {
	case "default", "":
		res = newTargetSummaryCollection(vres.Projected)
	}
	return res
}

// NewViewedTargetSummaryCollection initializes viewed result type
// TargetSummaryCollection from result type TargetSummaryCollection using the
// given view.
func NewViewedTargetSummaryCollection(res TargetSummaryCollection, view string) targetsviews.TargetSummaryCollection {
	var vres targetsviews.TargetSummaryCollection
	switch view {
	case "default", "":
		p := newTargetSummaryCollectionView(res)
		vres = targetsviews.TargetSummaryCollection{p, "default"}
	}
	return vres
}

// NewTarget initializes result type Target from viewed result type Target.
func NewTarget(vres *targetsviews.Target) *Target {
	var res *Target
	switch vres.View {
	case "default", "":
		res = newTarget(vres.Projected)
	}
	return res
}

// NewViewedTarget initializes viewed result type Target from result type
// Target using the given view.
func NewViewedTarget(res *Target, view string) *targetsviews.Target {
	var vres *targetsviews.Target
	switch view {
	case "default", "":
		p := newTargetView(res)
		vres = &targetsviews.Target{p, "default"}
	}
	return vres
}

// NewFindingCollection initializes result type FindingCollection from viewed
// result type FindingCollection.
func NewFindingCollection(vres targetsviews.FindingCollection) FindingCollection {
	var res FindingCollection
	switch vres.View {
	case "default", "":
		res = newFindingCollection(vres.Projected)
	}
	return res
}

// NewViewedFindingCollection initializes viewed result type FindingCollection
// from result type FindingCollection using the given view.
func NewViewedFindingCollection(res FindingCollection, view string) targetsviews.FindingCollection {
	var vres targetsviews.FindingCollection
	switch view {
	case "default", "":
		p := newFindingCollectionView(res)
		vres = targetsviews.FindingCollection{p, "default"}
	}
	return vres
}

// NewFinding initializes result type Finding from viewed result type Finding.
func NewFinding(vres *targetsviews.Finding) *Finding {
	var res *Finding
	switch vres.View {
	case "default", "":
		res = newFinding(vres.Projected)
	}
	return res
}

// NewViewedFinding initializes viewed result type Finding from result type
// Finding using the given view.
func NewViewedFinding(res *Finding, view string) *targetsviews.Finding {
	var vres *targetsviews.Finding
	switch view {
	case "default", "":
		p := newFindingView(res)
		vres = &targetsviews.Finding{p, "default"}
	}
	return vres
}

// newTargetCollection converts projected type TargetCollection to service type
// TargetCollection.
func newTargetCollection(vres targetsviews.TargetCollectionView) TargetCollection {
	res := make(TargetCollection, len(vres))
	for i, n := range vres {
		res[i] = newTarget(n)
	}
	return res
}

// newTargetCollectionView projects result type TargetCollection to projected
// type TargetCollectionView using the "default" view.
func newTargetCollectionView(res TargetCollection) targetsviews.TargetCollectionView {
	vres := make(targetsviews.TargetCollectionView, len(res))
	for i, n := range res {
		vres[i] = newTargetView(n)
	}
	return vres
}

// newTarget converts projected type Target to service type Target.
func newTarget(vres *targetsviews.TargetView) *Target {
	res := &Target{
		ID:         vres.ID,
		Identifier: vres.Identifier,
	}
	if vres.Tags != nil {
		res.Tags = make([]string, len(vres.Tags))
		for i, val := range vres.Tags {
			res.Tags[i] = val
		}
	}
	return res
}

// newTargetView projects result type Target to projected type TargetView using
// the "default" view.
func newTargetView(res *Target) *targetsviews.TargetView {
	vres := &targetsviews.TargetView{
		ID:         res.ID,
		Identifier: res.Identifier,
	}
	if res.Tags != nil {
		vres.Tags = make([]string, len(res.Tags))
		for i, val := range res.Tags {
			vres.Tags[i] = val
		}
	}
	return vres
}

// newTargetSummaryCollection converts projected type TargetSummaryCollection
// to service type TargetSummaryCollection.
func newTargetSummaryCollection(vres targetsviews.TargetSummaryCollectionView) TargetSummaryCollection {
	res := make(TargetSummaryCollection, len(vres))
	for i, n := range vres {
		res[i] = newTargetSummary(n)
	}
	return res
}

// newTargetSummaryCollectionView projects result type TargetSummaryCollection
// to projected type TargetSummaryCollectionView using the "default" view.
func newTargetSummaryCollectionView(res TargetSummaryCollection) targetsviews.TargetSummaryCollectionView {
	vres := make(targetsviews.TargetSummaryCollectionView, len(res))
	for i, n := range res {
		vres[i] = newTargetSummaryView(n)
	}
	return vres
}

// newTargetSummary converts projected type TargetSummary to service type
// TargetSummary.
func newTargetSummary(vres *targetsviews.TargetSummaryView) *TargetSummary {
	res := &TargetSummary{
		TargetID:      vres.TargetID,
		Identifier:    vres.Identifier,
		FindingsCount: vres.FindingsCount,
		IssuesCount:   vres.IssuesCount,
		MaxScore:      vres.MaxScore,
	}
	return res
}

// newTargetSummaryView projects result type TargetSummary to projected type
// TargetSummaryView using the "default" view.
func newTargetSummaryView(res *TargetSummary) *targetsviews.TargetSummaryView {
	vres := &targetsviews.TargetSummaryView{
		TargetID:      res.TargetID,
		Identifier:    res.Identifier,
		FindingsCount: res.FindingsCount,
		IssuesCount:   res.IssuesCount,
		MaxScore:      res.MaxScore,
	}
	return vres
}

// newFindingCollection converts projected type FindingCollection to service
// type FindingCollection.
func newFindingCollection(vres targetsviews.FindingCollectionView) FindingCollection {
	res := make(FindingCollection, len(vres))
	for i, n := range vres {
		res[i] = newFinding(n)
	}
	return res
}

// newFindingCollectionView projects result type FindingCollection to projected
// type FindingCollectionView using the "default" view.
func newFindingCollectionView(res FindingCollection) targetsviews.FindingCollectionView {
	vres := make(targetsviews.FindingCollectionView, len(res))
	for i, n := range res {
		vres[i] = newFindingView(n)
	}
	return vres
}

// newFinding converts projected type Finding to service type Finding.
func newFinding(vres *targetsviews.FindingView) *Finding {
	res := &Finding{
		ID:            vres.ID,
		Details:       vres.Details,
		ImpactDetails: vres.ImpactDetails,
		Status:        vres.Status,
		Score:         vres.Score,
	}
	if vres.Target != nil {
		res.Target = transformTargetsviewsTargetViewToTarget(vres.Target)
	}
	if vres.Resources != nil {
		res.Resources = make([]*ResourceGroup, len(vres.Resources))
		for i, val := range vres.Resources {
			res.Resources[i] = transformTargetsviewsResourceGroupViewToResourceGroup(val)
		}
	}
	if vres.Issue != nil {
		res.Issue = newIssue(vres.Issue)
	}
	if vres.Source != nil {
		res.Source = newSourcewithnotarget(vres.Source)
	}
	return res
}

// newFindingView projects result type Finding to projected type FindingView
// using the "default" view.
func newFindingView(res *Finding) *targetsviews.FindingView {
	vres := &targetsviews.FindingView{
		ID:            res.ID,
		Details:       res.Details,
		ImpactDetails: res.ImpactDetails,
		Status:        res.Status,
		Score:         res.Score,
	}
	if res.Target != nil {
		vres.Target = transformTargetToTargetsviewsTargetView(res.Target)
	}
	if res.Resources != nil {
		vres.Resources = make([]*targetsviews.ResourceGroupView, len(res.Resources))
		for i, val := range res.Resources {
			vres.Resources[i] = transformResourceGroupToTargetsviewsResourceGroupView(val)
		}
	}
	if res.Issue != nil {
		vres.Issue = newIssueView(res.Issue)
	}
	if res.Source != nil {
		vres.Source = newSourcewithnotargetView(res.Source)
	}
	return vres
}

// newIssue converts projected type Issue to service type Issue.
func newIssue(vres *targetsviews.IssueView) *Issue {
	res := &Issue{
		ID:          vres.ID,
		Summary:     vres.Summary,
		CweID:       vres.CweID,
		Description: vres.Description,
	}
	if vres.Recommendations != nil {
		res.Recommendations = make([]string, len(vres.Recommendations))
		for i, val := range vres.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if vres.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(vres.ReferenceLinks))
		for i, val := range vres.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	if vres.Labels != nil {
		res.Labels = make([]string, len(vres.Labels))
		for i, val := range vres.Labels {
			res.Labels[i] = val
		}
	}
	return res
}

// newIssueView projects result type Issue to projected type IssueView using
// the "default" view.
func newIssueView(res *Issue) *targetsviews.IssueView {
	vres := &targetsviews.IssueView{
		ID:          res.ID,
		Summary:     res.Summary,
		CweID:       res.CweID,
		Description: res.Description,
	}
	if res.Recommendations != nil {
		vres.Recommendations = make([]string, len(res.Recommendations))
		for i, val := range res.Recommendations {
			vres.Recommendations[i] = val
		}
	}
	if res.ReferenceLinks != nil {
		vres.ReferenceLinks = make([]string, len(res.ReferenceLinks))
		for i, val := range res.ReferenceLinks {
			vres.ReferenceLinks[i] = val
		}
	}
	if res.Labels != nil {
		vres.Labels = make([]string, len(res.Labels))
		for i, val := range res.Labels {
			vres.Labels[i] = val
		}
	}
	return vres
}

// newSourcewithnotarget converts projected type Sourcewithnotarget to service
// type Sourcewithnotarget.
func newSourcewithnotarget(vres *targetsviews.SourcewithnotargetView) *Sourcewithnotarget {
	res := &Sourcewithnotarget{
		ID:        vres.ID,
		Name:      vres.Name,
		Component: vres.Component,
		Instance:  vres.Instance,
		Options:   vres.Options,
		Time:      vres.Time,
	}
	return res
}

// newSourcewithnotargetView projects result type Sourcewithnotarget to
// projected type SourcewithnotargetView using the "default" view.
func newSourcewithnotargetView(res *Sourcewithnotarget) *targetsviews.SourcewithnotargetView {
	vres := &targetsviews.SourcewithnotargetView{
		ID:        res.ID,
		Name:      res.Name,
		Component: res.Component,
		Instance:  res.Instance,
		Options:   res.Options,
		Time:      res.Time,
	}
	return vres
}

// newResourceGroup converts projected type ResourceGroup to service type
// ResourceGroup.
func newResourceGroup(vres *targetsviews.ResourceGroupView) *ResourceGroup {
	res := &ResourceGroup{
		Name: vres.Name,
	}
	if vres.Attributes != nil {
		res.Attributes = make([]string, len(vres.Attributes))
		for i, val := range vres.Attributes {
			res.Attributes[i] = val
		}
	}
	if vres.Resources != nil {
		res.Resources = make([]map[string]string, len(vres.Resources))
		for i, val := range vres.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}
	return res
}

// newResourceGroupView projects result type ResourceGroup to projected type
// ResourceGroupView using the "default" view.
func newResourceGroupView(res *ResourceGroup) *targetsviews.ResourceGroupView {
	vres := &targetsviews.ResourceGroupView{
		Name: res.Name,
	}
	if res.Attributes != nil {
		vres.Attributes = make([]string, len(res.Attributes))
		for i, val := range res.Attributes {
			vres.Attributes[i] = val
		}
	}
	if res.Resources != nil {
		vres.Resources = make([]map[string]string, len(res.Resources))
		for i, val := range res.Resources {
			vres.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				vres.Resources[i][tk] = tv
			}
		}
	}
	return vres
}

// transformTargetsviewsTargetViewToTarget builds a value of type *Target from
// a value of type *targetsviews.TargetView.
func transformTargetsviewsTargetViewToTarget(v *targetsviews.TargetView) *Target {
	if v == nil {
		return nil
	}
	res := &Target{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// transformTargetsviewsResourceGroupViewToResourceGroup builds a value of type
// *ResourceGroup from a value of type *targetsviews.ResourceGroupView.
func transformTargetsviewsResourceGroupViewToResourceGroup(v *targetsviews.ResourceGroupView) *ResourceGroup {
	if v == nil {
		return nil
	}
	res := &ResourceGroup{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// transformTargetToTargetsviewsTargetView builds a value of type
// *targetsviews.TargetView from a value of type *Target.
func transformTargetToTargetsviewsTargetView(v *Target) *targetsviews.TargetView {
	if v == nil {
		return nil
	}
	res := &targetsviews.TargetView{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// transformResourceGroupToTargetsviewsResourceGroupView builds a value of type
// *targetsviews.ResourceGroupView from a value of type *ResourceGroup.
func transformResourceGroupToTargetsviewsResourceGroupView(v *ResourceGroup) *targetsviews.ResourceGroupView {
	if v == nil {
		return nil
	}
	res := &targetsviews.ResourceGroupView{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}
