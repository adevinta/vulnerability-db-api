/*
Copyright 2021 Adevinta
*/

// Code generated by goa v3.0.6, DO NOT EDIT.
//
// issues service
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package issues

import (
	"context"

	issuesviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/issues/views"
)

// Issues endpoint.
type Service interface {
	// ListIssues implements List issues.
	ListIssues(context.Context, *ListIssuesPayload) (res IssueCollection, err error)
	// IssuesSummary implements Issues summary.
	IssuesSummary(context.Context, *IssuesSummaryPayload) (res IssueSummaryCollection, err error)
	// GetIssue implements Get issue.
	GetIssue(context.Context, *GetIssuePayload) (res *Issue, err error)
	// ListFindingsByIssue implements List findings by issue.
	ListFindingsByIssue(context.Context, *ListFindingsByIssuePayload) (res FindingCollection, err error)
	// ListFindingsByIssueAndTarget implements List findings by issue and target.
	ListFindingsByIssueAndTarget(context.Context, *ListFindingsByIssueAndTargetPayload) (res *Finding, err error)
	// GetIssueMTTR implements Get issue MTTR.
	GetIssueMTTR(context.Context, *GetIssueMTTRPayload) (res float32, err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "issues"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [6]string{"List issues", "Issues summary", "Get issue", "List findings by issue", "List findings by issue and target", "Get issue MTTR"}

// ListIssuesPayload is the payload type of the issues service List issues
// method.
type ListIssuesPayload struct {
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
}

// IssueCollection is the result type of the issues service List issues method.
type IssueCollection []*Issue

// IssuesSummaryPayload is the payload type of the issues service Issues
// summary method.
type IssuesSummaryPayload struct {
	// Targets tag filter
	Tag *string
	// Finding status filter. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Sorting criteria. Supported fields: score, targets_count (use - for
	// descending order. E.g.: -score)
	SortBy *string
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
}

// IssueSummaryCollection is the result type of the issues service Issues
// summary method.
type IssueSummaryCollection []*IssueSummary

// GetIssuePayload is the payload type of the issues service Get issue method.
type GetIssuePayload struct {
	// Issue ID
	ID *string
}

// Issue is the result type of the issues service Get issue method.
type Issue struct {
	// Issue ID
	ID *string
	// Issue summary
	Summary *string
	// Common Weakness Enumeration ID
	CweID *int
	// Issue description
	Description *string
	// Recommendations to fix the issue
	Recommendations []string
	// Documentation reference for the issue
	ReferenceLinks []string
}

// ListFindingsByIssuePayload is the payload type of the issues service List
// findings by issue method.
type ListFindingsByIssuePayload struct {
	// Issue ID
	ID *string
	// Finding status filter. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Sorting criteria. Supported fields: score, -score (for descending order)
	SortBy *string
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
}

// FindingCollection is the result type of the issues service List findings by
// issue method.
type FindingCollection []*Finding

// ListFindingsByIssueAndTargetPayload is the payload type of the issues
// service List findings by issue and target method.
type ListFindingsByIssueAndTargetPayload struct {
	// Issue ID
	IssueID *string
	// Target ID
	TargetID *string
}

// Finding is the result type of the issues service List findings by issue and
// target method.
type Finding struct {
	// Finding ID
	ID *string
	// Issue
	Issue *Issue
	// Target
	Target *Target
	// Source
	Source *Sourcewithnotarget
	// Finding details
	Details *string
	// Finding impact details
	ImpactDetails *string
	// Finding status. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Finding severity score
	Score *float32
	// Other resources associated with the finding
	Resources []*ResourceGroup
}

// GetIssueMTTRPayload is the payload type of the issues service Get issue MTTR
// method.
type GetIssueMTTRPayload struct {
	// Issue ID
	ID *string
}

type IssueSummary struct {
	// Issue ID
	IssueID *string
	// Issue summary
	Summary *string
	// Number of affected targets for issue
	TargetsCount *int
	// Max score for issue
	MaxScore *float32
}

type Target struct {
	// Target ID
	ID *string
	// Target identifier
	Identifier *string
	// List of tags associated with target
	Tags []string
}

type Sourcewithnotarget struct {
	// Source ID
	ID *string
	// Source name
	Name *string
	// Source component
	Component *string
	// Source instance
	Instance *string
	// Source options
	Options *string
	// Time on which the source scanned the target
	Time *string
}

type ResourceGroup struct {
	// Name of the resource group
	Name *string
	// Column names of the resource group in the order that should be rendered
	Attributes []string
	// List containing the resource rows as hashmap
	Resources []map[string]string
}

// NewIssueCollection initializes result type IssueCollection from viewed
// result type IssueCollection.
func NewIssueCollection(vres issuesviews.IssueCollection) IssueCollection {
	var res IssueCollection
	switch vres.View {
	case "default", "":
		res = newIssueCollection(vres.Projected)
	}
	return res
}

// NewViewedIssueCollection initializes viewed result type IssueCollection from
// result type IssueCollection using the given view.
func NewViewedIssueCollection(res IssueCollection, view string) issuesviews.IssueCollection {
	var vres issuesviews.IssueCollection
	switch view {
	case "default", "":
		p := newIssueCollectionView(res)
		vres = issuesviews.IssueCollection{p, "default"}
	}
	return vres
}

// NewIssueSummaryCollection initializes result type IssueSummaryCollection
// from viewed result type IssueSummaryCollection.
func NewIssueSummaryCollection(vres issuesviews.IssueSummaryCollection) IssueSummaryCollection {
	var res IssueSummaryCollection
	switch vres.View {
	case "default", "":
		res = newIssueSummaryCollection(vres.Projected)
	}
	return res
}

// NewViewedIssueSummaryCollection initializes viewed result type
// IssueSummaryCollection from result type IssueSummaryCollection using the
// given view.
func NewViewedIssueSummaryCollection(res IssueSummaryCollection, view string) issuesviews.IssueSummaryCollection {
	var vres issuesviews.IssueSummaryCollection
	switch view {
	case "default", "":
		p := newIssueSummaryCollectionView(res)
		vres = issuesviews.IssueSummaryCollection{p, "default"}
	}
	return vres
}

// NewIssue initializes result type Issue from viewed result type Issue.
func NewIssue(vres *issuesviews.Issue) *Issue {
	var res *Issue
	switch vres.View {
	case "default", "":
		res = newIssue(vres.Projected)
	}
	return res
}

// NewViewedIssue initializes viewed result type Issue from result type Issue
// using the given view.
func NewViewedIssue(res *Issue, view string) *issuesviews.Issue {
	var vres *issuesviews.Issue
	switch view {
	case "default", "":
		p := newIssueView(res)
		vres = &issuesviews.Issue{p, "default"}
	}
	return vres
}

// NewFindingCollection initializes result type FindingCollection from viewed
// result type FindingCollection.
func NewFindingCollection(vres issuesviews.FindingCollection) FindingCollection {
	var res FindingCollection
	switch vres.View {
	case "default", "":
		res = newFindingCollection(vres.Projected)
	}
	return res
}

// NewViewedFindingCollection initializes viewed result type FindingCollection
// from result type FindingCollection using the given view.
func NewViewedFindingCollection(res FindingCollection, view string) issuesviews.FindingCollection {
	var vres issuesviews.FindingCollection
	switch view {
	case "default", "":
		p := newFindingCollectionView(res)
		vres = issuesviews.FindingCollection{p, "default"}
	}
	return vres
}

// NewFinding initializes result type Finding from viewed result type Finding.
func NewFinding(vres *issuesviews.Finding) *Finding {
	var res *Finding
	switch vres.View {
	case "default", "":
		res = newFinding(vres.Projected)
	}
	return res
}

// NewViewedFinding initializes viewed result type Finding from result type
// Finding using the given view.
func NewViewedFinding(res *Finding, view string) *issuesviews.Finding {
	var vres *issuesviews.Finding
	switch view {
	case "default", "":
		p := newFindingView(res)
		vres = &issuesviews.Finding{p, "default"}
	}
	return vres
}

// newIssueCollection converts projected type IssueCollection to service type
// IssueCollection.
func newIssueCollection(vres issuesviews.IssueCollectionView) IssueCollection {
	res := make(IssueCollection, len(vres))
	for i, n := range vres {
		res[i] = newIssue(n)
	}
	return res
}

// newIssueCollectionView projects result type IssueCollection to projected
// type IssueCollectionView using the "default" view.
func newIssueCollectionView(res IssueCollection) issuesviews.IssueCollectionView {
	vres := make(issuesviews.IssueCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIssueView(n)
	}
	return vres
}

// newIssue converts projected type Issue to service type Issue.
func newIssue(vres *issuesviews.IssueView) *Issue {
	res := &Issue{
		ID:          vres.ID,
		Summary:     vres.Summary,
		CweID:       vres.CweID,
		Description: vres.Description,
	}
	if vres.Recommendations != nil {
		res.Recommendations = make([]string, len(vres.Recommendations))
		for i, val := range vres.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if vres.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(vres.ReferenceLinks))
		for i, val := range vres.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	return res
}

// newIssueView projects result type Issue to projected type IssueView using
// the "default" view.
func newIssueView(res *Issue) *issuesviews.IssueView {
	vres := &issuesviews.IssueView{
		ID:          res.ID,
		Summary:     res.Summary,
		CweID:       res.CweID,
		Description: res.Description,
	}
	if res.Recommendations != nil {
		vres.Recommendations = make([]string, len(res.Recommendations))
		for i, val := range res.Recommendations {
			vres.Recommendations[i] = val
		}
	}
	if res.ReferenceLinks != nil {
		vres.ReferenceLinks = make([]string, len(res.ReferenceLinks))
		for i, val := range res.ReferenceLinks {
			vres.ReferenceLinks[i] = val
		}
	}
	return vres
}

// newIssueSummaryCollection converts projected type IssueSummaryCollection to
// service type IssueSummaryCollection.
func newIssueSummaryCollection(vres issuesviews.IssueSummaryCollectionView) IssueSummaryCollection {
	res := make(IssueSummaryCollection, len(vres))
	for i, n := range vres {
		res[i] = newIssueSummary(n)
	}
	return res
}

// newIssueSummaryCollectionView projects result type IssueSummaryCollection to
// projected type IssueSummaryCollectionView using the "default" view.
func newIssueSummaryCollectionView(res IssueSummaryCollection) issuesviews.IssueSummaryCollectionView {
	vres := make(issuesviews.IssueSummaryCollectionView, len(res))
	for i, n := range res {
		vres[i] = newIssueSummaryView(n)
	}
	return vres
}

// newIssueSummary converts projected type IssueSummary to service type
// IssueSummary.
func newIssueSummary(vres *issuesviews.IssueSummaryView) *IssueSummary {
	res := &IssueSummary{
		IssueID:      vres.IssueID,
		Summary:      vres.Summary,
		TargetsCount: vres.TargetsCount,
		MaxScore:     vres.MaxScore,
	}
	return res
}

// newIssueSummaryView projects result type IssueSummary to projected type
// IssueSummaryView using the "default" view.
func newIssueSummaryView(res *IssueSummary) *issuesviews.IssueSummaryView {
	vres := &issuesviews.IssueSummaryView{
		IssueID:      res.IssueID,
		Summary:      res.Summary,
		TargetsCount: res.TargetsCount,
		MaxScore:     res.MaxScore,
	}
	return vres
}

// newFindingCollection converts projected type FindingCollection to service
// type FindingCollection.
func newFindingCollection(vres issuesviews.FindingCollectionView) FindingCollection {
	res := make(FindingCollection, len(vres))
	for i, n := range vres {
		res[i] = newFinding(n)
	}
	return res
}

// newFindingCollectionView projects result type FindingCollection to projected
// type FindingCollectionView using the "default" view.
func newFindingCollectionView(res FindingCollection) issuesviews.FindingCollectionView {
	vres := make(issuesviews.FindingCollectionView, len(res))
	for i, n := range res {
		vres[i] = newFindingView(n)
	}
	return vres
}

// newFinding converts projected type Finding to service type Finding.
func newFinding(vres *issuesviews.FindingView) *Finding {
	res := &Finding{
		ID:            vres.ID,
		Details:       vres.Details,
		ImpactDetails: vres.ImpactDetails,
		Status:        vres.Status,
		Score:         vres.Score,
	}
	if vres.Target != nil {
		res.Target = transformIssuesviewsTargetViewToTarget(vres.Target)
	}
	if vres.Resources != nil {
		res.Resources = make([]*ResourceGroup, len(vres.Resources))
		for i, val := range vres.Resources {
			res.Resources[i] = transformIssuesviewsResourceGroupViewToResourceGroup(val)
		}
	}
	if vres.Issue != nil {
		res.Issue = newIssue(vres.Issue)
	}
	if vres.Source != nil {
		res.Source = newSourcewithnotarget(vres.Source)
	}
	return res
}

// newFindingView projects result type Finding to projected type FindingView
// using the "default" view.
func newFindingView(res *Finding) *issuesviews.FindingView {
	vres := &issuesviews.FindingView{
		ID:            res.ID,
		Details:       res.Details,
		ImpactDetails: res.ImpactDetails,
		Status:        res.Status,
		Score:         res.Score,
	}
	if res.Target != nil {
		vres.Target = transformTargetToIssuesviewsTargetView(res.Target)
	}
	if res.Resources != nil {
		vres.Resources = make([]*issuesviews.ResourceGroupView, len(res.Resources))
		for i, val := range res.Resources {
			vres.Resources[i] = transformResourceGroupToIssuesviewsResourceGroupView(val)
		}
	}
	if res.Issue != nil {
		vres.Issue = newIssueView(res.Issue)
	}
	if res.Source != nil {
		vres.Source = newSourcewithnotargetView(res.Source)
	}
	return vres
}

// newTarget converts projected type Target to service type Target.
func newTarget(vres *issuesviews.TargetView) *Target {
	res := &Target{
		ID:         vres.ID,
		Identifier: vres.Identifier,
	}
	if vres.Tags != nil {
		res.Tags = make([]string, len(vres.Tags))
		for i, val := range vres.Tags {
			res.Tags[i] = val
		}
	}
	return res
}

// newTargetView projects result type Target to projected type TargetView using
// the "default" view.
func newTargetView(res *Target) *issuesviews.TargetView {
	vres := &issuesviews.TargetView{
		ID:         res.ID,
		Identifier: res.Identifier,
	}
	if res.Tags != nil {
		vres.Tags = make([]string, len(res.Tags))
		for i, val := range res.Tags {
			vres.Tags[i] = val
		}
	}
	return vres
}

// newSourcewithnotarget converts projected type Sourcewithnotarget to service
// type Sourcewithnotarget.
func newSourcewithnotarget(vres *issuesviews.SourcewithnotargetView) *Sourcewithnotarget {
	res := &Sourcewithnotarget{
		ID:        vres.ID,
		Name:      vres.Name,
		Component: vres.Component,
		Instance:  vres.Instance,
		Options:   vres.Options,
		Time:      vres.Time,
	}
	return res
}

// newSourcewithnotargetView projects result type Sourcewithnotarget to
// projected type SourcewithnotargetView using the "default" view.
func newSourcewithnotargetView(res *Sourcewithnotarget) *issuesviews.SourcewithnotargetView {
	vres := &issuesviews.SourcewithnotargetView{
		ID:        res.ID,
		Name:      res.Name,
		Component: res.Component,
		Instance:  res.Instance,
		Options:   res.Options,
		Time:      res.Time,
	}
	return vres
}

// newResourceGroup converts projected type ResourceGroup to service type
// ResourceGroup.
func newResourceGroup(vres *issuesviews.ResourceGroupView) *ResourceGroup {
	res := &ResourceGroup{
		Name: vres.Name,
	}
	if vres.Attributes != nil {
		res.Attributes = make([]string, len(vres.Attributes))
		for i, val := range vres.Attributes {
			res.Attributes[i] = val
		}
	}
	if vres.Resources != nil {
		res.Resources = make([]map[string]string, len(vres.Resources))
		for i, val := range vres.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}
	return res
}

// newResourceGroupView projects result type ResourceGroup to projected type
// ResourceGroupView using the "default" view.
func newResourceGroupView(res *ResourceGroup) *issuesviews.ResourceGroupView {
	vres := &issuesviews.ResourceGroupView{
		Name: res.Name,
	}
	if res.Attributes != nil {
		vres.Attributes = make([]string, len(res.Attributes))
		for i, val := range res.Attributes {
			vres.Attributes[i] = val
		}
	}
	if res.Resources != nil {
		vres.Resources = make([]map[string]string, len(res.Resources))
		for i, val := range res.Resources {
			vres.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				vres.Resources[i][tk] = tv
			}
		}
	}
	return vres
}

// transformIssuesviewsTargetViewToTarget builds a value of type *Target from a
// value of type *issuesviews.TargetView.
func transformIssuesviewsTargetViewToTarget(v *issuesviews.TargetView) *Target {
	if v == nil {
		return nil
	}
	res := &Target{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// transformIssuesviewsResourceGroupViewToResourceGroup builds a value of type
// *ResourceGroup from a value of type *issuesviews.ResourceGroupView.
func transformIssuesviewsResourceGroupViewToResourceGroup(v *issuesviews.ResourceGroupView) *ResourceGroup {
	if v == nil {
		return nil
	}
	res := &ResourceGroup{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// transformTargetToIssuesviewsTargetView builds a value of type
// *issuesviews.TargetView from a value of type *Target.
func transformTargetToIssuesviewsTargetView(v *Target) *issuesviews.TargetView {
	if v == nil {
		return nil
	}
	res := &issuesviews.TargetView{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// transformResourceGroupToIssuesviewsResourceGroupView builds a value of type
// *issuesviews.ResourceGroupView from a value of type *ResourceGroup.
func transformResourceGroupToIssuesviewsResourceGroupView(v *ResourceGroup) *issuesviews.ResourceGroupView {
	if v == nil {
		return nil
	}
	res := &issuesviews.ResourceGroupView{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}
