/*
Copyright 2021 Adevinta
*/

// Code generated by goa v3.0.6, DO NOT EDIT.
//
// sources HTTP client types
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	sourcesviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/sources/views"
)

// ListSourcesResponseBody is the type of the "sources" service "List sources"
// endpoint HTTP response body.
type ListSourcesResponseBody []*SourceResponse

// GetSourceResponseBody is the type of the "sources" service "Get source"
// endpoint HTTP response body.
type GetSourceResponseBody struct {
	// Source ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Target ID
	TargetID *string `form:"target_id,omitempty" json:"target_id,omitempty" xml:"target_id,omitempty"`
	// Source name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Source component
	Component *string `form:"component,omitempty" json:"component,omitempty" xml:"component,omitempty"`
	// Source instance
	Instance *string `form:"instance,omitempty" json:"instance,omitempty" xml:"instance,omitempty"`
	// Source options
	Options *string `form:"options,omitempty" json:"options,omitempty" xml:"options,omitempty"`
	// Time on which the source scanned the target
	Time *string `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
}

// ListFindingsBySourceResponseBody is the type of the "sources" service "List
// findings by source" endpoint HTTP response body.
type ListFindingsBySourceResponseBody []*FindingResponse

// SourceResponse is used to define fields on response body types.
type SourceResponse struct {
	// Source ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Target ID
	TargetID *string `form:"target_id,omitempty" json:"target_id,omitempty" xml:"target_id,omitempty"`
	// Source name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Source component
	Component *string `form:"component,omitempty" json:"component,omitempty" xml:"component,omitempty"`
	// Source instance
	Instance *string `form:"instance,omitempty" json:"instance,omitempty" xml:"instance,omitempty"`
	// Source options
	Options *string `form:"options,omitempty" json:"options,omitempty" xml:"options,omitempty"`
	// Time on which the source scanned the target
	Time *string `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
}

// FindingResponse is used to define fields on response body types.
type FindingResponse struct {
	// Finding ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Issue
	Issue *IssueResponse `form:"issue,omitempty" json:"issue,omitempty" xml:"issue,omitempty"`
	// Target
	Target *TargetResponse `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
	// Source
	Source *SourcewithnotargetResponse `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// Finding details
	Details *string `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
	// Finding impact details
	ImpactDetails *string `form:"impact_details,omitempty" json:"impact_details,omitempty" xml:"impact_details,omitempty"`
	// Finding status. Can be 'OPEN' or 'FIXED'.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Finding severity score
	Score *float32 `form:"score,omitempty" json:"score,omitempty" xml:"score,omitempty"`
	// Other resources associated with the finding
	Resources []*ResourceGroupResponse `form:"resources,omitempty" json:"resources,omitempty" xml:"resources,omitempty"`
}

// IssueResponse is used to define fields on response body types.
type IssueResponse struct {
	// Issue ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Issue summary
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// Common Weakness Enumeration ID
	CweID *int `form:"cwe_id,omitempty" json:"cwe_id,omitempty" xml:"cwe_id,omitempty"`
	// Issue description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Recommendations to fix the issue
	Recommendations []string `form:"recommendations,omitempty" json:"recommendations,omitempty" xml:"recommendations,omitempty"`
	// Documentation reference for the issue
	ReferenceLinks []string `form:"reference_links,omitempty" json:"reference_links,omitempty" xml:"reference_links,omitempty"`
}

// TargetResponse is used to define fields on response body types.
type TargetResponse struct {
	// Target ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Target identifier
	Identifier *string `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// List of tags associated with target
	Tags []string `form:"tags,omitempty" json:"tags,omitempty" xml:"tags,omitempty"`
}

// SourcewithnotargetResponse is used to define fields on response body types.
type SourcewithnotargetResponse struct {
	// Source ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Source name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Source component
	Component *string `form:"component,omitempty" json:"component,omitempty" xml:"component,omitempty"`
	// Source instance
	Instance *string `form:"instance,omitempty" json:"instance,omitempty" xml:"instance,omitempty"`
	// Source options
	Options *string `form:"options,omitempty" json:"options,omitempty" xml:"options,omitempty"`
	// Time on which the source scanned the target
	Time *string `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
}

// ResourceGroupResponse is used to define fields on response body types.
type ResourceGroupResponse struct {
	// Name of the resource group
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Column names of the resource group in the order that should be rendered
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// List containing the resource rows as hashmap
	Resources []map[string]string `form:"resources,omitempty" json:"resources,omitempty" xml:"resources,omitempty"`
}

// NewListSourcesSourceCollectionOK builds a "sources" service "List sources"
// endpoint result from a HTTP "OK" response.
func NewListSourcesSourceCollectionOK(body ListSourcesResponseBody) sourcesviews.SourceCollectionView {
	v := make([]*sourcesviews.SourceView, len(body))
	for i, val := range body {
		v[i] = &sourcesviews.SourceView{
			ID:        val.ID,
			TargetID:  val.TargetID,
			Name:      val.Name,
			Component: val.Component,
			Instance:  val.Instance,
			Options:   val.Options,
			Time:      val.Time,
		}
	}
	return v
}

// NewGetSourceSourceOK builds a "sources" service "Get source" endpoint result
// from a HTTP "OK" response.
func NewGetSourceSourceOK(body *GetSourceResponseBody) *sourcesviews.SourceView {
	v := &sourcesviews.SourceView{
		ID:        body.ID,
		TargetID:  body.TargetID,
		Name:      body.Name,
		Component: body.Component,
		Instance:  body.Instance,
		Options:   body.Options,
		Time:      body.Time,
	}
	return v
}

// NewListFindingsBySourceFindingCollectionOK builds a "sources" service "List
// findings by source" endpoint result from a HTTP "OK" response.
func NewListFindingsBySourceFindingCollectionOK(body ListFindingsBySourceResponseBody) sourcesviews.FindingCollectionView {
	v := make([]*sourcesviews.FindingView, len(body))
	for i, val := range body {
		v[i] = &sourcesviews.FindingView{
			ID:            val.ID,
			Details:       val.Details,
			ImpactDetails: val.ImpactDetails,
			Status:        val.Status,
			Score:         val.Score,
		}
		if val.Issue != nil {
			v[i].Issue = unmarshalIssueResponseToSourcesviewsIssueView(val.Issue)
		}
		if val.Target != nil {
			v[i].Target = unmarshalTargetResponseToSourcesviewsTargetView(val.Target)
		}
		if val.Source != nil {
			v[i].Source = unmarshalSourcewithnotargetResponseToSourcesviewsSourcewithnotargetView(val.Source)
		}
		if val.Resources != nil {
			v[i].Resources = make([]*sourcesviews.ResourceGroupView, len(val.Resources))
			for j, val := range val.Resources {
				v[i].Resources[j] = unmarshalResourceGroupResponseToSourcesviewsResourceGroupView(val)
			}
		}
	}
	return v
}
