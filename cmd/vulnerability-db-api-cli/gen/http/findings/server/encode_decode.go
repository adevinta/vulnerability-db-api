// Code generated by goa v3.0.6, DO NOT EDIT.
//
// findings HTTP server encoders and decoders
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package server

import (
	"context"
	"net/http"
	"strconv"

	findingsviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/findings/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeListFindingsResponse returns an encoder for responses returned by the
// findings List findings endpoint.
func EncodeListFindingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(findingsviews.FindingCollection)
		enc := encoder(ctx, w)
		body := NewFindingResponseCollection(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListFindingsRequest returns a decoder for requests sent to the
// findings List findings endpoint.
func DecodeListFindingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			tag      *string
			status   *string
			minScore *int
			maxScore *int
			atDate   *string
			minDate  *string
			maxDate  *string
			sortBy   *string
			page     *int
			size     *int
			err      error
		)
		tagRaw := r.URL.Query().Get("tag")
		if tagRaw != "" {
			tag = &tagRaw
		}
		statusRaw := r.URL.Query().Get("status")
		if statusRaw != "" {
			status = &statusRaw
		}
		{
			minScoreRaw := r.URL.Query().Get("minScore")
			if minScoreRaw != "" {
				v, err2 := strconv.ParseInt(minScoreRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("minScore", minScoreRaw, "integer"))
				}
				pv := int(v)
				minScore = &pv
			}
		}
		{
			maxScoreRaw := r.URL.Query().Get("maxScore")
			if maxScoreRaw != "" {
				v, err2 := strconv.ParseInt(maxScoreRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("maxScore", maxScoreRaw, "integer"))
				}
				pv := int(v)
				maxScore = &pv
			}
		}
		atDateRaw := r.URL.Query().Get("atDate")
		if atDateRaw != "" {
			atDate = &atDateRaw
		}
		minDateRaw := r.URL.Query().Get("minDate")
		if minDateRaw != "" {
			minDate = &minDateRaw
		}
		maxDateRaw := r.URL.Query().Get("maxDate")
		if maxDateRaw != "" {
			maxDate = &maxDateRaw
		}
		sortByRaw := r.URL.Query().Get("sortBy")
		if sortByRaw != "" {
			sortBy = &sortByRaw
		}
		{
			pageRaw := r.URL.Query().Get("page")
			if pageRaw != "" {
				v, err2 := strconv.ParseInt(pageRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("page", pageRaw, "integer"))
				}
				pv := int(v)
				page = &pv
			}
		}
		{
			sizeRaw := r.URL.Query().Get("size")
			if sizeRaw != "" {
				v, err2 := strconv.ParseInt(sizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("size", sizeRaw, "integer"))
				}
				pv := int(v)
				size = &pv
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewListFindingsPayload(tag, status, minScore, maxScore, atDate, minDate, maxDate, sortBy, page, size)

		return payload, nil
	}
}

// EncodeGetFindingResponse returns an encoder for responses returned by the
// findings Get finding endpoint.
func EncodeGetFindingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*findingsviews.Finding)
		enc := encoder(ctx, w)
		body := NewGetFindingResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetFindingRequest returns a decoder for requests sent to the findings
// Get finding endpoint.
func DecodeGetFindingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id string

			params = mux.Vars(r)
		)
		id = params["id"]
		payload := NewGetFindingPayload(id)

		return payload, nil
	}
}

// EncodeListEventsByFindingResponse returns an encoder for responses returned
// by the findings List events by finding endpoint.
func EncodeListEventsByFindingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(findingsviews.EventCollection)
		enc := encoder(ctx, w)
		body := NewEventResponseCollection(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListEventsByFindingRequest returns a decoder for requests sent to the
// findings List events by finding endpoint.
func DecodeListEventsByFindingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id   string
			page *int
			size *int
			err  error

			params = mux.Vars(r)
		)
		id = params["id"]
		{
			pageRaw := r.URL.Query().Get("page")
			if pageRaw != "" {
				v, err2 := strconv.ParseInt(pageRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("page", pageRaw, "integer"))
				}
				pv := int(v)
				page = &pv
			}
		}
		{
			sizeRaw := r.URL.Query().Get("size")
			if sizeRaw != "" {
				v, err2 := strconv.ParseInt(sizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("size", sizeRaw, "integer"))
				}
				pv := int(v)
				size = &pv
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewListEventsByFindingPayload(id, page, size)

		return payload, nil
	}
}

// EncodeGetFindingMTTRResponse returns an encoder for responses returned by
// the findings Get finding MTTR endpoint.
func EncodeGetFindingMTTRResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*findingsviews.Mttr)
		enc := encoder(ctx, w)
		body := NewGetFindingMTTRResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetFindingMTTRRequest returns a decoder for requests sent to the
// findings Get finding MTTR endpoint.
func DecodeGetFindingMTTRRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id string

			params = mux.Vars(r)
		)
		id = params["id"]
		payload := NewGetFindingMTTRPayload(id)

		return payload, nil
	}
}

// marshalFindingsviewsIssueViewToIssueResponse builds a value of type
// *IssueResponse from a value of type *findingsviews.IssueView.
func marshalFindingsviewsIssueViewToIssueResponse(v *findingsviews.IssueView) *IssueResponse {
	if v == nil {
		return nil
	}
	res := &IssueResponse{
		ID:          v.ID,
		Summary:     v.Summary,
		CweID:       v.CweID,
		Description: v.Description,
	}
	if v.Recommendations != nil {
		res.Recommendations = make([]string, len(v.Recommendations))
		for i, val := range v.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if v.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(v.ReferenceLinks))
		for i, val := range v.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}

	return res
}

// marshalFindingsviewsTargetViewToTargetResponse builds a value of type
// *TargetResponse from a value of type *findingsviews.TargetView.
func marshalFindingsviewsTargetViewToTargetResponse(v *findingsviews.TargetView) *TargetResponse {
	if v == nil {
		return nil
	}
	res := &TargetResponse{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// marshalFindingsviewsSourcewithnotargetViewToSourcewithnotargetResponse
// builds a value of type *SourcewithnotargetResponse from a value of type
// *findingsviews.SourcewithnotargetView.
func marshalFindingsviewsSourcewithnotargetViewToSourcewithnotargetResponse(v *findingsviews.SourcewithnotargetView) *SourcewithnotargetResponse {
	if v == nil {
		return nil
	}
	res := &SourcewithnotargetResponse{
		ID:        v.ID,
		Name:      v.Name,
		Component: v.Component,
		Instance:  v.Instance,
		Options:   v.Options,
		Time:      v.Time,
	}

	return res
}

// marshalFindingsviewsResourceGroupViewToResourceGroupResponse builds a value
// of type *ResourceGroupResponse from a value of type
// *findingsviews.ResourceGroupView.
func marshalFindingsviewsResourceGroupViewToResourceGroupResponse(v *findingsviews.ResourceGroupView) *ResourceGroupResponse {
	if v == nil {
		return nil
	}
	res := &ResourceGroupResponse{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// marshalFindingsviewsIssueViewToIssueResponseBody builds a value of type
// *IssueResponseBody from a value of type *findingsviews.IssueView.
func marshalFindingsviewsIssueViewToIssueResponseBody(v *findingsviews.IssueView) *IssueResponseBody {
	if v == nil {
		return nil
	}
	res := &IssueResponseBody{
		ID:          v.ID,
		Summary:     v.Summary,
		CweID:       v.CweID,
		Description: v.Description,
	}
	if v.Recommendations != nil {
		res.Recommendations = make([]string, len(v.Recommendations))
		for i, val := range v.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if v.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(v.ReferenceLinks))
		for i, val := range v.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}

	return res
}

// marshalFindingsviewsTargetViewToTargetResponseBody builds a value of type
// *TargetResponseBody from a value of type *findingsviews.TargetView.
func marshalFindingsviewsTargetViewToTargetResponseBody(v *findingsviews.TargetView) *TargetResponseBody {
	if v == nil {
		return nil
	}
	res := &TargetResponseBody{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// marshalFindingsviewsSourcewithnotargetViewToSourcewithnotargetResponseBody
// builds a value of type *SourcewithnotargetResponseBody from a value of type
// *findingsviews.SourcewithnotargetView.
func marshalFindingsviewsSourcewithnotargetViewToSourcewithnotargetResponseBody(v *findingsviews.SourcewithnotargetView) *SourcewithnotargetResponseBody {
	if v == nil {
		return nil
	}
	res := &SourcewithnotargetResponseBody{
		ID:        v.ID,
		Name:      v.Name,
		Component: v.Component,
		Instance:  v.Instance,
		Options:   v.Options,
		Time:      v.Time,
	}

	return res
}

// marshalFindingsviewsResourceGroupViewToResourceGroupResponseBody builds a
// value of type *ResourceGroupResponseBody from a value of type
// *findingsviews.ResourceGroupView.
func marshalFindingsviewsResourceGroupViewToResourceGroupResponseBody(v *findingsviews.ResourceGroupView) *ResourceGroupResponseBody {
	if v == nil {
		return nil
	}
	res := &ResourceGroupResponseBody{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}
