// Code generated by goa v3.0.6, DO NOT EDIT.
//
// findings HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"fmt"
	"strconv"

	findings "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/findings"
)

// BuildListFindingsPayload builds the payload for the findings List findings
// endpoint from CLI flags.
func BuildListFindingsPayload(findingsListFindingsTag string, findingsListFindingsStatus string, findingsListFindingsMinScore string, findingsListFindingsMaxScore string, findingsListFindingsAtDate string, findingsListFindingsMinDate string, findingsListFindingsMaxDate string, findingsListFindingsSortBy string, findingsListFindingsPage string, findingsListFindingsSize string) (*findings.ListFindingsPayload, error) {
	var err error
	var tag *string
	{
		if findingsListFindingsTag != "" {
			tag = &findingsListFindingsTag
		}
	}
	var status *string
	{
		if findingsListFindingsStatus != "" {
			status = &findingsListFindingsStatus
		}
	}
	var minScore *int
	{
		if findingsListFindingsMinScore != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListFindingsMinScore, 10, 64)
			val := int(v)
			minScore = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for minScore, must be INT")
			}
		}
	}
	var maxScore *int
	{
		if findingsListFindingsMaxScore != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListFindingsMaxScore, 10, 64)
			val := int(v)
			maxScore = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for maxScore, must be INT")
			}
		}
	}
	var atDate *string
	{
		if findingsListFindingsAtDate != "" {
			atDate = &findingsListFindingsAtDate
		}
	}
	var minDate *string
	{
		if findingsListFindingsMinDate != "" {
			minDate = &findingsListFindingsMinDate
		}
	}
	var maxDate *string
	{
		if findingsListFindingsMaxDate != "" {
			maxDate = &findingsListFindingsMaxDate
		}
	}
	var sortBy *string
	{
		if findingsListFindingsSortBy != "" {
			sortBy = &findingsListFindingsSortBy
		}
	}
	var page *int
	{
		if findingsListFindingsPage != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListFindingsPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if findingsListFindingsSize != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListFindingsSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	payload := &findings.ListFindingsPayload{
		Tag:      tag,
		Status:   status,
		MinScore: minScore,
		MaxScore: maxScore,
		AtDate:   atDate,
		MinDate:  minDate,
		MaxDate:  maxDate,
		SortBy:   sortBy,
		Page:     page,
		Size:     size,
	}
	return payload, nil
}

// BuildGetFindingPayload builds the payload for the findings Get finding
// endpoint from CLI flags.
func BuildGetFindingPayload(findingsGetFindingID string) (*findings.GetFindingPayload, error) {
	var id string
	{
		id = findingsGetFindingID
	}
	payload := &findings.GetFindingPayload{
		ID: &id,
	}
	return payload, nil
}

// BuildListEventsByFindingPayload builds the payload for the findings List
// events by finding endpoint from CLI flags.
func BuildListEventsByFindingPayload(findingsListEventsByFindingID string, findingsListEventsByFindingPage string, findingsListEventsByFindingSize string) (*findings.ListEventsByFindingPayload, error) {
	var err error
	var id string
	{
		id = findingsListEventsByFindingID
	}
	var page *int
	{
		if findingsListEventsByFindingPage != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListEventsByFindingPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if findingsListEventsByFindingSize != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListEventsByFindingSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	payload := &findings.ListEventsByFindingPayload{
		ID:   &id,
		Page: page,
		Size: size,
	}
	return payload, nil
}

// BuildGetFindingMTTRPayload builds the payload for the findings Get finding
// MTTR endpoint from CLI flags.
func BuildGetFindingMTTRPayload(findingsGetFindingMTTRID string) (*findings.GetFindingMTTRPayload, error) {
	var id string
	{
		id = findingsGetFindingMTTRID
	}
	payload := &findings.GetFindingMTTRPayload{
		ID: &id,
	}
	return payload, nil
}
