// Code generated by goa v3.5.2, DO NOT EDIT.
//
// findings HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	findings "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/findings"
)

// BuildListFindingsPayload builds the payload for the findings List findings
// endpoint from CLI flags.
func BuildListFindingsPayload(findingsListFindingsTeam string, findingsListFindingsTag string, findingsListFindingsStatus string, findingsListFindingsMinScore string, findingsListFindingsMaxScore string, findingsListFindingsAtDate string, findingsListFindingsMinDate string, findingsListFindingsMaxDate string, findingsListFindingsSortBy string, findingsListFindingsPage string, findingsListFindingsSize string, findingsListFindingsIdentifier string, findingsListFindingsIdentifiermatch string, findingsListFindingsIdentifiers string, findingsListFindingsLabels string) (*findings.ListFindingsPayload, error) {
	var err error
	var team *string
	{
		if findingsListFindingsTeam != "" {
			team = &findingsListFindingsTeam
		}
	}
	var tag *string
	{
		if findingsListFindingsTag != "" {
			tag = &findingsListFindingsTag
		}
	}
	var status *string
	{
		if findingsListFindingsStatus != "" {
			status = &findingsListFindingsStatus
		}
	}
	var minScore *int
	{
		if findingsListFindingsMinScore != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListFindingsMinScore, 10, 64)
			val := int(v)
			minScore = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for minScore, must be INT")
			}
		}
	}
	var maxScore *int
	{
		if findingsListFindingsMaxScore != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListFindingsMaxScore, 10, 64)
			val := int(v)
			maxScore = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for maxScore, must be INT")
			}
		}
	}
	var atDate *string
	{
		if findingsListFindingsAtDate != "" {
			atDate = &findingsListFindingsAtDate
		}
	}
	var minDate *string
	{
		if findingsListFindingsMinDate != "" {
			minDate = &findingsListFindingsMinDate
		}
	}
	var maxDate *string
	{
		if findingsListFindingsMaxDate != "" {
			maxDate = &findingsListFindingsMaxDate
		}
	}
	var sortBy *string
	{
		if findingsListFindingsSortBy != "" {
			sortBy = &findingsListFindingsSortBy
		}
	}
	var page *int
	{
		if findingsListFindingsPage != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListFindingsPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if findingsListFindingsSize != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListFindingsSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	var identifier *string
	{
		if findingsListFindingsIdentifier != "" {
			identifier = &findingsListFindingsIdentifier
		}
	}
	var identifiermatch *bool
	{
		if findingsListFindingsIdentifiermatch != "" {
			var val bool
			val, err = strconv.ParseBool(findingsListFindingsIdentifiermatch)
			identifiermatch = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for identifiermatch, must be BOOL")
			}
		}
	}
	var identifiers *string
	{
		if findingsListFindingsIdentifiers != "" {
			identifiers = &findingsListFindingsIdentifiers
		}
	}
	var labels *string
	{
		if findingsListFindingsLabels != "" {
			labels = &findingsListFindingsLabels
		}
	}
	v := &findings.ListFindingsPayload{}
	v.Team = team
	v.Tag = tag
	v.Status = status
	v.MinScore = minScore
	v.MaxScore = maxScore
	v.AtDate = atDate
	v.MinDate = minDate
	v.MaxDate = maxDate
	v.SortBy = sortBy
	v.Page = page
	v.Size = size
	v.Identifier = identifier
	v.Identifiermatch = identifiermatch
	v.Identifiers = identifiers
	v.Labels = labels

	return v, nil
}

// BuildGetFindingPayload builds the payload for the findings Get finding
// endpoint from CLI flags.
func BuildGetFindingPayload(findingsGetFindingID string) (*findings.GetFindingPayload, error) {
	var id string
	{
		id = findingsGetFindingID
	}
	v := &findings.GetFindingPayload{}
	v.ID = &id

	return v, nil
}

// BuildListEventsByFindingPayload builds the payload for the findings List
// events by finding endpoint from CLI flags.
func BuildListEventsByFindingPayload(findingsListEventsByFindingID string, findingsListEventsByFindingPage string, findingsListEventsByFindingSize string) (*findings.ListEventsByFindingPayload, error) {
	var err error
	var id string
	{
		id = findingsListEventsByFindingID
	}
	var page *int
	{
		if findingsListEventsByFindingPage != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListEventsByFindingPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if findingsListEventsByFindingSize != "" {
			var v int64
			v, err = strconv.ParseInt(findingsListEventsByFindingSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	v := &findings.ListEventsByFindingPayload{}
	v.ID = &id
	v.Page = page
	v.Size = size

	return v, nil
}

// BuildGetFindingMTTRPayload builds the payload for the findings Get finding
// MTTR endpoint from CLI flags.
func BuildGetFindingMTTRPayload(findingsGetFindingMTTRID string) (*findings.GetFindingMTTRPayload, error) {
	var id string
	{
		id = findingsGetFindingMTTRID
	}
	v := &findings.GetFindingMTTRPayload{}
	v.ID = &id

	return v, nil
}

// BuildPatchFindingPayload builds the payload for the findings Patch finding
// endpoint from CLI flags.
func BuildPatchFindingPayload(findingsPatchFindingBody string, findingsPatchFindingID string, findingsPatchFindingAuthorization string) (*findings.PatchFindingPayload, error) {
	var err error
	var body PatchFindingRequestBody
	{
		err = json.Unmarshal([]byte(findingsPatchFindingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"status\": \"OPEN\"\n   }'")
		}
	}
	var id string
	{
		id = findingsPatchFindingID
	}
	var authorization *string
	{
		if findingsPatchFindingAuthorization != "" {
			authorization = &findingsPatchFindingAuthorization
		}
	}
	v := &findings.PatchFindingPayload{
		Status: body.Status,
	}
	v.ID = &id
	v.Authorization = authorization

	return v, nil
}
