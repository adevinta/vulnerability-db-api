// Code generated by goa v3.5.2, DO NOT EDIT.
//
// findings HTTP client encoders and decoders
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"

	findings "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/findings"
	findingsviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/findings/views"
	goahttp "goa.design/goa/v3/http"
)

// BuildListFindingsRequest instantiates a HTTP request object with method and
// path set to call the "findings" service "List findings" endpoint
func (c *Client) BuildListFindingsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListFindingsFindingsPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("findings", "List findings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListFindingsRequest returns an encoder for requests sent to the
// findings List findings server.
func EncodeListFindingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*findings.ListFindingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("findings", "List findings", "*findings.ListFindingsPayload", v)
		}
		values := req.URL.Query()
		if p.Tag != nil {
			values.Add("tag", *p.Tag)
		}
		if p.Status != nil {
			values.Add("status", *p.Status)
		}
		if p.MinScore != nil {
			values.Add("minScore", fmt.Sprintf("%v", *p.MinScore))
		}
		if p.MaxScore != nil {
			values.Add("maxScore", fmt.Sprintf("%v", *p.MaxScore))
		}
		if p.AtDate != nil {
			values.Add("atDate", *p.AtDate)
		}
		if p.MinDate != nil {
			values.Add("minDate", *p.MinDate)
		}
		if p.MaxDate != nil {
			values.Add("maxDate", *p.MaxDate)
		}
		if p.SortBy != nil {
			values.Add("sortBy", *p.SortBy)
		}
		if p.Page != nil {
			values.Add("page", fmt.Sprintf("%v", *p.Page))
		}
		if p.Size != nil {
			values.Add("size", fmt.Sprintf("%v", *p.Size))
		}
		if p.Identifier != nil {
			values.Add("identifier", *p.Identifier)
		}
		if p.Identifiermatch != nil {
			values.Add("identifiermatch", fmt.Sprintf("%v", *p.Identifiermatch))
		}
		if p.Identifiers != nil {
			values.Add("identifiers", *p.Identifiers)
		}
		if p.Labels != nil {
			values.Add("labels", *p.Labels)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListFindingsResponse returns a decoder for responses returned by the
// findings List findings endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeListFindingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListFindingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("findings", "List findings", err)
			}
			p := NewListFindingsFindingCollectionOK(body)
			view := "default"
			vres := findingsviews.FindingCollection{Projected: p, View: view}
			if err = findingsviews.ValidateFindingCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("findings", "List findings", err)
			}
			res := findings.NewFindingCollection(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("findings", "List findings", resp.StatusCode, string(body))
		}
	}
}

// BuildGetFindingRequest instantiates a HTTP request object with method and
// path set to call the "findings" service "Get finding" endpoint
func (c *Client) BuildGetFindingRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*findings.GetFindingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("findings", "Get finding", "*findings.GetFindingPayload", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetFindingFindingsPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("findings", "Get finding", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetFindingResponse returns a decoder for responses returned by the
// findings Get finding endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeGetFindingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetFindingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("findings", "Get finding", err)
			}
			p := NewGetFindingFindingOK(&body)
			view := "default"
			vres := &findingsviews.Finding{Projected: p, View: view}
			if err = findingsviews.ValidateFinding(vres); err != nil {
				return nil, goahttp.ErrValidationError("findings", "Get finding", err)
			}
			res := findings.NewFinding(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("findings", "Get finding", resp.StatusCode, string(body))
		}
	}
}

// BuildListEventsByFindingRequest instantiates a HTTP request object with
// method and path set to call the "findings" service "List events by finding"
// endpoint
func (c *Client) BuildListEventsByFindingRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*findings.ListEventsByFindingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("findings", "List events by finding", "*findings.ListEventsByFindingPayload", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListEventsByFindingFindingsPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("findings", "List events by finding", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListEventsByFindingRequest returns an encoder for requests sent to the
// findings List events by finding server.
func EncodeListEventsByFindingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*findings.ListEventsByFindingPayload)
		if !ok {
			return goahttp.ErrInvalidType("findings", "List events by finding", "*findings.ListEventsByFindingPayload", v)
		}
		values := req.URL.Query()
		if p.Page != nil {
			values.Add("page", fmt.Sprintf("%v", *p.Page))
		}
		if p.Size != nil {
			values.Add("size", fmt.Sprintf("%v", *p.Size))
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListEventsByFindingResponse returns a decoder for responses returned
// by the findings List events by finding endpoint. restoreBody controls
// whether the response body should be restored after having been read.
func DecodeListEventsByFindingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListEventsByFindingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("findings", "List events by finding", err)
			}
			p := NewListEventsByFindingEventCollectionOK(body)
			view := "default"
			vres := findingsviews.EventCollection{Projected: p, View: view}
			if err = findingsviews.ValidateEventCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("findings", "List events by finding", err)
			}
			res := findings.NewEventCollection(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("findings", "List events by finding", resp.StatusCode, string(body))
		}
	}
}

// BuildGetFindingMTTRRequest instantiates a HTTP request object with method
// and path set to call the "findings" service "Get finding MTTR" endpoint
func (c *Client) BuildGetFindingMTTRRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*findings.GetFindingMTTRPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("findings", "Get finding MTTR", "*findings.GetFindingMTTRPayload", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetFindingMTTRFindingsPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("findings", "Get finding MTTR", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetFindingMTTRResponse returns a decoder for responses returned by the
// findings Get finding MTTR endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeGetFindingMTTRResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetFindingMTTRResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("findings", "Get finding MTTR", err)
			}
			p := NewGetFindingMTTRMttrOK(&body)
			view := "default"
			vres := &findingsviews.Mttr{Projected: p, View: view}
			if err = findingsviews.ValidateMttr(vres); err != nil {
				return nil, goahttp.ErrValidationError("findings", "Get finding MTTR", err)
			}
			res := findings.NewMttr(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("findings", "Get finding MTTR", resp.StatusCode, string(body))
		}
	}
}

// BuildPatchFindingRequest instantiates a HTTP request object with method and
// path set to call the "findings" service "Patch finding" endpoint
func (c *Client) BuildPatchFindingRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*findings.PatchFindingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("findings", "Patch finding", "*findings.PatchFindingPayload", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PatchFindingFindingsPath(id)}
	req, err := http.NewRequest("PATCH", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("findings", "Patch finding", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePatchFindingRequest returns an encoder for requests sent to the
// findings Patch finding server.
func EncodePatchFindingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*findings.PatchFindingPayload)
		if !ok {
			return goahttp.ErrInvalidType("findings", "Patch finding", "*findings.PatchFindingPayload", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			req.Header.Set("Authorization", head)
		}
		body := NewPatchFindingRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("findings", "Patch finding", err)
		}
		return nil
	}
}

// DecodePatchFindingResponse returns a decoder for responses returned by the
// findings Patch finding endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodePatchFindingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body PatchFindingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("findings", "Patch finding", err)
			}
			p := NewPatchFindingFindingOK(&body)
			view := "default"
			vres := &findingsviews.Finding{Projected: p, View: view}
			if err = findingsviews.ValidateFinding(vres); err != nil {
				return nil, goahttp.ErrValidationError("findings", "Patch finding", err)
			}
			res := findings.NewFinding(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("findings", "Patch finding", resp.StatusCode, string(body))
		}
	}
}

// unmarshalFindingResponseToFindingsviewsFindingView builds a value of type
// *findingsviews.FindingView from a value of type *FindingResponse.
func unmarshalFindingResponseToFindingsviewsFindingView(v *FindingResponse) *findingsviews.FindingView {
	res := &findingsviews.FindingView{
		ID:            v.ID,
		Details:       v.Details,
		ImpactDetails: v.ImpactDetails,
		Status:        v.Status,
		Score:         v.Score,
	}
	if v.Issue != nil {
		res.Issue = unmarshalIssueResponseToFindingsviewsIssueView(v.Issue)
	}
	if v.Target != nil {
		res.Target = unmarshalTargetResponseToFindingsviewsTargetView(v.Target)
	}
	if v.Source != nil {
		res.Source = unmarshalSourcewithnotargetResponseToFindingsviewsSourcewithnotargetView(v.Source)
	}
	if v.Resources != nil {
		res.Resources = make([]*findingsviews.ResourceGroupView, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = unmarshalResourceGroupResponseToFindingsviewsResourceGroupView(val)
		}
	}

	return res
}

// unmarshalIssueResponseToFindingsviewsIssueView builds a value of type
// *findingsviews.IssueView from a value of type *IssueResponse.
func unmarshalIssueResponseToFindingsviewsIssueView(v *IssueResponse) *findingsviews.IssueView {
	if v == nil {
		return nil
	}
	res := &findingsviews.IssueView{
		ID:          v.ID,
		Summary:     v.Summary,
		CweID:       v.CweID,
		Description: v.Description,
	}
	if v.Recommendations != nil {
		res.Recommendations = make([]string, len(v.Recommendations))
		for i, val := range v.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if v.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(v.ReferenceLinks))
		for i, val := range v.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// unmarshalTargetResponseToFindingsviewsTargetView builds a value of type
// *findingsviews.TargetView from a value of type *TargetResponse.
func unmarshalTargetResponseToFindingsviewsTargetView(v *TargetResponse) *findingsviews.TargetView {
	if v == nil {
		return nil
	}
	res := &findingsviews.TargetView{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// unmarshalSourcewithnotargetResponseToFindingsviewsSourcewithnotargetView
// builds a value of type *findingsviews.SourcewithnotargetView from a value of
// type *SourcewithnotargetResponse.
func unmarshalSourcewithnotargetResponseToFindingsviewsSourcewithnotargetView(v *SourcewithnotargetResponse) *findingsviews.SourcewithnotargetView {
	if v == nil {
		return nil
	}
	res := &findingsviews.SourcewithnotargetView{
		ID:        v.ID,
		Name:      v.Name,
		Component: v.Component,
		Instance:  v.Instance,
		Options:   v.Options,
		Time:      v.Time,
	}

	return res
}

// unmarshalResourceGroupResponseToFindingsviewsResourceGroupView builds a
// value of type *findingsviews.ResourceGroupView from a value of type
// *ResourceGroupResponse.
func unmarshalResourceGroupResponseToFindingsviewsResourceGroupView(v *ResourceGroupResponse) *findingsviews.ResourceGroupView {
	if v == nil {
		return nil
	}
	res := &findingsviews.ResourceGroupView{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// unmarshalIssueResponseBodyToFindingsviewsIssueView builds a value of type
// *findingsviews.IssueView from a value of type *IssueResponseBody.
func unmarshalIssueResponseBodyToFindingsviewsIssueView(v *IssueResponseBody) *findingsviews.IssueView {
	if v == nil {
		return nil
	}
	res := &findingsviews.IssueView{
		ID:          v.ID,
		Summary:     v.Summary,
		CweID:       v.CweID,
		Description: v.Description,
	}
	if v.Recommendations != nil {
		res.Recommendations = make([]string, len(v.Recommendations))
		for i, val := range v.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if v.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(v.ReferenceLinks))
		for i, val := range v.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// unmarshalTargetResponseBodyToFindingsviewsTargetView builds a value of type
// *findingsviews.TargetView from a value of type *TargetResponseBody.
func unmarshalTargetResponseBodyToFindingsviewsTargetView(v *TargetResponseBody) *findingsviews.TargetView {
	if v == nil {
		return nil
	}
	res := &findingsviews.TargetView{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// unmarshalSourcewithnotargetResponseBodyToFindingsviewsSourcewithnotargetView
// builds a value of type *findingsviews.SourcewithnotargetView from a value of
// type *SourcewithnotargetResponseBody.
func unmarshalSourcewithnotargetResponseBodyToFindingsviewsSourcewithnotargetView(v *SourcewithnotargetResponseBody) *findingsviews.SourcewithnotargetView {
	if v == nil {
		return nil
	}
	res := &findingsviews.SourcewithnotargetView{
		ID:        v.ID,
		Name:      v.Name,
		Component: v.Component,
		Instance:  v.Instance,
		Options:   v.Options,
		Time:      v.Time,
	}

	return res
}

// unmarshalResourceGroupResponseBodyToFindingsviewsResourceGroupView builds a
// value of type *findingsviews.ResourceGroupView from a value of type
// *ResourceGroupResponseBody.
func unmarshalResourceGroupResponseBodyToFindingsviewsResourceGroupView(v *ResourceGroupResponseBody) *findingsviews.ResourceGroupView {
	if v == nil {
		return nil
	}
	res := &findingsviews.ResourceGroupView{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// unmarshalEventResponseToFindingsviewsEventView builds a value of type
// *findingsviews.EventView from a value of type *EventResponse.
func unmarshalEventResponseToFindingsviewsEventView(v *EventResponse) *findingsviews.EventView {
	res := &findingsviews.EventView{
		ID:        v.ID,
		FindingID: v.FindingID,
		SourceID:  v.SourceID,
		Score:     v.Score,
		Time:      v.Time,
	}

	return res
}
