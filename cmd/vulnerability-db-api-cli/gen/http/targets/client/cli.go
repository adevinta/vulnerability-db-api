// Code generated by goa v3.0.6, DO NOT EDIT.
//
// targets HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"fmt"
	"strconv"

	targets "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/targets"
)

// BuildListTargetsPayload builds the payload for the targets List targets
// endpoint from CLI flags.
func BuildListTargetsPayload(targetsListTargetsTag string, targetsListTargetsIdentifier string, targetsListTargetsPage string, targetsListTargetsSize string) (*targets.ListTargetsPayload, error) {
	var err error
	var tag *string
	{
		if targetsListTargetsTag != "" {
			tag = &targetsListTargetsTag
		}
	}
	var identifier *string
	{
		if targetsListTargetsIdentifier != "" {
			identifier = &targetsListTargetsIdentifier
		}
	}
	var page *int
	{
		if targetsListTargetsPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListTargetsPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsListTargetsSize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListTargetsSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	payload := &targets.ListTargetsPayload{
		Tag:        tag,
		Identifier: identifier,
		Page:       page,
		Size:       size,
	}
	return payload, nil
}

// BuildTargetsSummaryPayload builds the payload for the targets Targets
// summary endpoint from CLI flags.
func BuildTargetsSummaryPayload(targetsTargetsSummaryTag string, targetsTargetsSummaryStatus string, targetsTargetsSummarySortBy string, targetsTargetsSummaryPage string, targetsTargetsSummarySize string) (*targets.TargetsSummaryPayload, error) {
	var err error
	var tag *string
	{
		if targetsTargetsSummaryTag != "" {
			tag = &targetsTargetsSummaryTag
		}
	}
	var status *string
	{
		if targetsTargetsSummaryStatus != "" {
			status = &targetsTargetsSummaryStatus
		}
	}
	var sortBy *string
	{
		if targetsTargetsSummarySortBy != "" {
			sortBy = &targetsTargetsSummarySortBy
		}
	}
	var page *int
	{
		if targetsTargetsSummaryPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsTargetsSummaryPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsTargetsSummarySize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsTargetsSummarySize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	payload := &targets.TargetsSummaryPayload{
		Tag:    tag,
		Status: status,
		SortBy: sortBy,
		Page:   page,
		Size:   size,
	}
	return payload, nil
}

// BuildGetTargetPayload builds the payload for the targets Get target endpoint
// from CLI flags.
func BuildGetTargetPayload(targetsGetTargetID string) (*targets.GetTargetPayload, error) {
	var id string
	{
		id = targetsGetTargetID
	}
	payload := &targets.GetTargetPayload{
		ID: &id,
	}
	return payload, nil
}

// BuildListFindingsByTargetPayload builds the payload for the targets List
// findings by target endpoint from CLI flags.
func BuildListFindingsByTargetPayload(targetsListFindingsByTargetID string, targetsListFindingsByTargetStatus string, targetsListFindingsByTargetSortBy string, targetsListFindingsByTargetPage string, targetsListFindingsByTargetSize string) (*targets.ListFindingsByTargetPayload, error) {
	var err error
	var id string
	{
		id = targetsListFindingsByTargetID
	}
	var status *string
	{
		if targetsListFindingsByTargetStatus != "" {
			status = &targetsListFindingsByTargetStatus
		}
	}
	var sortBy *string
	{
		if targetsListFindingsByTargetSortBy != "" {
			sortBy = &targetsListFindingsByTargetSortBy
		}
	}
	var page *int
	{
		if targetsListFindingsByTargetPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListFindingsByTargetPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsListFindingsByTargetSize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListFindingsByTargetSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	payload := &targets.ListFindingsByTargetPayload{
		ID:     &id,
		Status: status,
		SortBy: sortBy,
		Page:   page,
		Size:   size,
	}
	return payload, nil
}

// BuildListFindingsByTargetAndIssuePayload builds the payload for the targets
// List findings by target and issue endpoint from CLI flags.
func BuildListFindingsByTargetAndIssuePayload(targetsListFindingsByTargetAndIssueTargetID string, targetsListFindingsByTargetAndIssueIssueID string) (*targets.ListFindingsByTargetAndIssuePayload, error) {
	var targetID string
	{
		targetID = targetsListFindingsByTargetAndIssueTargetID
	}
	var issueID string
	{
		issueID = targetsListFindingsByTargetAndIssueIssueID
	}
	payload := &targets.ListFindingsByTargetAndIssuePayload{
		TargetID: &targetID,
		IssueID:  &issueID,
	}
	return payload, nil
}

// BuildGetTargetMTTRPayload builds the payload for the targets Get target MTTR
// endpoint from CLI flags.
func BuildGetTargetMTTRPayload(targetsGetTargetMTTRID string) (*targets.GetTargetMTTRPayload, error) {
	var id string
	{
		id = targetsGetTargetMTTRID
	}
	payload := &targets.GetTargetMTTRPayload{
		ID: &id,
	}
	return payload, nil
}
