// Code generated by goa v3.5.2, DO NOT EDIT.
//
// targets HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	targets "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/targets"
	goa "goa.design/goa/v3/pkg"
)

// BuildListTargetsPayload builds the payload for the targets List targets
// endpoint from CLI flags.
func BuildListTargetsPayload(targetsListTargetsTeam string, targetsListTargetsTeams string, targetsListTargetsIdentifier string, targetsListTargetsPage string, targetsListTargetsSize string, targetsListTargetsIdentifiermatch string, targetsListTargetsIdentifiers string) (*targets.ListTargetsPayload, error) {
	var err error
	var team *string
	{
		if targetsListTargetsTeam != "" {
			team = &targetsListTargetsTeam
		}
	}
	var teams *string
	{
		if targetsListTargetsTeams != "" {
			teams = &targetsListTargetsTeams
		}
	}
	var identifier *string
	{
		if targetsListTargetsIdentifier != "" {
			identifier = &targetsListTargetsIdentifier
		}
	}
	var page *int
	{
		if targetsListTargetsPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListTargetsPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsListTargetsSize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListTargetsSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	var identifiermatch *bool
	{
		if targetsListTargetsIdentifiermatch != "" {
			var val bool
			val, err = strconv.ParseBool(targetsListTargetsIdentifiermatch)
			identifiermatch = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for identifiermatch, must be BOOL")
			}
		}
	}
	var identifiers *string
	{
		if targetsListTargetsIdentifiers != "" {
			identifiers = &targetsListTargetsIdentifiers
		}
	}
	v := &targets.ListTargetsPayload{}
	v.Team = team
	v.Teams = teams
	v.Identifier = identifier
	v.Page = page
	v.Size = size
	v.Identifiermatch = identifiermatch
	v.Identifiers = identifiers

	return v, nil
}

// BuildTargetsSummaryPayload builds the payload for the targets Targets
// summary endpoint from CLI flags.
func BuildTargetsSummaryPayload(targetsTargetsSummaryTeam string, targetsTargetsSummaryTeams string, targetsTargetsSummaryStatus string, targetsTargetsSummarySortBy string, targetsTargetsSummaryPage string, targetsTargetsSummarySize string, targetsTargetsSummaryIdentifiers string, targetsTargetsSummaryLabels string) (*targets.TargetsSummaryPayload, error) {
	var err error
	var team *string
	{
		if targetsTargetsSummaryTeam != "" {
			team = &targetsTargetsSummaryTeam
		}
	}
	var teams *string
	{
		if targetsTargetsSummaryTeams != "" {
			teams = &targetsTargetsSummaryTeams
		}
	}
	var status *string
	{
		if targetsTargetsSummaryStatus != "" {
			status = &targetsTargetsSummaryStatus
		}
	}
	var sortBy *string
	{
		if targetsTargetsSummarySortBy != "" {
			sortBy = &targetsTargetsSummarySortBy
		}
	}
	var page *int
	{
		if targetsTargetsSummaryPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsTargetsSummaryPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsTargetsSummarySize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsTargetsSummarySize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	var identifiers *string
	{
		if targetsTargetsSummaryIdentifiers != "" {
			identifiers = &targetsTargetsSummaryIdentifiers
		}
	}
	var labels *string
	{
		if targetsTargetsSummaryLabels != "" {
			labels = &targetsTargetsSummaryLabels
		}
	}
	v := &targets.TargetsSummaryPayload{}
	v.Team = team
	v.Teams = teams
	v.Status = status
	v.SortBy = sortBy
	v.Page = page
	v.Size = size
	v.Identifiers = identifiers
	v.Labels = labels

	return v, nil
}

// BuildGetTargetPayload builds the payload for the targets Get target endpoint
// from CLI flags.
func BuildGetTargetPayload(targetsGetTargetID string) (*targets.GetTargetPayload, error) {
	var id string
	{
		id = targetsGetTargetID
	}
	v := &targets.GetTargetPayload{}
	v.ID = &id

	return v, nil
}

// BuildCreateTargetPayload builds the payload for the targets Create target
// endpoint from CLI flags.
func BuildCreateTargetPayload(targetsCreateTargetBody string) (*targets.CreateTargetPayload, error) {
	var err error
	var body CreateTargetRequestBody
	{
		err = json.Unmarshal([]byte(targetsCreateTargetBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"identifier\": \"www.example.com\",\n      \"teams\": [\n         \"e84cfeeb-7a2b-442b-b1cf-15af8b4a52d3\"\n      ]\n   }'")
		}
	}
	v := &targets.CreateTargetPayload{
		Identifier: body.Identifier,
	}
	if body.Teams != nil {
		v.Teams = make([]string, len(body.Teams))
		for i, val := range body.Teams {
			v.Teams[i] = val
		}
	}

	return v, nil
}

// BuildListFindingsByTargetPayload builds the payload for the targets List
// findings by target endpoint from CLI flags.
func BuildListFindingsByTargetPayload(targetsListFindingsByTargetID string, targetsListFindingsByTargetStatus string, targetsListFindingsByTargetSortBy string, targetsListFindingsByTargetPage string, targetsListFindingsByTargetSize string, targetsListFindingsByTargetLabels string) (*targets.ListFindingsByTargetPayload, error) {
	var err error
	var id string
	{
		id = targetsListFindingsByTargetID
	}
	var status *string
	{
		if targetsListFindingsByTargetStatus != "" {
			status = &targetsListFindingsByTargetStatus
		}
	}
	var sortBy *string
	{
		if targetsListFindingsByTargetSortBy != "" {
			sortBy = &targetsListFindingsByTargetSortBy
		}
	}
	var page *int
	{
		if targetsListFindingsByTargetPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListFindingsByTargetPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsListFindingsByTargetSize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListFindingsByTargetSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	var labels *string
	{
		if targetsListFindingsByTargetLabels != "" {
			labels = &targetsListFindingsByTargetLabels
		}
	}
	v := &targets.ListFindingsByTargetPayload{}
	v.ID = &id
	v.Status = status
	v.SortBy = sortBy
	v.Page = page
	v.Size = size
	v.Labels = labels

	return v, nil
}

// BuildGetFindingByTargetIssueAndAffectedResourcePayload builds the payload
// for the targets Get finding by target, issue and affected resource endpoint
// from CLI flags.
func BuildGetFindingByTargetIssueAndAffectedResourcePayload(targetsGetFindingByTargetIssueAndAffectedResourceTargetID string, targetsGetFindingByTargetIssueAndAffectedResourceIssueID string, targetsGetFindingByTargetIssueAndAffectedResourceResource string) (*targets.GetFindingByTargetIssueAndAffectedResourcePayload, error) {
	var targetID string
	{
		targetID = targetsGetFindingByTargetIssueAndAffectedResourceTargetID
	}
	var issueID string
	{
		issueID = targetsGetFindingByTargetIssueAndAffectedResourceIssueID
	}
	var resource string
	{
		resource = targetsGetFindingByTargetIssueAndAffectedResourceResource
	}
	v := &targets.GetFindingByTargetIssueAndAffectedResourcePayload{}
	v.TargetID = &targetID
	v.IssueID = &issueID
	v.Resource = &resource

	return v, nil
}

// BuildGetTargetMTTRPayload builds the payload for the targets Get target MTTR
// endpoint from CLI flags.
func BuildGetTargetMTTRPayload(targetsGetTargetMTTRID string) (*targets.GetTargetMTTRPayload, error) {
	var id string
	{
		id = targetsGetTargetMTTRID
	}
	v := &targets.GetTargetMTTRPayload{}
	v.ID = &id

	return v, nil
}

// BuildDeleteTargetTeamPayload builds the payload for the targets Delete
// target team endpoint from CLI flags.
func BuildDeleteTargetTeamPayload(targetsDeleteTargetTeamTargetID string, targetsDeleteTargetTeamTeam string, targetsDeleteTargetTeamAuth string) (*targets.DeleteTargetTeamPayload, error) {
	var err error
	var targetID string
	{
		targetID = targetsDeleteTargetTeamTargetID
	}
	var team string
	{
		team = targetsDeleteTargetTeamTeam
	}
	var auth string
	{
		auth = targetsDeleteTargetTeamAuth
		err = goa.MergeErrors(err, goa.ValidatePattern("auth", auth, "^TEAM team=[^ ]+$"))
		if err != nil {
			return nil, err
		}
	}
	v := &targets.DeleteTargetTeamPayload{}
	v.TargetID = &targetID
	v.Team = &team
	v.Auth = auth

	return v, nil
}

// BuildDeleteTeamPayload builds the payload for the targets Delete team
// endpoint from CLI flags.
func BuildDeleteTeamPayload(targetsDeleteTeamTeam string, targetsDeleteTeamAuth string) (*targets.DeleteTeamPayload, error) {
	var err error
	var team string
	{
		team = targetsDeleteTeamTeam
	}
	var auth string
	{
		auth = targetsDeleteTeamAuth
		err = goa.MergeErrors(err, goa.ValidatePattern("auth", auth, "^TEAM team=[^ ]+$"))
		if err != nil {
			return nil, err
		}
	}
	v := &targets.DeleteTeamPayload{}
	v.Team = &team
	v.Auth = auth

	return v, nil
}
