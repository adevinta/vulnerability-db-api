// Code generated by goa v3.0.6, DO NOT EDIT.
//
// targets HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	targets "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/targets"
)

// BuildListTargetsPayload builds the payload for the targets List targets
// endpoint from CLI flags.
func BuildListTargetsPayload(targetsListTargetsTag string, targetsListTargetsIdentifier string, targetsListTargetsPage string, targetsListTargetsSize string, targetsListTargetsIdentifiermatch string) (*targets.ListTargetsPayload, error) {
	var err error
	var tag *string
	{
		if targetsListTargetsTag != "" {
			tag = &targetsListTargetsTag
		}
	}
	var identifier *string
	{
		if targetsListTargetsIdentifier != "" {
			identifier = &targetsListTargetsIdentifier
		}
	}
	var page *int
	{
		if targetsListTargetsPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListTargetsPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsListTargetsSize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListTargetsSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	var identifiermatch *bool
	{
		if targetsListTargetsIdentifiermatch != "" {
			var val bool
			val, err = strconv.ParseBool(targetsListTargetsIdentifiermatch)
			identifiermatch = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for identifiermatch, must be BOOL")
			}
		}
	}
	payload := &targets.ListTargetsPayload{
		Tag:             tag,
		Identifier:      identifier,
		Page:            page,
		Size:            size,
		Identifiermatch: identifiermatch,
	}
	return payload, nil
}

// BuildTargetsSummaryPayload builds the payload for the targets Targets
// summary endpoint from CLI flags.
func BuildTargetsSummaryPayload(targetsTargetsSummaryTag string, targetsTargetsSummaryStatus string, targetsTargetsSummarySortBy string, targetsTargetsSummaryPage string, targetsTargetsSummarySize string) (*targets.TargetsSummaryPayload, error) {
	var err error
	var tag *string
	{
		if targetsTargetsSummaryTag != "" {
			tag = &targetsTargetsSummaryTag
		}
	}
	var status *string
	{
		if targetsTargetsSummaryStatus != "" {
			status = &targetsTargetsSummaryStatus
		}
	}
	var sortBy *string
	{
		if targetsTargetsSummarySortBy != "" {
			sortBy = &targetsTargetsSummarySortBy
		}
	}
	var page *int
	{
		if targetsTargetsSummaryPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsTargetsSummaryPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsTargetsSummarySize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsTargetsSummarySize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	payload := &targets.TargetsSummaryPayload{
		Tag:    tag,
		Status: status,
		SortBy: sortBy,
		Page:   page,
		Size:   size,
	}
	return payload, nil
}

// BuildGetTargetPayload builds the payload for the targets Get target endpoint
// from CLI flags.
func BuildGetTargetPayload(targetsGetTargetID string) (*targets.GetTargetPayload, error) {
	var id string
	{
		id = targetsGetTargetID
	}
	payload := &targets.GetTargetPayload{
		ID: &id,
	}
	return payload, nil
}

// BuildCreateTargetPayload builds the payload for the targets Create target
// endpoint from CLI flags.
func BuildCreateTargetPayload(targetsCreateTargetBody string) (*targets.CreateTargetPayload, error) {
	var err error
	var body CreateTargetRequestBody
	{
		err = json.Unmarshal([]byte(targetsCreateTargetBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"identifier\": \"www.example.com\",\n      \"tags\": [\n         \"sdrn:adevinta:team:security\"\n      ]\n   }'")
		}
	}
	v := &targets.CreateTargetPayload{
		Identifier: body.Identifier,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	return v, nil
}

// BuildListFindingsByTargetPayload builds the payload for the targets List
// findings by target endpoint from CLI flags.
func BuildListFindingsByTargetPayload(targetsListFindingsByTargetID string, targetsListFindingsByTargetStatus string, targetsListFindingsByTargetSortBy string, targetsListFindingsByTargetPage string, targetsListFindingsByTargetSize string) (*targets.ListFindingsByTargetPayload, error) {
	var err error
	var id string
	{
		id = targetsListFindingsByTargetID
	}
	var status *string
	{
		if targetsListFindingsByTargetStatus != "" {
			status = &targetsListFindingsByTargetStatus
		}
	}
	var sortBy *string
	{
		if targetsListFindingsByTargetSortBy != "" {
			sortBy = &targetsListFindingsByTargetSortBy
		}
	}
	var page *int
	{
		if targetsListFindingsByTargetPage != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListFindingsByTargetPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if targetsListFindingsByTargetSize != "" {
			var v int64
			v, err = strconv.ParseInt(targetsListFindingsByTargetSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	payload := &targets.ListFindingsByTargetPayload{
		ID:     &id,
		Status: status,
		SortBy: sortBy,
		Page:   page,
		Size:   size,
	}
	return payload, nil
}

// BuildListFindingsByTargetAndIssuePayload builds the payload for the targets
// List findings by target and issue endpoint from CLI flags.
func BuildListFindingsByTargetAndIssuePayload(targetsListFindingsByTargetAndIssueTargetID string, targetsListFindingsByTargetAndIssueIssueID string) (*targets.ListFindingsByTargetAndIssuePayload, error) {
	var targetID string
	{
		targetID = targetsListFindingsByTargetAndIssueTargetID
	}
	var issueID string
	{
		issueID = targetsListFindingsByTargetAndIssueIssueID
	}
	payload := &targets.ListFindingsByTargetAndIssuePayload{
		TargetID: &targetID,
		IssueID:  &issueID,
	}
	return payload, nil
}

// BuildGetTargetMTTRPayload builds the payload for the targets Get target MTTR
// endpoint from CLI flags.
func BuildGetTargetMTTRPayload(targetsGetTargetMTTRID string) (*targets.GetTargetMTTRPayload, error) {
	var id string
	{
		id = targetsGetTargetMTTRID
	}
	payload := &targets.GetTargetMTTRPayload{
		ID: &id,
	}
	return payload, nil
}

// BuildDeleteTargetTagPayload builds the payload for the targets Delete target
// tag endpoint from CLI flags.
func BuildDeleteTargetTagPayload(targetsDeleteTargetTagTargetID string, targetsDeleteTargetTagTag string, targetsDeleteTargetTagAuth string) (*targets.DeleteTargetTagPayload, error) {
	var targetID string
	{
		targetID = targetsDeleteTargetTagTargetID
	}
	var tag string
	{
		tag = targetsDeleteTargetTagTag
	}
	var auth string
	{
		auth = targetsDeleteTargetTagAuth
	}
	payload := &targets.DeleteTargetTagPayload{
		TargetID: &targetID,
		Tag:      &tag,
		Auth:     auth,
	}
	return payload, nil
}

// BuildDeleteTagPayload builds the payload for the targets Delete tag endpoint
// from CLI flags.
func BuildDeleteTagPayload(targetsDeleteTagTag string, targetsDeleteTagAuth string) (*targets.DeleteTagPayload, error) {
	var tag string
	{
		tag = targetsDeleteTagTag
	}
	var auth string
	{
		auth = targetsDeleteTagAuth
	}
	payload := &targets.DeleteTagPayload{
		Tag:  &tag,
		Auth: auth,
	}
	return payload, nil
}
