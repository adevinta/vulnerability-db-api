// Code generated by goa v3.5.2, DO NOT EDIT.
//
// targets HTTP client encoders and decoders
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"

	targets "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/targets"
	targetsviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/targets/views"
	goahttp "goa.design/goa/v3/http"
)

// BuildListTargetsRequest instantiates a HTTP request object with method and
// path set to call the "targets" service "List targets" endpoint
func (c *Client) BuildListTargetsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListTargetsTargetsPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "List targets", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListTargetsRequest returns an encoder for requests sent to the targets
// List targets server.
func EncodeListTargetsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*targets.ListTargetsPayload)
		if !ok {
			return goahttp.ErrInvalidType("targets", "List targets", "*targets.ListTargetsPayload", v)
		}
		values := req.URL.Query()
		if p.Tag != nil {
			values.Add("tag", *p.Tag)
		}
		if p.Identifier != nil {
			values.Add("identifier", *p.Identifier)
		}
		if p.Page != nil {
			values.Add("page", fmt.Sprintf("%v", *p.Page))
		}
		if p.Size != nil {
			values.Add("size", fmt.Sprintf("%v", *p.Size))
		}
		if p.Identifiermatch != nil {
			values.Add("identifiermatch", fmt.Sprintf("%v", *p.Identifiermatch))
		}
		if p.Identifiers != nil {
			values.Add("identifiers", *p.Identifiers)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListTargetsResponse returns a decoder for responses returned by the
// targets List targets endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeListTargetsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListTargetsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("targets", "List targets", err)
			}
			p := NewListTargetsTargetCollectionOK(body)
			view := "default"
			vres := targetsviews.TargetCollection{Projected: p, View: view}
			if err = targetsviews.ValidateTargetCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("targets", "List targets", err)
			}
			res := targets.NewTargetCollection(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "List targets", resp.StatusCode, string(body))
		}
	}
}

// BuildTargetsSummaryRequest instantiates a HTTP request object with method
// and path set to call the "targets" service "Targets summary" endpoint
func (c *Client) BuildTargetsSummaryRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: TargetsSummaryTargetsPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "Targets summary", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeTargetsSummaryRequest returns an encoder for requests sent to the
// targets Targets summary server.
func EncodeTargetsSummaryRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*targets.TargetsSummaryPayload)
		if !ok {
			return goahttp.ErrInvalidType("targets", "Targets summary", "*targets.TargetsSummaryPayload", v)
		}
		values := req.URL.Query()
		if p.Tag != nil {
			values.Add("tag", *p.Tag)
		}
		if p.Status != nil {
			values.Add("status", *p.Status)
		}
		if p.SortBy != nil {
			values.Add("sortBy", *p.SortBy)
		}
		if p.Page != nil {
			values.Add("page", fmt.Sprintf("%v", *p.Page))
		}
		if p.Size != nil {
			values.Add("size", fmt.Sprintf("%v", *p.Size))
		}
		if p.Identifiers != nil {
			values.Add("identifiers", *p.Identifiers)
		}
		if p.Labels != nil {
			values.Add("labels", *p.Labels)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeTargetsSummaryResponse returns a decoder for responses returned by the
// targets Targets summary endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeTargetsSummaryResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body TargetsSummaryResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("targets", "Targets summary", err)
			}
			p := NewTargetsSummaryTargetSummaryCollectionOK(body)
			view := "default"
			vres := targetsviews.TargetSummaryCollection{Projected: p, View: view}
			if err = targetsviews.ValidateTargetSummaryCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("targets", "Targets summary", err)
			}
			res := targets.NewTargetSummaryCollection(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "Targets summary", resp.StatusCode, string(body))
		}
	}
}

// BuildGetTargetRequest instantiates a HTTP request object with method and
// path set to call the "targets" service "Get target" endpoint
func (c *Client) BuildGetTargetRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*targets.GetTargetPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("targets", "Get target", "*targets.GetTargetPayload", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetTargetTargetsPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "Get target", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetTargetResponse returns a decoder for responses returned by the
// targets Get target endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetTargetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetTargetResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("targets", "Get target", err)
			}
			p := NewGetTargetTargetOK(&body)
			view := "default"
			vres := &targetsviews.Target{Projected: p, View: view}
			if err = targetsviews.ValidateTarget(vres); err != nil {
				return nil, goahttp.ErrValidationError("targets", "Get target", err)
			}
			res := targets.NewTarget(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "Get target", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateTargetRequest instantiates a HTTP request object with method and
// path set to call the "targets" service "Create target" endpoint
func (c *Client) BuildCreateTargetRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateTargetTargetsPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "Create target", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateTargetRequest returns an encoder for requests sent to the
// targets Create target server.
func EncodeCreateTargetRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*targets.CreateTargetPayload)
		if !ok {
			return goahttp.ErrInvalidType("targets", "Create target", "*targets.CreateTargetPayload", v)
		}
		body := NewCreateTargetRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("targets", "Create target", err)
		}
		return nil
	}
}

// DecodeCreateTargetResponse returns a decoder for responses returned by the
// targets Create target endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeCreateTargetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateTargetResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("targets", "Create target", err)
			}
			p := NewCreateTargetTargetCreated(&body)
			view := "default"
			vres := &targetsviews.Target{Projected: p, View: view}
			if err = targetsviews.ValidateTarget(vres); err != nil {
				return nil, goahttp.ErrValidationError("targets", "Create target", err)
			}
			res := targets.NewTarget(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "Create target", resp.StatusCode, string(body))
		}
	}
}

// BuildListFindingsByTargetRequest instantiates a HTTP request object with
// method and path set to call the "targets" service "List findings by target"
// endpoint
func (c *Client) BuildListFindingsByTargetRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*targets.ListFindingsByTargetPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("targets", "List findings by target", "*targets.ListFindingsByTargetPayload", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListFindingsByTargetTargetsPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "List findings by target", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListFindingsByTargetRequest returns an encoder for requests sent to
// the targets List findings by target server.
func EncodeListFindingsByTargetRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*targets.ListFindingsByTargetPayload)
		if !ok {
			return goahttp.ErrInvalidType("targets", "List findings by target", "*targets.ListFindingsByTargetPayload", v)
		}
		values := req.URL.Query()
		if p.Status != nil {
			values.Add("status", *p.Status)
		}
		if p.SortBy != nil {
			values.Add("sortBy", *p.SortBy)
		}
		if p.Page != nil {
			values.Add("page", fmt.Sprintf("%v", *p.Page))
		}
		if p.Size != nil {
			values.Add("size", fmt.Sprintf("%v", *p.Size))
		}
		if p.Labels != nil {
			values.Add("labels", *p.Labels)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListFindingsByTargetResponse returns a decoder for responses returned
// by the targets List findings by target endpoint. restoreBody controls
// whether the response body should be restored after having been read.
func DecodeListFindingsByTargetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListFindingsByTargetResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("targets", "List findings by target", err)
			}
			p := NewListFindingsByTargetFindingCollectionOK(body)
			view := "default"
			vres := targetsviews.FindingCollection{Projected: p, View: view}
			if err = targetsviews.ValidateFindingCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("targets", "List findings by target", err)
			}
			res := targets.NewFindingCollection(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "List findings by target", resp.StatusCode, string(body))
		}
	}
}

// BuildGetFindingByTargetIssueAndAffectedResourceRequest instantiates a HTTP
// request object with method and path set to call the "targets" service "Get
// finding by target, issue and affected resource" endpoint
func (c *Client) BuildGetFindingByTargetIssueAndAffectedResourceRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		targetID string
		issueID  string
		resource string
	)
	{
		p, ok := v.(*targets.GetFindingByTargetIssueAndAffectedResourcePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("targets", "Get finding by target, issue and affected resource", "*targets.GetFindingByTargetIssueAndAffectedResourcePayload", v)
		}
		if p.TargetID != nil {
			targetID = *p.TargetID
		}
		if p.IssueID != nil {
			issueID = *p.IssueID
		}
		if p.Resource != nil {
			resource = *p.Resource
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetFindingByTargetIssueAndAffectedResourceTargetsPath(targetID, issueID, resource)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "Get finding by target, issue and affected resource", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetFindingByTargetIssueAndAffectedResourceResponse returns a decoder
// for responses returned by the targets Get finding by target, issue and
// affected resource endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetFindingByTargetIssueAndAffectedResourceResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetFindingByTargetIssueAndAffectedResourceResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("targets", "Get finding by target, issue and affected resource", err)
			}
			p := NewGetFindingByTargetIssueAndAffectedResourceFindingOK(&body)
			view := "default"
			vres := &targetsviews.Finding{Projected: p, View: view}
			if err = targetsviews.ValidateFinding(vres); err != nil {
				return nil, goahttp.ErrValidationError("targets", "Get finding by target, issue and affected resource", err)
			}
			res := targets.NewFinding(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "Get finding by target, issue and affected resource", resp.StatusCode, string(body))
		}
	}
}

// BuildGetTargetMTTRRequest instantiates a HTTP request object with method and
// path set to call the "targets" service "Get target MTTR" endpoint
func (c *Client) BuildGetTargetMTTRRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*targets.GetTargetMTTRPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("targets", "Get target MTTR", "*targets.GetTargetMTTRPayload", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetTargetMTTRTargetsPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "Get target MTTR", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetTargetMTTRResponse returns a decoder for responses returned by the
// targets Get target MTTR endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeGetTargetMTTRResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body float32
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("targets", "Get target MTTR", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "Get target MTTR", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteTargetTagRequest instantiates a HTTP request object with method
// and path set to call the "targets" service "Delete target tag" endpoint
func (c *Client) BuildDeleteTargetTagRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		targetID string
		tag      string
	)
	{
		p, ok := v.(*targets.DeleteTargetTagPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("targets", "Delete target tag", "*targets.DeleteTargetTagPayload", v)
		}
		if p.TargetID != nil {
			targetID = *p.TargetID
		}
		if p.Tag != nil {
			tag = *p.Tag
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteTargetTagTargetsPath(targetID, tag)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "Delete target tag", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteTargetTagRequest returns an encoder for requests sent to the
// targets Delete target tag server.
func EncodeDeleteTargetTagRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*targets.DeleteTargetTagPayload)
		if !ok {
			return goahttp.ErrInvalidType("targets", "Delete target tag", "*targets.DeleteTargetTagPayload", v)
		}
		{
			head := p.Auth
			req.Header.Set("Authorization", head)
		}
		return nil
	}
}

// DecodeDeleteTargetTagResponse returns a decoder for responses returned by
// the targets Delete target tag endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeDeleteTargetTagResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "Delete target tag", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteTagRequest instantiates a HTTP request object with method and
// path set to call the "targets" service "Delete tag" endpoint
func (c *Client) BuildDeleteTagRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		tag string
	)
	{
		p, ok := v.(*targets.DeleteTagPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("targets", "Delete tag", "*targets.DeleteTagPayload", v)
		}
		if p.Tag != nil {
			tag = *p.Tag
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteTagTargetsPath(tag)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("targets", "Delete tag", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteTagRequest returns an encoder for requests sent to the targets
// Delete tag server.
func EncodeDeleteTagRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*targets.DeleteTagPayload)
		if !ok {
			return goahttp.ErrInvalidType("targets", "Delete tag", "*targets.DeleteTagPayload", v)
		}
		{
			head := p.Auth
			req.Header.Set("Authorization", head)
		}
		return nil
	}
}

// DecodeDeleteTagResponse returns a decoder for responses returned by the
// targets Delete tag endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeDeleteTagResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("targets", "Delete tag", resp.StatusCode, string(body))
		}
	}
}

// unmarshalTargetResponseToTargetsviewsTargetView builds a value of type
// *targetsviews.TargetView from a value of type *TargetResponse.
func unmarshalTargetResponseToTargetsviewsTargetView(v *TargetResponse) *targetsviews.TargetView {
	res := &targetsviews.TargetView{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// unmarshalTargetSummaryResponseToTargetsviewsTargetSummaryView builds a value
// of type *targetsviews.TargetSummaryView from a value of type
// *TargetSummaryResponse.
func unmarshalTargetSummaryResponseToTargetsviewsTargetSummaryView(v *TargetSummaryResponse) *targetsviews.TargetSummaryView {
	res := &targetsviews.TargetSummaryView{
		TargetID:      v.TargetID,
		Identifier:    v.Identifier,
		FindingsCount: v.FindingsCount,
		IssuesCount:   v.IssuesCount,
		MaxScore:      v.MaxScore,
	}

	return res
}

// unmarshalFindingResponseToTargetsviewsFindingView builds a value of type
// *targetsviews.FindingView from a value of type *FindingResponse.
func unmarshalFindingResponseToTargetsviewsFindingView(v *FindingResponse) *targetsviews.FindingView {
	res := &targetsviews.FindingView{
		ID:            v.ID,
		Details:       v.Details,
		ImpactDetails: v.ImpactDetails,
		Status:        v.Status,
		Score:         v.Score,
	}
	if v.Issue != nil {
		res.Issue = unmarshalIssueResponseToTargetsviewsIssueView(v.Issue)
	}
	if v.Target != nil {
		res.Target = unmarshalTargetResponseToTargetsviewsTargetView(v.Target)
	}
	if v.Source != nil {
		res.Source = unmarshalSourcewithnotargetResponseToTargetsviewsSourcewithnotargetView(v.Source)
	}
	if v.Resources != nil {
		res.Resources = make([]*targetsviews.ResourceGroupView, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = unmarshalResourceGroupResponseToTargetsviewsResourceGroupView(val)
		}
	}

	return res
}

// unmarshalIssueResponseToTargetsviewsIssueView builds a value of type
// *targetsviews.IssueView from a value of type *IssueResponse.
func unmarshalIssueResponseToTargetsviewsIssueView(v *IssueResponse) *targetsviews.IssueView {
	if v == nil {
		return nil
	}
	res := &targetsviews.IssueView{
		ID:          v.ID,
		Summary:     v.Summary,
		CweID:       v.CweID,
		Description: v.Description,
	}
	if v.Recommendations != nil {
		res.Recommendations = make([]string, len(v.Recommendations))
		for i, val := range v.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if v.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(v.ReferenceLinks))
		for i, val := range v.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// unmarshalSourcewithnotargetResponseToTargetsviewsSourcewithnotargetView
// builds a value of type *targetsviews.SourcewithnotargetView from a value of
// type *SourcewithnotargetResponse.
func unmarshalSourcewithnotargetResponseToTargetsviewsSourcewithnotargetView(v *SourcewithnotargetResponse) *targetsviews.SourcewithnotargetView {
	if v == nil {
		return nil
	}
	res := &targetsviews.SourcewithnotargetView{
		ID:        v.ID,
		Name:      v.Name,
		Component: v.Component,
		Instance:  v.Instance,
		Options:   v.Options,
		Time:      v.Time,
	}

	return res
}

// unmarshalResourceGroupResponseToTargetsviewsResourceGroupView builds a value
// of type *targetsviews.ResourceGroupView from a value of type
// *ResourceGroupResponse.
func unmarshalResourceGroupResponseToTargetsviewsResourceGroupView(v *ResourceGroupResponse) *targetsviews.ResourceGroupView {
	if v == nil {
		return nil
	}
	res := &targetsviews.ResourceGroupView{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// unmarshalIssueResponseBodyToTargetsviewsIssueView builds a value of type
// *targetsviews.IssueView from a value of type *IssueResponseBody.
func unmarshalIssueResponseBodyToTargetsviewsIssueView(v *IssueResponseBody) *targetsviews.IssueView {
	if v == nil {
		return nil
	}
	res := &targetsviews.IssueView{
		ID:          v.ID,
		Summary:     v.Summary,
		CweID:       v.CweID,
		Description: v.Description,
	}
	if v.Recommendations != nil {
		res.Recommendations = make([]string, len(v.Recommendations))
		for i, val := range v.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if v.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(v.ReferenceLinks))
		for i, val := range v.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// unmarshalTargetResponseBodyToTargetsviewsTargetView builds a value of type
// *targetsviews.TargetView from a value of type *TargetResponseBody.
func unmarshalTargetResponseBodyToTargetsviewsTargetView(v *TargetResponseBody) *targetsviews.TargetView {
	if v == nil {
		return nil
	}
	res := &targetsviews.TargetView{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// unmarshalSourcewithnotargetResponseBodyToTargetsviewsSourcewithnotargetView
// builds a value of type *targetsviews.SourcewithnotargetView from a value of
// type *SourcewithnotargetResponseBody.
func unmarshalSourcewithnotargetResponseBodyToTargetsviewsSourcewithnotargetView(v *SourcewithnotargetResponseBody) *targetsviews.SourcewithnotargetView {
	if v == nil {
		return nil
	}
	res := &targetsviews.SourcewithnotargetView{
		ID:        v.ID,
		Name:      v.Name,
		Component: v.Component,
		Instance:  v.Instance,
		Options:   v.Options,
		Time:      v.Time,
	}

	return res
}

// unmarshalResourceGroupResponseBodyToTargetsviewsResourceGroupView builds a
// value of type *targetsviews.ResourceGroupView from a value of type
// *ResourceGroupResponseBody.
func unmarshalResourceGroupResponseBodyToTargetsviewsResourceGroupView(v *ResourceGroupResponseBody) *targetsviews.ResourceGroupView {
	if v == nil {
		return nil
	}
	res := &targetsviews.ResourceGroupView{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}
