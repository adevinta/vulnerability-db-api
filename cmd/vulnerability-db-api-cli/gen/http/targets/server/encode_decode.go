// Code generated by goa v3.14.0, DO NOT EDIT.
//
// targets HTTP server encoders and decoders
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package server

import (
	"context"
	"io"
	"net/http"
	"strconv"

	targetsviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/targets/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeListTargetsResponse returns an encoder for responses returned by the
// targets List targets endpoint.
func EncodeListTargetsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(targetsviews.TargetCollection)
		enc := encoder(ctx, w)
		body := NewTargetResponseCollection(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListTargetsRequest returns a decoder for requests sent to the targets
// List targets endpoint.
func DecodeListTargetsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			team            *string
			teams           *string
			identifier      *string
			page            *int
			size            *int
			identifiermatch *bool
			identifiers     *string
			err             error
		)
		teamRaw := r.URL.Query().Get("team")
		if teamRaw != "" {
			team = &teamRaw
		}
		teamsRaw := r.URL.Query().Get("teams")
		if teamsRaw != "" {
			teams = &teamsRaw
		}
		identifierRaw := r.URL.Query().Get("identifier")
		if identifierRaw != "" {
			identifier = &identifierRaw
		}
		{
			pageRaw := r.URL.Query().Get("page")
			if pageRaw != "" {
				v, err2 := strconv.ParseInt(pageRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("page", pageRaw, "integer"))
				}
				pv := int(v)
				page = &pv
			}
		}
		{
			sizeRaw := r.URL.Query().Get("size")
			if sizeRaw != "" {
				v, err2 := strconv.ParseInt(sizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("size", sizeRaw, "integer"))
				}
				pv := int(v)
				size = &pv
			}
		}
		{
			identifiermatchRaw := r.URL.Query().Get("identifiermatch")
			if identifiermatchRaw != "" {
				v, err2 := strconv.ParseBool(identifiermatchRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("identifiermatch", identifiermatchRaw, "boolean"))
				}
				identifiermatch = &v
			}
		}
		identifiersRaw := r.URL.Query().Get("identifiers")
		if identifiersRaw != "" {
			identifiers = &identifiersRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewListTargetsPayload(team, teams, identifier, page, size, identifiermatch, identifiers)

		return payload, nil
	}
}

// EncodeTargetsSummaryResponse returns an encoder for responses returned by
// the targets Targets summary endpoint.
func EncodeTargetsSummaryResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(targetsviews.TargetSummaryCollection)
		enc := encoder(ctx, w)
		body := NewTargetSummaryResponseCollection(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeTargetsSummaryRequest returns a decoder for requests sent to the
// targets Targets summary endpoint.
func DecodeTargetsSummaryRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			team        *string
			teams       *string
			status      *string
			sortBy      *string
			page        *int
			size        *int
			identifiers *string
			labels      *string
			err         error
		)
		teamRaw := r.URL.Query().Get("team")
		if teamRaw != "" {
			team = &teamRaw
		}
		teamsRaw := r.URL.Query().Get("teams")
		if teamsRaw != "" {
			teams = &teamsRaw
		}
		statusRaw := r.URL.Query().Get("status")
		if statusRaw != "" {
			status = &statusRaw
		}
		sortByRaw := r.URL.Query().Get("sortBy")
		if sortByRaw != "" {
			sortBy = &sortByRaw
		}
		{
			pageRaw := r.URL.Query().Get("page")
			if pageRaw != "" {
				v, err2 := strconv.ParseInt(pageRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("page", pageRaw, "integer"))
				}
				pv := int(v)
				page = &pv
			}
		}
		{
			sizeRaw := r.URL.Query().Get("size")
			if sizeRaw != "" {
				v, err2 := strconv.ParseInt(sizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("size", sizeRaw, "integer"))
				}
				pv := int(v)
				size = &pv
			}
		}
		identifiersRaw := r.URL.Query().Get("identifiers")
		if identifiersRaw != "" {
			identifiers = &identifiersRaw
		}
		labelsRaw := r.URL.Query().Get("labels")
		if labelsRaw != "" {
			labels = &labelsRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewTargetsSummaryPayload(team, teams, status, sortBy, page, size, identifiers, labels)

		return payload, nil
	}
}

// EncodeGetTargetResponse returns an encoder for responses returned by the
// targets Get target endpoint.
func EncodeGetTargetResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*targetsviews.Target)
		enc := encoder(ctx, w)
		body := NewGetTargetResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTargetRequest returns a decoder for requests sent to the targets
// Get target endpoint.
func DecodeGetTargetRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id string

			params = mux.Vars(r)
		)
		id = params["id"]
		payload := NewGetTargetPayload(id)

		return payload, nil
	}
}

// EncodeCreateTargetResponse returns an encoder for responses returned by the
// targets Create target endpoint.
func EncodeCreateTargetResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*targetsviews.Target)
		enc := encoder(ctx, w)
		body := NewCreateTargetResponseBody(res.Projected)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateTargetRequest returns a decoder for requests sent to the targets
// Create target endpoint.
func DecodeCreateTargetRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateTargetRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		payload := NewCreateTargetPayload(&body)

		return payload, nil
	}
}

// EncodeListFindingsByTargetResponse returns an encoder for responses returned
// by the targets List findings by target endpoint.
func EncodeListFindingsByTargetResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(targetsviews.FindingCollection)
		enc := encoder(ctx, w)
		body := NewFindingResponseCollection(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListFindingsByTargetRequest returns a decoder for requests sent to the
// targets List findings by target endpoint.
func DecodeListFindingsByTargetRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id     string
			status *string
			sortBy *string
			page   *int
			size   *int
			labels *string
			err    error

			params = mux.Vars(r)
		)
		id = params["id"]
		statusRaw := r.URL.Query().Get("status")
		if statusRaw != "" {
			status = &statusRaw
		}
		sortByRaw := r.URL.Query().Get("sortBy")
		if sortByRaw != "" {
			sortBy = &sortByRaw
		}
		{
			pageRaw := r.URL.Query().Get("page")
			if pageRaw != "" {
				v, err2 := strconv.ParseInt(pageRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("page", pageRaw, "integer"))
				}
				pv := int(v)
				page = &pv
			}
		}
		{
			sizeRaw := r.URL.Query().Get("size")
			if sizeRaw != "" {
				v, err2 := strconv.ParseInt(sizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("size", sizeRaw, "integer"))
				}
				pv := int(v)
				size = &pv
			}
		}
		labelsRaw := r.URL.Query().Get("labels")
		if labelsRaw != "" {
			labels = &labelsRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewListFindingsByTargetPayload(id, status, sortBy, page, size, labels)

		return payload, nil
	}
}

// EncodeGetFindingByTargetIssueAndAffectedResourceResponse returns an encoder
// for responses returned by the targets Get finding by target, issue and
// affected resource endpoint.
func EncodeGetFindingByTargetIssueAndAffectedResourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*targetsviews.Finding)
		enc := encoder(ctx, w)
		body := NewGetFindingByTargetIssueAndAffectedResourceResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetFindingByTargetIssueAndAffectedResourceRequest returns a decoder
// for requests sent to the targets Get finding by target, issue and affected
// resource endpoint.
func DecodeGetFindingByTargetIssueAndAffectedResourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			targetID string
			issueID  string
			resource string

			params = mux.Vars(r)
		)
		targetID = params["target_id"]
		issueID = params["issue_id"]
		resource = params["resource"]
		payload := NewGetFindingByTargetIssueAndAffectedResourcePayload(targetID, issueID, resource)

		return payload, nil
	}
}

// EncodeGetTargetMTTRResponse returns an encoder for responses returned by the
// targets Get target MTTR endpoint.
func EncodeGetTargetMTTRResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(float32)
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTargetMTTRRequest returns a decoder for requests sent to the
// targets Get target MTTR endpoint.
func DecodeGetTargetMTTRRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id string

			params = mux.Vars(r)
		)
		id = params["id"]
		payload := NewGetTargetMTTRPayload(id)

		return payload, nil
	}
}

// EncodeDeleteTargetTeamResponse returns an encoder for responses returned by
// the targets Delete target team endpoint.
func EncodeDeleteTargetTeamResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteTargetTeamRequest returns a decoder for requests sent to the
// targets Delete target team endpoint.
func DecodeDeleteTargetTeamRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			targetID string
			team     string
			auth     string
			err      error

			params = mux.Vars(r)
		)
		targetID = params["target_id"]
		team = params["team"]
		auth = r.Header.Get("Authorization")
		if auth == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("auth", "header"))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("auth", auth, "^TEAM team=[^ ]+$"))
		if err != nil {
			return nil, err
		}
		payload := NewDeleteTargetTeamPayload(targetID, team, auth)

		return payload, nil
	}
}

// EncodeDeleteTeamResponse returns an encoder for responses returned by the
// targets Delete team endpoint.
func EncodeDeleteTeamResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteTeamRequest returns a decoder for requests sent to the targets
// Delete team endpoint.
func DecodeDeleteTeamRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			team string
			auth string
			err  error

			params = mux.Vars(r)
		)
		team = params["team"]
		auth = r.Header.Get("Authorization")
		if auth == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("auth", "header"))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("auth", auth, "^TEAM team=[^ ]+$"))
		if err != nil {
			return nil, err
		}
		payload := NewDeleteTeamPayload(team, auth)

		return payload, nil
	}
}

// marshalTargetsviewsTargetViewToTargetResponse builds a value of type
// *TargetResponse from a value of type *targetsviews.TargetView.
func marshalTargetsviewsTargetViewToTargetResponse(v *targetsviews.TargetView) *TargetResponse {
	res := &TargetResponse{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Teams != nil {
		res.Teams = make([]string, len(v.Teams))
		for i, val := range v.Teams {
			res.Teams[i] = val
		}
	}

	return res
}

// marshalTargetsviewsTargetSummaryViewToTargetSummaryResponse builds a value
// of type *TargetSummaryResponse from a value of type
// *targetsviews.TargetSummaryView.
func marshalTargetsviewsTargetSummaryViewToTargetSummaryResponse(v *targetsviews.TargetSummaryView) *TargetSummaryResponse {
	res := &TargetSummaryResponse{
		TargetID:      v.TargetID,
		Identifier:    v.Identifier,
		FindingsCount: v.FindingsCount,
		IssuesCount:   v.IssuesCount,
		MaxScore:      v.MaxScore,
	}

	return res
}

// marshalTargetsviewsFindingViewToFindingResponse builds a value of type
// *FindingResponse from a value of type *targetsviews.FindingView.
func marshalTargetsviewsFindingViewToFindingResponse(v *targetsviews.FindingView) *FindingResponse {
	res := &FindingResponse{
		ID:            v.ID,
		Details:       v.Details,
		ImpactDetails: v.ImpactDetails,
		Status:        v.Status,
		Score:         v.Score,
	}
	if v.Issue != nil {
		res.Issue = marshalTargetsviewsIssueViewToIssueResponse(v.Issue)
	}
	if v.Target != nil {
		res.Target = marshalTargetsviewsTargetViewToTargetResponse(v.Target)
	}
	if v.Source != nil {
		res.Source = marshalTargetsviewsSourcewithnotargetViewToSourcewithnotargetResponse(v.Source)
	}
	if v.Resources != nil {
		res.Resources = make([]*ResourceGroupResponse, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = marshalTargetsviewsResourceGroupViewToResourceGroupResponse(val)
		}
	}

	return res
}

// marshalTargetsviewsIssueViewToIssueResponse builds a value of type
// *IssueResponse from a value of type *targetsviews.IssueView.
func marshalTargetsviewsIssueViewToIssueResponse(v *targetsviews.IssueView) *IssueResponse {
	if v == nil {
		return nil
	}
	res := &IssueResponse{
		ID:          v.ID,
		Summary:     v.Summary,
		CweID:       v.CweID,
		Description: v.Description,
	}
	if v.Recommendations != nil {
		res.Recommendations = make([]string, len(v.Recommendations))
		for i, val := range v.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if v.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(v.ReferenceLinks))
		for i, val := range v.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// marshalTargetsviewsSourcewithnotargetViewToSourcewithnotargetResponse builds
// a value of type *SourcewithnotargetResponse from a value of type
// *targetsviews.SourcewithnotargetView.
func marshalTargetsviewsSourcewithnotargetViewToSourcewithnotargetResponse(v *targetsviews.SourcewithnotargetView) *SourcewithnotargetResponse {
	if v == nil {
		return nil
	}
	res := &SourcewithnotargetResponse{
		ID:        v.ID,
		Name:      v.Name,
		Component: v.Component,
		Instance:  v.Instance,
		Options:   v.Options,
		Time:      v.Time,
	}

	return res
}

// marshalTargetsviewsResourceGroupViewToResourceGroupResponse builds a value
// of type *ResourceGroupResponse from a value of type
// *targetsviews.ResourceGroupView.
func marshalTargetsviewsResourceGroupViewToResourceGroupResponse(v *targetsviews.ResourceGroupView) *ResourceGroupResponse {
	if v == nil {
		return nil
	}
	res := &ResourceGroupResponse{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// marshalTargetsviewsIssueViewToIssueResponseBody builds a value of type
// *IssueResponseBody from a value of type *targetsviews.IssueView.
func marshalTargetsviewsIssueViewToIssueResponseBody(v *targetsviews.IssueView) *IssueResponseBody {
	if v == nil {
		return nil
	}
	res := &IssueResponseBody{
		ID:          v.ID,
		Summary:     v.Summary,
		CweID:       v.CweID,
		Description: v.Description,
	}
	if v.Recommendations != nil {
		res.Recommendations = make([]string, len(v.Recommendations))
		for i, val := range v.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if v.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(v.ReferenceLinks))
		for i, val := range v.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// marshalTargetsviewsTargetViewToTargetResponseBody builds a value of type
// *TargetResponseBody from a value of type *targetsviews.TargetView.
func marshalTargetsviewsTargetViewToTargetResponseBody(v *targetsviews.TargetView) *TargetResponseBody {
	if v == nil {
		return nil
	}
	res := &TargetResponseBody{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Teams != nil {
		res.Teams = make([]string, len(v.Teams))
		for i, val := range v.Teams {
			res.Teams[i] = val
		}
	}

	return res
}

// marshalTargetsviewsSourcewithnotargetViewToSourcewithnotargetResponseBody
// builds a value of type *SourcewithnotargetResponseBody from a value of type
// *targetsviews.SourcewithnotargetView.
func marshalTargetsviewsSourcewithnotargetViewToSourcewithnotargetResponseBody(v *targetsviews.SourcewithnotargetView) *SourcewithnotargetResponseBody {
	if v == nil {
		return nil
	}
	res := &SourcewithnotargetResponseBody{
		ID:        v.ID,
		Name:      v.Name,
		Component: v.Component,
		Instance:  v.Instance,
		Options:   v.Options,
		Time:      v.Time,
	}

	return res
}

// marshalTargetsviewsResourceGroupViewToResourceGroupResponseBody builds a
// value of type *ResourceGroupResponseBody from a value of type
// *targetsviews.ResourceGroupView.
func marshalTargetsviewsResourceGroupViewToResourceGroupResponseBody(v *targetsviews.ResourceGroupView) *ResourceGroupResponseBody {
	if v == nil {
		return nil
	}
	res := &ResourceGroupResponseBody{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}
