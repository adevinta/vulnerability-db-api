// Code generated by goa v3.5.2, DO NOT EDIT.
//
// issues HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"fmt"
	"strconv"

	issues "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/issues"
)

// BuildListIssuesPayload builds the payload for the issues List issues
// endpoint from CLI flags.
func BuildListIssuesPayload(issuesListIssuesPage string, issuesListIssuesSize string) (*issues.ListIssuesPayload, error) {
	var err error
	var page *int
	{
		if issuesListIssuesPage != "" {
			var v int64
			v, err = strconv.ParseInt(issuesListIssuesPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if issuesListIssuesSize != "" {
			var v int64
			v, err = strconv.ParseInt(issuesListIssuesSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	v := &issues.ListIssuesPayload{}
	v.Page = page
	v.Size = size

	return v, nil
}

// BuildIssuesSummaryPayload builds the payload for the issues Issues summary
// endpoint from CLI flags.
func BuildIssuesSummaryPayload(issuesIssuesSummaryTag string, issuesIssuesSummaryStatus string, issuesIssuesSummarySortBy string, issuesIssuesSummaryPage string, issuesIssuesSummarySize string, issuesIssuesSummaryIdentifiers string, issuesIssuesSummaryLabels string) (*issues.IssuesSummaryPayload, error) {
	var err error
	var tag *string
	{
		if issuesIssuesSummaryTag != "" {
			tag = &issuesIssuesSummaryTag
		}
	}
	var status *string
	{
		if issuesIssuesSummaryStatus != "" {
			status = &issuesIssuesSummaryStatus
		}
	}
	var sortBy *string
	{
		if issuesIssuesSummarySortBy != "" {
			sortBy = &issuesIssuesSummarySortBy
		}
	}
	var page *int
	{
		if issuesIssuesSummaryPage != "" {
			var v int64
			v, err = strconv.ParseInt(issuesIssuesSummaryPage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if issuesIssuesSummarySize != "" {
			var v int64
			v, err = strconv.ParseInt(issuesIssuesSummarySize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	var identifiers *string
	{
		if issuesIssuesSummaryIdentifiers != "" {
			identifiers = &issuesIssuesSummaryIdentifiers
		}
	}
	var labels *string
	{
		if issuesIssuesSummaryLabels != "" {
			labels = &issuesIssuesSummaryLabels
		}
	}
	v := &issues.IssuesSummaryPayload{}
	v.Tag = tag
	v.Status = status
	v.SortBy = sortBy
	v.Page = page
	v.Size = size
	v.Identifiers = identifiers
	v.Labels = labels

	return v, nil
}

// BuildGetIssuePayload builds the payload for the issues Get issue endpoint
// from CLI flags.
func BuildGetIssuePayload(issuesGetIssueID string) (*issues.GetIssuePayload, error) {
	var id string
	{
		id = issuesGetIssueID
	}
	v := &issues.GetIssuePayload{}
	v.ID = &id

	return v, nil
}

// BuildListFindingsByIssuePayload builds the payload for the issues List
// findings by issue endpoint from CLI flags.
func BuildListFindingsByIssuePayload(issuesListFindingsByIssueID string, issuesListFindingsByIssueStatus string, issuesListFindingsByIssueSortBy string, issuesListFindingsByIssuePage string, issuesListFindingsByIssueSize string, issuesListFindingsByIssueIdentifiers string, issuesListFindingsByIssueLabels string) (*issues.ListFindingsByIssuePayload, error) {
	var err error
	var id string
	{
		id = issuesListFindingsByIssueID
	}
	var status *string
	{
		if issuesListFindingsByIssueStatus != "" {
			status = &issuesListFindingsByIssueStatus
		}
	}
	var sortBy *string
	{
		if issuesListFindingsByIssueSortBy != "" {
			sortBy = &issuesListFindingsByIssueSortBy
		}
	}
	var page *int
	{
		if issuesListFindingsByIssuePage != "" {
			var v int64
			v, err = strconv.ParseInt(issuesListFindingsByIssuePage, 10, 64)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var size *int
	{
		if issuesListFindingsByIssueSize != "" {
			var v int64
			v, err = strconv.ParseInt(issuesListFindingsByIssueSize, 10, 64)
			val := int(v)
			size = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for size, must be INT")
			}
		}
	}
	var identifiers *string
	{
		if issuesListFindingsByIssueIdentifiers != "" {
			identifiers = &issuesListFindingsByIssueIdentifiers
		}
	}
	var labels *string
	{
		if issuesListFindingsByIssueLabels != "" {
			labels = &issuesListFindingsByIssueLabels
		}
	}
	v := &issues.ListFindingsByIssuePayload{}
	v.ID = &id
	v.Status = status
	v.SortBy = sortBy
	v.Page = page
	v.Size = size
	v.Identifiers = identifiers
	v.Labels = labels

	return v, nil
}

// BuildGetFindingByIssueTargetAndAffectedResourcePayload builds the payload
// for the issues Get finding by issue, target and affected resource endpoint
// from CLI flags.
func BuildGetFindingByIssueTargetAndAffectedResourcePayload(issuesGetFindingByIssueTargetAndAffectedResourceIssueID string, issuesGetFindingByIssueTargetAndAffectedResourceTargetID string, issuesGetFindingByIssueTargetAndAffectedResourceResource string) (*issues.GetFindingByIssueTargetAndAffectedResourcePayload, error) {
	var issueID string
	{
		issueID = issuesGetFindingByIssueTargetAndAffectedResourceIssueID
	}
	var targetID string
	{
		targetID = issuesGetFindingByIssueTargetAndAffectedResourceTargetID
	}
	var resource string
	{
		resource = issuesGetFindingByIssueTargetAndAffectedResourceResource
	}
	v := &issues.GetFindingByIssueTargetAndAffectedResourcePayload{}
	v.IssueID = &issueID
	v.TargetID = &targetID
	v.Resource = &resource

	return v, nil
}

// BuildGetIssueMTTRPayload builds the payload for the issues Get issue MTTR
// endpoint from CLI flags.
func BuildGetIssueMTTRPayload(issuesGetIssueMTTRID string) (*issues.GetIssueMTTRPayload, error) {
	var id string
	{
		id = issuesGetIssueMTTRID
	}
	v := &issues.GetIssueMTTRPayload{}
	v.ID = &id

	return v, nil
}
