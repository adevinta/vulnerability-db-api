// Code generated by goa v3.0.6, DO NOT EDIT.
//
// issues HTTP server types
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package server

import (
	issues "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/issues"
	issuesviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/issues/views"
)

// IssueResponseCollection is the type of the "issues" service "List issues"
// endpoint HTTP response body.
type IssueResponseCollection []*IssueResponse

// IssueSummaryResponseCollection is the type of the "issues" service "Issues
// summary" endpoint HTTP response body.
type IssueSummaryResponseCollection []*IssueSummaryResponse

// GetIssueResponseBody is the type of the "issues" service "Get issue"
// endpoint HTTP response body.
type GetIssueResponseBody struct {
	// Issue ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Issue summary
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// Common Weakness Enumeration ID
	CweID *int `form:"cwe_id,omitempty" json:"cwe_id,omitempty" xml:"cwe_id,omitempty"`
	// Issue description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Recommendations to fix the issue
	Recommendations []string `form:"recommendations,omitempty" json:"recommendations,omitempty" xml:"recommendations,omitempty"`
	// Documentation reference for the issue
	ReferenceLinks []string `form:"reference_links,omitempty" json:"reference_links,omitempty" xml:"reference_links,omitempty"`
}

// FindingResponseCollection is the type of the "issues" service "List findings
// by issue" endpoint HTTP response body.
type FindingResponseCollection []*FindingResponse

// ListFindingsByIssueAndTargetResponseBody is the type of the "issues" service
// "List findings by issue and target" endpoint HTTP response body.
type ListFindingsByIssueAndTargetResponseBody struct {
	// Finding ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Issue
	Issue *IssueResponseBody `form:"issue,omitempty" json:"issue,omitempty" xml:"issue,omitempty"`
	// Target
	Target *TargetResponseBody `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
	// Source
	Source *SourcewithnotargetResponseBody `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// Finding details
	Details *string `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
	// Finding impact details
	ImpactDetails *string `form:"impact_details,omitempty" json:"impact_details,omitempty" xml:"impact_details,omitempty"`
	// Finding status. Can be 'OPEN' or 'FIXED'.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Finding severity score
	Score *float32 `form:"score,omitempty" json:"score,omitempty" xml:"score,omitempty"`
	// Other resources associated with the finding
	Resources []*ResourceGroupResponseBody `form:"resources,omitempty" json:"resources,omitempty" xml:"resources,omitempty"`
}

// IssueResponse is used to define fields on response body types.
type IssueResponse struct {
	// Issue ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Issue summary
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// Common Weakness Enumeration ID
	CweID *int `form:"cwe_id,omitempty" json:"cwe_id,omitempty" xml:"cwe_id,omitempty"`
	// Issue description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Recommendations to fix the issue
	Recommendations []string `form:"recommendations,omitempty" json:"recommendations,omitempty" xml:"recommendations,omitempty"`
	// Documentation reference for the issue
	ReferenceLinks []string `form:"reference_links,omitempty" json:"reference_links,omitempty" xml:"reference_links,omitempty"`
}

// IssueSummaryResponse is used to define fields on response body types.
type IssueSummaryResponse struct {
	// Issue ID
	IssueID *string `form:"issue_id,omitempty" json:"issue_id,omitempty" xml:"issue_id,omitempty"`
	// Issue summary
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// Number of affected targets for issue
	TargetsCount *int `form:"targets_count,omitempty" json:"targets_count,omitempty" xml:"targets_count,omitempty"`
	// Max score for issue
	MaxScore *float32 `form:"max_score,omitempty" json:"max_score,omitempty" xml:"max_score,omitempty"`
}

// FindingResponse is used to define fields on response body types.
type FindingResponse struct {
	// Finding ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Issue
	Issue *IssueResponse `form:"issue,omitempty" json:"issue,omitempty" xml:"issue,omitempty"`
	// Target
	Target *TargetResponse `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
	// Source
	Source *SourcewithnotargetResponse `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// Finding details
	Details *string `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
	// Finding impact details
	ImpactDetails *string `form:"impact_details,omitempty" json:"impact_details,omitempty" xml:"impact_details,omitempty"`
	// Finding status. Can be 'OPEN' or 'FIXED'.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Finding severity score
	Score *float32 `form:"score,omitempty" json:"score,omitempty" xml:"score,omitempty"`
	// Other resources associated with the finding
	Resources []*ResourceGroupResponse `form:"resources,omitempty" json:"resources,omitempty" xml:"resources,omitempty"`
}

// TargetResponse is used to define fields on response body types.
type TargetResponse struct {
	// Target ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Target identifier
	Identifier *string `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// List of tags associated with target
	Tags []string `form:"tags,omitempty" json:"tags,omitempty" xml:"tags,omitempty"`
}

// SourcewithnotargetResponse is used to define fields on response body types.
type SourcewithnotargetResponse struct {
	// Source ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Source name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Source component
	Component *string `form:"component,omitempty" json:"component,omitempty" xml:"component,omitempty"`
	// Source instance
	Instance *string `form:"instance,omitempty" json:"instance,omitempty" xml:"instance,omitempty"`
	// Source options
	Options *string `form:"options,omitempty" json:"options,omitempty" xml:"options,omitempty"`
	// Time on which the source scanned the target
	Time *string `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
}

// ResourceGroupResponse is used to define fields on response body types.
type ResourceGroupResponse struct {
	// Name of the resource group
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Column names of the resource group in the order that should be rendered
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// List containing the resource rows as hashmap
	Resources []map[string]string `form:"resources,omitempty" json:"resources,omitempty" xml:"resources,omitempty"`
}

// IssueResponseBody is used to define fields on response body types.
type IssueResponseBody struct {
	// Issue ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Issue summary
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// Common Weakness Enumeration ID
	CweID *int `form:"cwe_id,omitempty" json:"cwe_id,omitempty" xml:"cwe_id,omitempty"`
	// Issue description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Recommendations to fix the issue
	Recommendations []string `form:"recommendations,omitempty" json:"recommendations,omitempty" xml:"recommendations,omitempty"`
	// Documentation reference for the issue
	ReferenceLinks []string `form:"reference_links,omitempty" json:"reference_links,omitempty" xml:"reference_links,omitempty"`
}

// TargetResponseBody is used to define fields on response body types.
type TargetResponseBody struct {
	// Target ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Target identifier
	Identifier *string `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// List of tags associated with target
	Tags []string `form:"tags,omitempty" json:"tags,omitempty" xml:"tags,omitempty"`
}

// SourcewithnotargetResponseBody is used to define fields on response body
// types.
type SourcewithnotargetResponseBody struct {
	// Source ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Source name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Source component
	Component *string `form:"component,omitempty" json:"component,omitempty" xml:"component,omitempty"`
	// Source instance
	Instance *string `form:"instance,omitempty" json:"instance,omitempty" xml:"instance,omitempty"`
	// Source options
	Options *string `form:"options,omitempty" json:"options,omitempty" xml:"options,omitempty"`
	// Time on which the source scanned the target
	Time *string `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
}

// ResourceGroupResponseBody is used to define fields on response body types.
type ResourceGroupResponseBody struct {
	// Name of the resource group
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Column names of the resource group in the order that should be rendered
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// List containing the resource rows as hashmap
	Resources []map[string]string `form:"resources,omitempty" json:"resources,omitempty" xml:"resources,omitempty"`
}

// NewIssueResponseCollection builds the HTTP response body from the result of
// the "List issues" endpoint of the "issues" service.
func NewIssueResponseCollection(res issuesviews.IssueCollectionView) IssueResponseCollection {
	body := make([]*IssueResponse, len(res))
	for i, val := range res {
		body[i] = &IssueResponse{
			ID:          val.ID,
			Summary:     val.Summary,
			CweID:       val.CweID,
			Description: val.Description,
		}
		if val.Recommendations != nil {
			body[i].Recommendations = make([]string, len(val.Recommendations))
			for j, val := range val.Recommendations {
				body[i].Recommendations[j] = val
			}
		}
		if val.ReferenceLinks != nil {
			body[i].ReferenceLinks = make([]string, len(val.ReferenceLinks))
			for j, val := range val.ReferenceLinks {
				body[i].ReferenceLinks[j] = val
			}
		}
	}
	return body
}

// NewIssueSummaryResponseCollection builds the HTTP response body from the
// result of the "Issues summary" endpoint of the "issues" service.
func NewIssueSummaryResponseCollection(res issuesviews.IssueSummaryCollectionView) IssueSummaryResponseCollection {
	body := make([]*IssueSummaryResponse, len(res))
	for i, val := range res {
		body[i] = &IssueSummaryResponse{
			IssueID:      val.IssueID,
			Summary:      val.Summary,
			TargetsCount: val.TargetsCount,
			MaxScore:     val.MaxScore,
		}
	}
	return body
}

// NewGetIssueResponseBody builds the HTTP response body from the result of the
// "Get issue" endpoint of the "issues" service.
func NewGetIssueResponseBody(res *issuesviews.IssueView) *GetIssueResponseBody {
	body := &GetIssueResponseBody{
		ID:          res.ID,
		Summary:     res.Summary,
		CweID:       res.CweID,
		Description: res.Description,
	}
	if res.Recommendations != nil {
		body.Recommendations = make([]string, len(res.Recommendations))
		for i, val := range res.Recommendations {
			body.Recommendations[i] = val
		}
	}
	if res.ReferenceLinks != nil {
		body.ReferenceLinks = make([]string, len(res.ReferenceLinks))
		for i, val := range res.ReferenceLinks {
			body.ReferenceLinks[i] = val
		}
	}
	return body
}

// NewFindingResponseCollection builds the HTTP response body from the result
// of the "List findings by issue" endpoint of the "issues" service.
func NewFindingResponseCollection(res issuesviews.FindingCollectionView) FindingResponseCollection {
	body := make([]*FindingResponse, len(res))
	for i, val := range res {
		body[i] = &FindingResponse{
			ID:            val.ID,
			Details:       val.Details,
			ImpactDetails: val.ImpactDetails,
			Status:        val.Status,
			Score:         val.Score,
		}
		if val.Issue != nil {
			body[i].Issue = marshalIssuesviewsIssueViewToIssueResponse(val.Issue)
		}
		if val.Target != nil {
			body[i].Target = marshalIssuesviewsTargetViewToTargetResponse(val.Target)
		}
		if val.Source != nil {
			body[i].Source = marshalIssuesviewsSourcewithnotargetViewToSourcewithnotargetResponse(val.Source)
		}
		if val.Resources != nil {
			body[i].Resources = make([]*ResourceGroupResponse, len(val.Resources))
			for j, val := range val.Resources {
				body[i].Resources[j] = marshalIssuesviewsResourceGroupViewToResourceGroupResponse(val)
			}
		}
	}
	return body
}

// NewListFindingsByIssueAndTargetResponseBody builds the HTTP response body
// from the result of the "List findings by issue and target" endpoint of the
// "issues" service.
func NewListFindingsByIssueAndTargetResponseBody(res *issuesviews.FindingView) *ListFindingsByIssueAndTargetResponseBody {
	body := &ListFindingsByIssueAndTargetResponseBody{
		ID:            res.ID,
		Details:       res.Details,
		ImpactDetails: res.ImpactDetails,
		Status:        res.Status,
		Score:         res.Score,
	}
	if res.Issue != nil {
		body.Issue = marshalIssuesviewsIssueViewToIssueResponseBody(res.Issue)
	}
	if res.Target != nil {
		body.Target = marshalIssuesviewsTargetViewToTargetResponseBody(res.Target)
	}
	if res.Source != nil {
		body.Source = marshalIssuesviewsSourcewithnotargetViewToSourcewithnotargetResponseBody(res.Source)
	}
	if res.Resources != nil {
		body.Resources = make([]*ResourceGroupResponseBody, len(res.Resources))
		for i, val := range res.Resources {
			body.Resources[i] = marshalIssuesviewsResourceGroupViewToResourceGroupResponseBody(val)
		}
	}
	return body
}

// NewListIssuesPayload builds a issues service List issues endpoint payload.
func NewListIssuesPayload(page *int, size *int) *issues.ListIssuesPayload {
	return &issues.ListIssuesPayload{
		Page: page,
		Size: size,
	}
}

// NewIssuesSummaryPayload builds a issues service Issues summary endpoint
// payload.
func NewIssuesSummaryPayload(tag *string, status *string, sortBy *string, page *int, size *int) *issues.IssuesSummaryPayload {
	return &issues.IssuesSummaryPayload{
		Tag:    tag,
		Status: status,
		SortBy: sortBy,
		Page:   page,
		Size:   size,
	}
}

// NewGetIssuePayload builds a issues service Get issue endpoint payload.
func NewGetIssuePayload(id string) *issues.GetIssuePayload {
	return &issues.GetIssuePayload{
		ID: &id,
	}
}

// NewListFindingsByIssuePayload builds a issues service List findings by issue
// endpoint payload.
func NewListFindingsByIssuePayload(id string, status *string, sortBy *string, page *int, size *int) *issues.ListFindingsByIssuePayload {
	return &issues.ListFindingsByIssuePayload{
		ID:     &id,
		Status: status,
		SortBy: sortBy,
		Page:   page,
		Size:   size,
	}
}

// NewListFindingsByIssueAndTargetPayload builds a issues service List findings
// by issue and target endpoint payload.
func NewListFindingsByIssueAndTargetPayload(issueID string, targetID string) *issues.ListFindingsByIssueAndTargetPayload {
	return &issues.ListFindingsByIssueAndTargetPayload{
		IssueID:  &issueID,
		TargetID: &targetID,
	}
}

// NewGetIssueMTTRPayload builds a issues service Get issue MTTR endpoint
// payload.
func NewGetIssueMTTRPayload(id string) *issues.GetIssueMTTRPayload {
	return &issues.GetIssueMTTRPayload{
		ID: &id,
	}
}
