// Code generated by goa v3.5.2, DO NOT EDIT.
//
// stats HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package client

import (
	"fmt"
	"strconv"

	stats "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/stats"
)

// BuildGetOpenIssuesStatsPayload builds the payload for the stats Get open
// issues stats endpoint from CLI flags.
func BuildGetOpenIssuesStatsPayload(statsGetOpenIssuesStatsTag string, statsGetOpenIssuesStatsMinDate string, statsGetOpenIssuesStatsMaxDate string, statsGetOpenIssuesStatsAtDate string, statsGetOpenIssuesStatsIdentifiers string, statsGetOpenIssuesStatsLabels string) (*stats.GetOpenIssuesStatsPayload, error) {
	var tag *string
	{
		if statsGetOpenIssuesStatsTag != "" {
			tag = &statsGetOpenIssuesStatsTag
		}
	}
	var minDate *string
	{
		if statsGetOpenIssuesStatsMinDate != "" {
			minDate = &statsGetOpenIssuesStatsMinDate
		}
	}
	var maxDate *string
	{
		if statsGetOpenIssuesStatsMaxDate != "" {
			maxDate = &statsGetOpenIssuesStatsMaxDate
		}
	}
	var atDate *string
	{
		if statsGetOpenIssuesStatsAtDate != "" {
			atDate = &statsGetOpenIssuesStatsAtDate
		}
	}
	var identifiers *string
	{
		if statsGetOpenIssuesStatsIdentifiers != "" {
			identifiers = &statsGetOpenIssuesStatsIdentifiers
		}
	}
	var labels *string
	{
		if statsGetOpenIssuesStatsLabels != "" {
			labels = &statsGetOpenIssuesStatsLabels
		}
	}
	v := &stats.GetOpenIssuesStatsPayload{}
	v.Tag = tag
	v.MinDate = minDate
	v.MaxDate = maxDate
	v.AtDate = atDate
	v.Identifiers = identifiers
	v.Labels = labels

	return v, nil
}

// BuildGetFixedIssuesStatsPayload builds the payload for the stats Get fixed
// issues stats endpoint from CLI flags.
func BuildGetFixedIssuesStatsPayload(statsGetFixedIssuesStatsTag string, statsGetFixedIssuesStatsMinDate string, statsGetFixedIssuesStatsMaxDate string, statsGetFixedIssuesStatsAtDate string, statsGetFixedIssuesStatsIdentifiers string, statsGetFixedIssuesStatsLabels string) (*stats.GetFixedIssuesStatsPayload, error) {
	var tag *string
	{
		if statsGetFixedIssuesStatsTag != "" {
			tag = &statsGetFixedIssuesStatsTag
		}
	}
	var minDate *string
	{
		if statsGetFixedIssuesStatsMinDate != "" {
			minDate = &statsGetFixedIssuesStatsMinDate
		}
	}
	var maxDate *string
	{
		if statsGetFixedIssuesStatsMaxDate != "" {
			maxDate = &statsGetFixedIssuesStatsMaxDate
		}
	}
	var atDate *string
	{
		if statsGetFixedIssuesStatsAtDate != "" {
			atDate = &statsGetFixedIssuesStatsAtDate
		}
	}
	var identifiers *string
	{
		if statsGetFixedIssuesStatsIdentifiers != "" {
			identifiers = &statsGetFixedIssuesStatsIdentifiers
		}
	}
	var labels *string
	{
		if statsGetFixedIssuesStatsLabels != "" {
			labels = &statsGetFixedIssuesStatsLabels
		}
	}
	v := &stats.GetFixedIssuesStatsPayload{}
	v.Tag = tag
	v.MinDate = minDate
	v.MaxDate = maxDate
	v.AtDate = atDate
	v.Identifiers = identifiers
	v.Labels = labels

	return v, nil
}

// BuildGetIssuesStatsPayload builds the payload for the stats Get issues stats
// endpoint from CLI flags.
func BuildGetIssuesStatsPayload(statsGetIssuesStatsMinDate string, statsGetIssuesStatsMaxDate string, statsGetIssuesStatsMinScore string, statsGetIssuesStatsMaxScore string) (*stats.GetIssuesStatsPayload, error) {
	var err error
	var minDate *string
	{
		if statsGetIssuesStatsMinDate != "" {
			minDate = &statsGetIssuesStatsMinDate
		}
	}
	var maxDate *string
	{
		if statsGetIssuesStatsMaxDate != "" {
			maxDate = &statsGetIssuesStatsMaxDate
		}
	}
	var minScore *int
	{
		if statsGetIssuesStatsMinScore != "" {
			var v int64
			v, err = strconv.ParseInt(statsGetIssuesStatsMinScore, 10, 64)
			val := int(v)
			minScore = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for minScore, must be INT")
			}
		}
	}
	var maxScore *int
	{
		if statsGetIssuesStatsMaxScore != "" {
			var v int64
			v, err = strconv.ParseInt(statsGetIssuesStatsMaxScore, 10, 64)
			val := int(v)
			maxScore = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for maxScore, must be INT")
			}
		}
	}
	v := &stats.GetIssuesStatsPayload{}
	v.MinDate = minDate
	v.MaxDate = maxDate
	v.MinScore = minScore
	v.MaxScore = maxScore

	return v, nil
}

// BuildGetStatsMTTRPayload builds the payload for the stats Get stats MTTR
// endpoint from CLI flags.
func BuildGetStatsMTTRPayload(statsGetStatsMTTRTag string, statsGetStatsMTTRMinDate string, statsGetStatsMTTRMaxDate string) (*stats.GetStatsMTTRPayload, error) {
	var tag *string
	{
		if statsGetStatsMTTRTag != "" {
			tag = &statsGetStatsMTTRTag
		}
	}
	var minDate *string
	{
		if statsGetStatsMTTRMinDate != "" {
			minDate = &statsGetStatsMTTRMinDate
		}
	}
	var maxDate *string
	{
		if statsGetStatsMTTRMaxDate != "" {
			maxDate = &statsGetStatsMTTRMaxDate
		}
	}
	v := &stats.GetStatsMTTRPayload{}
	v.Tag = tag
	v.MinDate = minDate
	v.MaxDate = maxDate

	return v, nil
}

// BuildGetStatsExposurePayload builds the payload for the stats Get stats
// exposure endpoint from CLI flags.
func BuildGetStatsExposurePayload(statsGetStatsExposureTag string, statsGetStatsExposureAtDate string, statsGetStatsExposureMinScore string, statsGetStatsExposureMaxScore string) (*stats.GetStatsExposurePayload, error) {
	var err error
	var tag *string
	{
		if statsGetStatsExposureTag != "" {
			tag = &statsGetStatsExposureTag
		}
	}
	var atDate *string
	{
		if statsGetStatsExposureAtDate != "" {
			atDate = &statsGetStatsExposureAtDate
		}
	}
	var minScore *int
	{
		if statsGetStatsExposureMinScore != "" {
			var v int64
			v, err = strconv.ParseInt(statsGetStatsExposureMinScore, 10, 64)
			val := int(v)
			minScore = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for minScore, must be INT")
			}
		}
	}
	var maxScore *int
	{
		if statsGetStatsExposureMaxScore != "" {
			var v int64
			v, err = strconv.ParseInt(statsGetStatsExposureMaxScore, 10, 64)
			val := int(v)
			maxScore = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for maxScore, must be INT")
			}
		}
	}
	v := &stats.GetStatsExposurePayload{}
	v.Tag = tag
	v.AtDate = atDate
	v.MinScore = minScore
	v.MaxScore = maxScore

	return v, nil
}
