// Code generated by goa v3.0.6, DO NOT EDIT.
//
// findings service
//
// Command:
// $ goa gen
// github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/design

package findings

import (
	"context"

	findingsviews "github.com/adevinta/vulnerability-db-api/cmd/vulnerability-db-api-cli/gen/findings/views"
	"goa.design/goa/v3/security"
)

// Findings endpoint.
type Service interface {
	// This method allows to list findings by using different filters.
	// When querying for open findings in a specific time range, it returns every
	// finding that has been found in that time, regardless if that finding has
	// also been fixed in that span of time.
	// When querying for fixed findings in a specific time range, it returns every
	// finding that has been fixed in that time and it's fixed at the end of that
	// time range, so a finding that is fixed and then reopened in that range of
	// time will not be returned.
	ListFindings(context.Context, *ListFindingsPayload) (res FindingCollection, err error)
	// GetFinding implements Get finding.
	GetFinding(context.Context, *GetFindingPayload) (res *Finding, err error)
	// ListEventsByFinding implements List events by finding.
	ListEventsByFinding(context.Context, *ListEventsByFindingPayload) (res EventCollection, err error)
	// GetFindingMTTR implements Get finding MTTR.
	GetFindingMTTR(context.Context, *GetFindingMTTRPayload) (res *Mttr, err error)
	// PatchFinding implements Patch finding.
	PatchFinding(context.Context, *PatchFindingPayload) (res *Finding, err error)
}

// Auther defines the authorization functions to be implemented by the service.
type Auther interface {
	// APIKeyAuth implements the authorization logic for the APIKey security scheme.
	APIKeyAuth(ctx context.Context, key string, schema *security.APIKeyScheme) (context.Context, error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "findings"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [5]string{"List findings", "Get finding", "List events by finding", "Get finding MTTR", "Patch finding"}

// ListFindingsPayload is the payload type of the findings service List
// findings method.
type ListFindingsPayload struct {
	// Targets tag filter
	Tag *string
	// Finding status filter. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Minimum issues score filter
	MinScore *int
	// Maximum issues score filter
	MaxScore *int
	// Allows to get a list of findings for a specific date (YYY-MM-DD). This
	// filter has preference over minDate and maxDate.
	AtDate *string
	// Minimum date filter (YYY-MM-DD). This filter only applies when used in
	// conjunction with status filter.
	MinDate *string
	// Maximum date filter (YYY-MM-DD). This filter only applies when used in
	// conjunction with status filter.
	MaxDate *string
	// Sorting criteria. Supported fields: score, -score (for descending order)
	SortBy *string
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
	// Findings identifier filter
	Identifier *string
	// Exact match in identifier filter
	Identifiermatch *bool
}

// FindingCollection is the result type of the findings service List findings
// method.
type FindingCollection []*Finding

// GetFindingPayload is the payload type of the findings service Get finding
// method.
type GetFindingPayload struct {
	// Finding ID
	ID *string
}

// Finding is the result type of the findings service Get finding method.
type Finding struct {
	// Finding ID
	ID *string
	// Issue
	Issue *Issue
	// Target
	Target *Target
	// Source
	Source *Sourcewithnotarget
	// Finding details
	Details *string
	// Finding impact details
	ImpactDetails *string
	// Finding status. Can be 'OPEN' or 'FIXED'.
	Status *string
	// Finding severity score
	Score *float32
	// Other resources associated with the finding
	Resources []*ResourceGroup
}

// ListEventsByFindingPayload is the payload type of the findings service List
// events by finding method.
type ListEventsByFindingPayload struct {
	// Finding ID
	ID *string
	// Number of page requested
	Page *int
	// Number of results per page
	Size *int
}

// EventCollection is the result type of the findings service List events by
// finding method.
type EventCollection []*Event

// GetFindingMTTRPayload is the payload type of the findings service Get
// finding MTTR method.
type GetFindingMTTRPayload struct {
	// Finding ID
	ID *string
}

// Mttr is the result type of the findings service Get finding MTTR method.
type Mttr struct {
	Mttr *int
}

// PatchFindingPayload is the payload type of the findings service Patch
// finding method.
type PatchFindingPayload struct {
	Authorization *string
	// Finding ID
	ID *string
	// Status
	Status *string
}

type Issue struct {
	// Issue ID
	ID *string
	// Issue summary
	Summary *string
	// Common Weakness Enumeration ID
	CweID *int
	// Issue description
	Description *string
	// Recommendations to fix the issue
	Recommendations []string
	// Documentation reference for the issue
	ReferenceLinks []string
}

type Target struct {
	// Target ID
	ID *string
	// Target identifier
	Identifier *string
	// List of tags associated with target
	Tags []string
}

type Sourcewithnotarget struct {
	// Source ID
	ID *string
	// Source name
	Name *string
	// Source component
	Component *string
	// Source instance
	Instance *string
	// Source options
	Options *string
	// Time on which the source scanned the target
	Time *string
}

type ResourceGroup struct {
	// Name of the resource group
	Name *string
	// Column names of the resource group in the order that should be rendered
	Attributes []string
	// List containing the resource rows as hashmap
	Resources []map[string]string
}

type Event struct {
	// Finding event ID
	ID *string
	// Finding ID
	FindingID *string
	// Source ID
	SourceID *string
	// Finding severity score
	Score *float32
	// Event time
	Time *string
}

// NewFindingCollection initializes result type FindingCollection from viewed
// result type FindingCollection.
func NewFindingCollection(vres findingsviews.FindingCollection) FindingCollection {
	var res FindingCollection
	switch vres.View {
	case "default", "":
		res = newFindingCollection(vres.Projected)
	}
	return res
}

// NewViewedFindingCollection initializes viewed result type FindingCollection
// from result type FindingCollection using the given view.
func NewViewedFindingCollection(res FindingCollection, view string) findingsviews.FindingCollection {
	var vres findingsviews.FindingCollection
	switch view {
	case "default", "":
		p := newFindingCollectionView(res)
		vres = findingsviews.FindingCollection{p, "default"}
	}
	return vres
}

// NewFinding initializes result type Finding from viewed result type Finding.
func NewFinding(vres *findingsviews.Finding) *Finding {
	var res *Finding
	switch vres.View {
	case "default", "":
		res = newFinding(vres.Projected)
	}
	return res
}

// NewViewedFinding initializes viewed result type Finding from result type
// Finding using the given view.
func NewViewedFinding(res *Finding, view string) *findingsviews.Finding {
	var vres *findingsviews.Finding
	switch view {
	case "default", "":
		p := newFindingView(res)
		vres = &findingsviews.Finding{p, "default"}
	}
	return vres
}

// NewEventCollection initializes result type EventCollection from viewed
// result type EventCollection.
func NewEventCollection(vres findingsviews.EventCollection) EventCollection {
	var res EventCollection
	switch vres.View {
	case "default", "":
		res = newEventCollection(vres.Projected)
	}
	return res
}

// NewViewedEventCollection initializes viewed result type EventCollection from
// result type EventCollection using the given view.
func NewViewedEventCollection(res EventCollection, view string) findingsviews.EventCollection {
	var vres findingsviews.EventCollection
	switch view {
	case "default", "":
		p := newEventCollectionView(res)
		vres = findingsviews.EventCollection{p, "default"}
	}
	return vres
}

// NewMttr initializes result type Mttr from viewed result type Mttr.
func NewMttr(vres *findingsviews.Mttr) *Mttr {
	var res *Mttr
	switch vres.View {
	case "default", "":
		res = newMttr(vres.Projected)
	}
	return res
}

// NewViewedMttr initializes viewed result type Mttr from result type Mttr
// using the given view.
func NewViewedMttr(res *Mttr, view string) *findingsviews.Mttr {
	var vres *findingsviews.Mttr
	switch view {
	case "default", "":
		p := newMttrView(res)
		vres = &findingsviews.Mttr{p, "default"}
	}
	return vres
}

// newFindingCollection converts projected type FindingCollection to service
// type FindingCollection.
func newFindingCollection(vres findingsviews.FindingCollectionView) FindingCollection {
	res := make(FindingCollection, len(vres))
	for i, n := range vres {
		res[i] = newFinding(n)
	}
	return res
}

// newFindingCollectionView projects result type FindingCollection to projected
// type FindingCollectionView using the "default" view.
func newFindingCollectionView(res FindingCollection) findingsviews.FindingCollectionView {
	vres := make(findingsviews.FindingCollectionView, len(res))
	for i, n := range res {
		vres[i] = newFindingView(n)
	}
	return vres
}

// newFinding converts projected type Finding to service type Finding.
func newFinding(vres *findingsviews.FindingView) *Finding {
	res := &Finding{
		ID:            vres.ID,
		Details:       vres.Details,
		ImpactDetails: vres.ImpactDetails,
		Status:        vres.Status,
		Score:         vres.Score,
	}
	if vres.Target != nil {
		res.Target = transformFindingsviewsTargetViewToTarget(vres.Target)
	}
	if vres.Resources != nil {
		res.Resources = make([]*ResourceGroup, len(vres.Resources))
		for i, val := range vres.Resources {
			res.Resources[i] = transformFindingsviewsResourceGroupViewToResourceGroup(val)
		}
	}
	if vres.Issue != nil {
		res.Issue = newIssue(vres.Issue)
	}
	if vres.Source != nil {
		res.Source = newSourcewithnotarget(vres.Source)
	}
	return res
}

// newFindingView projects result type Finding to projected type FindingView
// using the "default" view.
func newFindingView(res *Finding) *findingsviews.FindingView {
	vres := &findingsviews.FindingView{
		ID:            res.ID,
		Details:       res.Details,
		ImpactDetails: res.ImpactDetails,
		Status:        res.Status,
		Score:         res.Score,
	}
	if res.Target != nil {
		vres.Target = transformTargetToFindingsviewsTargetView(res.Target)
	}
	if res.Resources != nil {
		vres.Resources = make([]*findingsviews.ResourceGroupView, len(res.Resources))
		for i, val := range res.Resources {
			vres.Resources[i] = transformResourceGroupToFindingsviewsResourceGroupView(val)
		}
	}
	if res.Issue != nil {
		vres.Issue = newIssueView(res.Issue)
	}
	if res.Source != nil {
		vres.Source = newSourcewithnotargetView(res.Source)
	}
	return vres
}

// newIssue converts projected type Issue to service type Issue.
func newIssue(vres *findingsviews.IssueView) *Issue {
	res := &Issue{
		ID:          vres.ID,
		Summary:     vres.Summary,
		CweID:       vres.CweID,
		Description: vres.Description,
	}
	if vres.Recommendations != nil {
		res.Recommendations = make([]string, len(vres.Recommendations))
		for i, val := range vres.Recommendations {
			res.Recommendations[i] = val
		}
	}
	if vres.ReferenceLinks != nil {
		res.ReferenceLinks = make([]string, len(vres.ReferenceLinks))
		for i, val := range vres.ReferenceLinks {
			res.ReferenceLinks[i] = val
		}
	}
	return res
}

// newIssueView projects result type Issue to projected type IssueView using
// the "default" view.
func newIssueView(res *Issue) *findingsviews.IssueView {
	vres := &findingsviews.IssueView{
		ID:          res.ID,
		Summary:     res.Summary,
		CweID:       res.CweID,
		Description: res.Description,
	}
	if res.Recommendations != nil {
		vres.Recommendations = make([]string, len(res.Recommendations))
		for i, val := range res.Recommendations {
			vres.Recommendations[i] = val
		}
	}
	if res.ReferenceLinks != nil {
		vres.ReferenceLinks = make([]string, len(res.ReferenceLinks))
		for i, val := range res.ReferenceLinks {
			vres.ReferenceLinks[i] = val
		}
	}
	return vres
}

// newTarget converts projected type Target to service type Target.
func newTarget(vres *findingsviews.TargetView) *Target {
	res := &Target{
		ID:         vres.ID,
		Identifier: vres.Identifier,
	}
	if vres.Tags != nil {
		res.Tags = make([]string, len(vres.Tags))
		for i, val := range vres.Tags {
			res.Tags[i] = val
		}
	}
	return res
}

// newTargetView projects result type Target to projected type TargetView using
// the "default" view.
func newTargetView(res *Target) *findingsviews.TargetView {
	vres := &findingsviews.TargetView{
		ID:         res.ID,
		Identifier: res.Identifier,
	}
	if res.Tags != nil {
		vres.Tags = make([]string, len(res.Tags))
		for i, val := range res.Tags {
			vres.Tags[i] = val
		}
	}
	return vres
}

// newSourcewithnotarget converts projected type Sourcewithnotarget to service
// type Sourcewithnotarget.
func newSourcewithnotarget(vres *findingsviews.SourcewithnotargetView) *Sourcewithnotarget {
	res := &Sourcewithnotarget{
		ID:        vres.ID,
		Name:      vres.Name,
		Component: vres.Component,
		Instance:  vres.Instance,
		Options:   vres.Options,
		Time:      vres.Time,
	}
	return res
}

// newSourcewithnotargetView projects result type Sourcewithnotarget to
// projected type SourcewithnotargetView using the "default" view.
func newSourcewithnotargetView(res *Sourcewithnotarget) *findingsviews.SourcewithnotargetView {
	vres := &findingsviews.SourcewithnotargetView{
		ID:        res.ID,
		Name:      res.Name,
		Component: res.Component,
		Instance:  res.Instance,
		Options:   res.Options,
		Time:      res.Time,
	}
	return vres
}

// newResourceGroup converts projected type ResourceGroup to service type
// ResourceGroup.
func newResourceGroup(vres *findingsviews.ResourceGroupView) *ResourceGroup {
	res := &ResourceGroup{
		Name: vres.Name,
	}
	if vres.Attributes != nil {
		res.Attributes = make([]string, len(vres.Attributes))
		for i, val := range vres.Attributes {
			res.Attributes[i] = val
		}
	}
	if vres.Resources != nil {
		res.Resources = make([]map[string]string, len(vres.Resources))
		for i, val := range vres.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}
	return res
}

// newResourceGroupView projects result type ResourceGroup to projected type
// ResourceGroupView using the "default" view.
func newResourceGroupView(res *ResourceGroup) *findingsviews.ResourceGroupView {
	vres := &findingsviews.ResourceGroupView{
		Name: res.Name,
	}
	if res.Attributes != nil {
		vres.Attributes = make([]string, len(res.Attributes))
		for i, val := range res.Attributes {
			vres.Attributes[i] = val
		}
	}
	if res.Resources != nil {
		vres.Resources = make([]map[string]string, len(res.Resources))
		for i, val := range res.Resources {
			vres.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				vres.Resources[i][tk] = tv
			}
		}
	}
	return vres
}

// newEventCollection converts projected type EventCollection to service type
// EventCollection.
func newEventCollection(vres findingsviews.EventCollectionView) EventCollection {
	res := make(EventCollection, len(vres))
	for i, n := range vres {
		res[i] = newEvent(n)
	}
	return res
}

// newEventCollectionView projects result type EventCollection to projected
// type EventCollectionView using the "default" view.
func newEventCollectionView(res EventCollection) findingsviews.EventCollectionView {
	vres := make(findingsviews.EventCollectionView, len(res))
	for i, n := range res {
		vres[i] = newEventView(n)
	}
	return vres
}

// newEvent converts projected type Event to service type Event.
func newEvent(vres *findingsviews.EventView) *Event {
	res := &Event{
		ID:        vres.ID,
		FindingID: vres.FindingID,
		SourceID:  vres.SourceID,
		Score:     vres.Score,
		Time:      vres.Time,
	}
	return res
}

// newEventView projects result type Event to projected type EventView using
// the "default" view.
func newEventView(res *Event) *findingsviews.EventView {
	vres := &findingsviews.EventView{
		ID:        res.ID,
		FindingID: res.FindingID,
		SourceID:  res.SourceID,
		Score:     res.Score,
		Time:      res.Time,
	}
	return vres
}

// newMttr converts projected type Mttr to service type Mttr.
func newMttr(vres *findingsviews.MttrView) *Mttr {
	res := &Mttr{
		Mttr: vres.Mttr,
	}
	return res
}

// newMttrView projects result type Mttr to projected type MttrView using the
// "default" view.
func newMttrView(res *Mttr) *findingsviews.MttrView {
	vres := &findingsviews.MttrView{
		Mttr: res.Mttr,
	}
	return vres
}

// transformFindingsviewsTargetViewToTarget builds a value of type *Target from
// a value of type *findingsviews.TargetView.
func transformFindingsviewsTargetViewToTarget(v *findingsviews.TargetView) *Target {
	if v == nil {
		return nil
	}
	res := &Target{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// transformFindingsviewsResourceGroupViewToResourceGroup builds a value of
// type *ResourceGroup from a value of type *findingsviews.ResourceGroupView.
func transformFindingsviewsResourceGroupViewToResourceGroup(v *findingsviews.ResourceGroupView) *ResourceGroup {
	if v == nil {
		return nil
	}
	res := &ResourceGroup{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}

// transformTargetToFindingsviewsTargetView builds a value of type
// *findingsviews.TargetView from a value of type *Target.
func transformTargetToFindingsviewsTargetView(v *Target) *findingsviews.TargetView {
	if v == nil {
		return nil
	}
	res := &findingsviews.TargetView{
		ID:         v.ID,
		Identifier: v.Identifier,
	}
	if v.Tags != nil {
		res.Tags = make([]string, len(v.Tags))
		for i, val := range v.Tags {
			res.Tags[i] = val
		}
	}

	return res
}

// transformResourceGroupToFindingsviewsResourceGroupView builds a value of
// type *findingsviews.ResourceGroupView from a value of type *ResourceGroup.
func transformResourceGroupToFindingsviewsResourceGroupView(v *ResourceGroup) *findingsviews.ResourceGroupView {
	if v == nil {
		return nil
	}
	res := &findingsviews.ResourceGroupView{
		Name: v.Name,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Resources != nil {
		res.Resources = make([]map[string]string, len(v.Resources))
		for i, val := range v.Resources {
			res.Resources[i] = make(map[string]string, len(val))
			for key, val := range val {
				tk := key
				tv := val
				res.Resources[i][tk] = tv
			}
		}
	}

	return res
}
