/*
Copyright 2020 Adevinta
*/

package design

import (
	. "goa.design/goa/v3/dsl"
)

var FindingResourceGroup = ResultType("resource_group", func() {
	Attributes(func() {
		Attribute("name", String, "Name of the resource group", func() {
			Example("Network Resources")
		})
		Attribute("attributes", ArrayOf(String), "Column names of the resource group in the order that should be rendered", func() {
			Example([]string{"Hostname", "Port", "Protocol", "Service"})
		})
		Attribute("resources", ArrayOf(FindingResource), "List containing the resource rows as hashmap", func() {
			Example([]map[string]string{
				map[string]string{
					"Hostname": "adevinta.com",
					"Port":     "443",
					"Protocol": "tcp",
					"Service":  "www",
				},
			})
		})
	})
})

var FindingResource = MapOf(String, String)

var FindingResult = ResultType("finding", func() {
	Attributes(func() {
		Attribute("id", String, "Finding ID", func() {
			Example("97db1956-b15c-4b50-ae06-fd1e7be57963")
		})
		Attribute("issue", IssueResult, "Issue")
		Attribute("target", TargetResult, "Target")
		Attribute("source", SourceResultNoTarget, "Source")
		Attribute("details", String, "Finding details", func() {
			Example("TLSv1 is enabled and the server supports at least one cipher")
		})
		Attribute("impact_details", String, "Finding impact details", func() {
			Example("The remote service encrypts traffic using an older version of TLS.")
		})
		Attribute("status", String, "Finding status. Can be 'OPEN' or 'FIXED'.", func() {
			Example("OPEN")
		})
		Attribute("score", Float32, "Finding severity score", func() {
			Example(7.0)
		})
		Attribute("resources", ArrayOf(FindingResourceGroup), "Other resources associated with the finding")
	})
})

var _ = Service("findings", func() {
	Description("Findings endpoint.")

	Method("List findings", func() {
		Description("This method allows to list findings by using different filters.\n" +
			"When querying for open findings in a specific time range, it returns every finding that " +
			"has been found in that time, regardless if that finding has also been fixed in that span of time.\n" +
			"When querying for fixed findings in a specific time range, it returns every finding that " +
			"has been fixed in that time and it's fixed at the end of that time range, so a " +
			"finding that is fixed and then reopened in that range of time will not be returned.")

		Payload(func() {
			Field(1, "team", String, "Targets team filter")
			Field(2, "tag", String, "Targets tag filter")
			Field(3, "status", String, "Finding status filter. Can be 'OPEN' or 'FIXED'.")
			Field(4, "minScore", Int, "Minimum issues score filter")
			Field(5, "maxScore", Int, "Maximum issues score filter")
			Field(6, "atDate", String, "Allows to get a list of findings for a specific date (YYY-MM-DD). This filter has preference over minDate and maxDate.")
			Field(7, "minDate", String, "Minimum date filter (YYY-MM-DD). This filter only applies when used in conjunction with status filter.")
			Field(8, "maxDate", String, "Maximum date filter (YYY-MM-DD). This filter only applies when used in conjunction with status filter.")
			Field(9, "sortBy", String, "Sorting criteria. Supported fields: score, -score (for descending order)")
			Field(10, "page", Int, "Number of page requested")
			Field(11, "size", Int, "Number of results per page")
			Field(12, "identifier", String, "Findings identifier filter")
			Field(13, "identifiermatch", Boolean, "Exact match in identifier filter")
			Field(14, "identifiers", String, "A list of asset identifiers")
			Field(15, "labels", String, "List of issue labels to filter by")
		})

		Result(CollectionOf(FindingResult))

		HTTP(func() {
			GET("/findings")

			Param("team")
			Param("tag")
			Param("status")
			Param("minScore")
			Param("maxScore")
			Param("atDate")
			Param("minDate")
			Param("maxDate")
			Param("sortBy")
			Param("page")
			Param("size")
			Param("identifier")
			Param("identifiermatch")
			Param("identifiers")
			Param("labels")

			Response(StatusOK)
		})
	})

	Method("Get finding", func() {
		Payload(func() {
			Field(1, "id", String, "Finding ID")
		})

		Result(FindingResult)

		HTTP(func() {
			GET("/findings/{id}")

			Response(StatusOK)
		})
	})

	Method("List events by finding", func() {
		Payload(func() {
			Field(1, "id", String, "Finding ID")
			Field(3, "page", Int, "Number of page requested")
			Field(4, "size", Int, "Number of results per page")
		})

		Result(CollectionOf(FindingEventResult))

		HTTP(func() {
			GET("/findings/{id}/events")

			Param("page")
			Param("size")

			Response(StatusOK)
		})
	})

	Method("Get finding MTTR", func() {
		Payload(func() {
			Field(1, "id", String, "Finding ID")
		})

		Result(MTTRResult)

		HTTP(func() {
			GET("/findings/{id}/mttr")

			Response(StatusOK)
		})
	})

	Method("Patch finding", func() {
		Security(TeamAuth)
		Payload(func() {
			APIKey("authorization", "authorization")
			Field(1, "id", String, "Finding ID")
			Field(2, "status", String, "Status",
				func() {
					Example("OPEN")
				})
		})

		Result(FindingResult)

		HTTP(func() {
			PATCH("/findings/{id}")
			Response(StatusOK)
		})
	})
})
var TeamAuth = APIKeySecurity("authorization", func() {
	Description("Value must be 'TEAM team=myteam'")
})
