/*
Copyright 2021 Adevinta
*/

package api

import (
	"errors"
	"net/http"
	"regexp"
	"strconv"

	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/labstack/echo"
)

// API holds the storage interface and related methods.
type API struct {
	storage storage.Storage
	Options Options
}

// Options holds the configurations options for the API.
type Options struct {
	MaxSize     int
	DefaultSize int
}

// Pagination holds response pagination information.
type Pagination struct {
	Limit  int  `json:"limit"`
	Offset int  `json:"offset"`
	Total  int  `json:"total"`
	More   bool `json:"more"`
}

var (
	// Regular expression matching date format 'yyyy-mm-dd'.
	dateFmtRegEx = `^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])$`

	// ErrDateMalformed indicates that the date format does not comply with YYYY-MM-DD.
	ErrDateMalformed = errors.New("Malformed Date")

	// ErrPageMalformed indicates that the page requested is not an integer larger than 0.
	ErrPageMalformed = errors.New("Malformed Page Number")

	// ErrPageNotFound indicates that the page requested does not exist.
	ErrPageNotFound = errors.New("Page Not Found")

	// ErrSizeMalformed indicates that the size requested is not an integer larger than 0.
	ErrSizeMalformed = errors.New("Malformed Size Number")

	// ErrSizeTooLarge indicates that the size requested is larger than the maximum allowed.
	ErrSizeTooLarge = errors.New("Size Number Too Large")

	// ErrInvalidFilter indicates that there is a conflict between specified params for the filter.
	ErrInvalidFilter = errors.New("Filter parameters combination is invalid")
)

// New instantiates a new API.
func New(s storage.Storage, options Options) *API {
	return &API{storage: s, Options: options}
}

func response(c echo.Context, data interface{}, dataType string, p ...storage.Pagination) error {
	if data == nil {
		return c.NoContent(http.StatusNoContent)
	}

	resp := map[string]interface{}{}

	// We check if the variadic argument is present.
	if len(p) > 0 {
		// We only use the first element, as we expect only one.
		more := p[0].Total > p[0].Offset+p[0].Limit

		pagination := Pagination{
			Limit:  p[0].Limit,
			Offset: p[0].Offset,
			Total:  p[0].Total,
			More:   more,
		}

		if p[0].Offset > p[0].Total {
			return echo.NewHTTPError(http.StatusNotFound, ErrPageNotFound.Error())
		}

		resp["pagination"] = pagination
	}

	resp[dataType] = data

	return c.JSON(http.StatusOK, resp)
}

func (api *API) parsePagination(pageStr, sizeStr string) (int, int, error) {
	var pageNum, sizeNum int

	if pageStr == "" {
		pageStr = "1"
	}

	pageNum, err := strconv.Atoi(pageStr)
	if err != nil {
		return 0, 0, ErrPageMalformed
	}

	if pageNum < 1 {
		return 0, 0, ErrPageMalformed
	}

	if sizeStr != "" {
		sizeNum, err = strconv.Atoi(sizeStr)
		if err != nil {
			return 0, 0, ErrSizeMalformed
		}

		if sizeNum < 1 {
			return 0, 0, ErrSizeMalformed
		}

		if sizeNum > api.Options.MaxSize {
			return 0, 0, ErrSizeTooLarge
		}
	} else {
		sizeNum = api.Options.DefaultSize
	}

	return pageNum, sizeNum, nil
}

func (api *API) parseFilter(c echo.Context) (storage.Filter, error) {
	filter := storage.Filter{}

	page, size, err := api.parsePagination(c.QueryParam("page"), c.QueryParam("size"))
	if err != nil {
		return storage.Filter{}, err
	}
	filter.Page = page
	filter.Size = size

	filter.Status = c.QueryParam("status")
	filter.Tag = c.QueryParam("tag")
	filter.Identifier = c.QueryParam("identifier")

	if c.QueryParam("identifiermatch") != "" {
		match, err := strconv.ParseBool(c.QueryParam("identifiermatch"))
		if err != nil {
			return storage.Filter{}, err
		}
		filter.IdentifierMatch = match
	}

	if c.QueryParam("minScore") != "" {
		minScore, err := strconv.ParseFloat(c.QueryParam("minScore"), 32)
		if err != nil {
			return storage.Filter{}, err
		}
		filter.MinScore = float32(minScore)
	}

	if c.QueryParam("maxScore") != "" {
		maxScore, err := strconv.ParseFloat(c.QueryParam("maxScore"), 32)
		if err != nil {
			return storage.Filter{}, err
		}
		filter.MaxScore = float32(maxScore)
	}

	filter.MinDate = c.QueryParam("minDate")
	filter.MaxDate = c.QueryParam("maxDate")
	filter.AtDate = c.QueryParam("atDate")
	if !isValidDate(filter.MinDate) || !isValidDate(filter.MaxDate) ||
		!isValidDate(filter.AtDate) {
		return storage.Filter{}, ErrDateMalformed
	}

	filter.SortBy = parseSortFilter(c.QueryParam("sortBy"))

	// Validate filter params compatibility.
	if filter.AtDate != "" && (filter.MinDate != "" || filter.MaxDate != "") ||
		!isValidFilterForEndpoint(filter, c.Path()) {
		return storage.Filter{}, ErrInvalidFilter
	}

	return filter, nil
}

func parseSortFilter(sortParam string) storage.SortBy {
	if sortParam == "" {
		return storage.SortBy{}
	}

	order := string(sortParam[0])
	if order == "-" {
		order = "desc"
	} else {
		// Default
		order = "asc"
	}

	var field string
	if order == "desc" {
		field = sortParam[1:]
	} else {
		field = sortParam
	}

	return storage.SortBy{
		Field: field,
		Order: order,
	}
}

func isValidFilterForEndpoint(filter storage.Filter, endpoint string) bool {
	switch endpoint {
	case "/findings":
		return (filter.Status != "" || (filter.MinDate == "" && filter.MaxDate == "")) &&
			(filter.SortBy.Field == "" || filter.SortBy.Field == "score")
	case "/issues/summary":
		return filter.SortBy.Field == "" ||
			filter.SortBy.Field == "max_score" ||
			filter.SortBy.Field == "targets_count"
	case "/targets/summary":
		return filter.SortBy.Field == "" ||
			filter.SortBy.Field == "max_score" ||
			filter.SortBy.Field == "findings_count"
	default:
		// TODO: This function is not perfect as many possible
		// combinations which might not apply to each endpoint
		// can possibly be parsed as valid, but with current impl
		// at least we return a bad request response for some combinations
		// that might be thought as valid by users.
		// E.g.: setting minDate param for /findings without setting status.
		//
		// If we want to enforce only the valid combinations for each
		// endpoint we would need to use some regexp for endpoint matching
		// and "rules" for valid combinations for each endpoint.
		return true
	}
}

func isValidDate(date string) bool {
	if date == "" {
		return true
	}
	return regexp.MustCompile(dateFmtRegEx).MatchString(date)
}

// Healthcheck performs a simple query and returns an OK response.
func (api *API) Healthcheck(c echo.Context) error {
	_, _, err := api.storage.ListIssues(storage.Filter{Page: 1, Size: 1})
	if err != nil {
		return err
	}

	return c.JSON(http.StatusOK, nil)
}
