/*
Copyright 2021 Adevinta
*/

package api

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/adevinta/vulnerability-db-api/pkg/api/test"
	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/labstack/echo"
	"github.com/stretchr/testify/assert"
)

type issuesDB test.MockDB

func (db issuesDB) ListIssues(filter storage.Filter) ([]model.Issue, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	if filter.Size < len(test.Issues) {
		return test.Issues[0:filter.Size], storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(test.Issues)}, nil
	}

	return test.Issues, storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(test.Issues)}, nil
}

func (db issuesDB) GetIssue(id string) (model.Issue, error) {
	for _, issue := range test.Issues {
		if issue.ID == id {
			return issue, nil
		}
	}

	return model.Issue{}, nil
}

func (db issuesDB) GetIssueMTTR(id string) (float32, error) {
	var ttrSum, count float32 = 0, 0

	for _, finding := range test.Findings {
		if finding.IssueID == id {
			for _, exposure := range test.FindingExposures {
				if exposure.FindingID == finding.ID {
					ttrSum += exposure.TTR
					count++
				}
			}
		}
	}

	if ttrSum == 0 {
		return 0, nil
	}

	return ttrSum / count, nil
}

func TestGetIssue(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetIssue",
			RequestURI: "/issues/" + test.Issues[0].ID,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issue model.Issue
				test.JSONObject(tc, rec, "issue", &issue)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Issues[0], issue)
			},
		},
		test.Case{
			Name:       "GetIssueNotFound",
			RequestURI: "/issues/" + test.NonExistingID,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issue model.Issue
				test.JSONObject(tc, rec, "issue", &issue)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, model.Issue{}, issue)
			},
		},
	}

	e := echo.New()
	a := New(issuesDB{}, test.Options)
	e.GET("/issues/:id", a.GetIssue)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestListIssues(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "ListIssues",
			RequestURI: "/issues",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Issues, issues)
			},
		},
		test.Case{
			Name:       "ListIssuesWithPagination",
			RequestURI: "/issues?page=1",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Issues, issues)
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, test.DefaultSize, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListIssuesWithPaginationZero",
			RequestURI: "/issues?page=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(issues))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListIssuesWithPaginationOverflown",
			RequestURI: "/issues?page=100",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, 0, len(issues))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListIssuesWithPaginationMalformed",
			RequestURI: "/issues?page=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(issues))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListIssuesWithSize",
			RequestURI: "/issues?page=1&size=2",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Issues[0:2], issues)
				assert.Equal(tc, true, pagination.More)
				assert.Equal(tc, 2, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListIssuesWithSizeZero",
			RequestURI: "/issues?page=1&size=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(issues))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListIssuesWithSizeOverflown",
			RequestURI: "/issues?page=1&size=1000",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(issues))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListIssuesWithSizeMalformed",
			RequestURI: "/issues?page=1&size=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var issues []model.Issue
				test.JSONObject(tc, rec, "issues", &issues)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(issues))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
	}

	e := echo.New()
	a := New(issuesDB{}, test.Options)
	e.GET("/issues", a.ListIssues)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestGetIssueMTTR(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetIssueMTTROfFixed",
			RequestURI: "/issues/" + test.Issues[0].ID + "/mttr",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var mttr float32
				test.JSONObject(tc, rec, "mttr", &mttr)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, float32(5), mttr)
			},
		},
		test.Case{
			Name:       "GetIssueMTTROfOpen",
			RequestURI: "/issues/" + test.Issues[1].ID + "/mttr",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var mttr float32
				test.JSONObject(tc, rec, "mttr", &mttr)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, float32(0), mttr)
			},
		},
	}

	e := echo.New()
	a := New(issuesDB{}, test.Options)
	e.GET("/issues/:id/mttr", a.GetIssueMTTR)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}
