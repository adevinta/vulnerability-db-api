/*
Copyright 2020 Adevinta
*/

package api

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/adevinta/vulnerability-db-api/pkg/api/test"
	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/labstack/echo"
	"github.com/stretchr/testify/assert"
)

type targetsDB test.MockDB

func (db targetsDB) ListTargets(filter storage.Filter) ([]model.Target, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	targets := []model.Target{}

	if filter.Tag == "" && filter.Identifier == "" {
		targets = test.Targets
	} else {
		for _, t := range test.Targets {
			matchesTag := false
			for _, ttag := range t.Tags {
				if filter.Tag == "" || ttag == filter.Tag {
					matchesTag = true
					break
				}
			}

			matchesIdentifier := filter.Identifier == "" ||
				strings.Contains(t.Identifier, filter.Identifier)

			if matchesTag && matchesIdentifier {
				targets = append(targets, t)
			}
		}
	}

	return targets, storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(targets)}, nil
}

func (db targetsDB) GetTarget(id string) (model.Target, error) {
	for _, target := range test.Targets {
		if target.ID == id {
			return target, nil
		}
	}

	return model.Target{}, nil
}

func (db targetsDB) GetTargetMTTR(id string) (float32, error) {
	var ttrSum, count float32 = 0, 0

	for _, finding := range test.Findings {
		if finding.TargetID == id {
			for _, exposure := range test.FindingExposures {
				if exposure.FindingID == finding.ID {
					ttrSum += exposure.TTR
					count++
				}
			}
		}
	}

	if ttrSum == 0 {
		return 0, nil
	}

	return ttrSum / count, nil
}

func (db targetsDB) CreateTarget(target model.Target) (model.Target, error) {
	target.ID = test.NonExistingID
	return target, nil
}

func TestGetTarget(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetTarget",
			RequestURI: "/targets/" + test.Targets[0].ID,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var target model.Target
				test.JSONObject(tc, rec, "target", &target)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Targets[0], target)
			},
		},
		test.Case{
			Name:       "GetTargetNotFound",
			RequestURI: "/targets/" + test.NonExistingID,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var target model.Target
				test.JSONObject(tc, rec, "target", &target)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, model.Target{}, target)
			},
		},
	}

	e := echo.New()
	a := New(targetsDB{}, test.Options)
	e.GET("/targets/:id", a.GetTarget)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestListTargets(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "ListTargets",
			RequestURI: "/targets",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Targets, targets)
			},
		},
		test.Case{
			Name:       "ListTargetsWithPagination",
			RequestURI: "/targets?page=1",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Targets, targets)
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, test.DefaultSize, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListTargetsWithPaginationZero",
			RequestURI: "/targets?page=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(targets))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListTargetsWithPaginationOverflown",
			RequestURI: "/targets?page=100",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, 0, len(targets))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListTargetsWithPaginationMalformed",
			RequestURI: "/targets?page=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(targets))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListTargetsWithTagFilter",
			RequestURI: "/targets?tag=sdrn:adevinta:team:security",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Targets, targets)
			},
		},
		test.Case{
			Name:       "ListTargetsWithNonExistentTagFilter",
			RequestURI: "/targets?tag=thistagdoesnotexist",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, []model.Target{}, targets)
			},
		},
		test.Case{
			Name:       "ListTargetsWithIdentifierFilter",
			RequestURI: "/targets?identifier=strongbox",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, []model.Target{test.Targets[2]}, targets)
			},
		},
		test.Case{
			Name:       "ListTargetsWithNonExistentIdentifierFilter",
			RequestURI: "/targets?identifier=thisidentifierdoesnotexist",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var targets []model.Target
				test.JSONObject(tc, rec, "targets", &targets)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, []model.Target{}, targets)
			},
		},
	}

	e := echo.New()
	a := New(targetsDB{}, test.Options)
	e.GET("/targets", a.ListTargets)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestGetTargetMTTR(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetTargetMTTROfFixed",
			RequestURI: "/targets/" + test.Targets[0].ID + "/mttr",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var mttr float32
				test.JSONObject(tc, rec, "mttr", &mttr)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, float32(3.5), mttr)
			},
		},
		test.Case{
			Name:       "GetTargetMTTROfOpen",
			RequestURI: "/targets/" + test.Targets[1].ID + "/mttr",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var mttr float32
				test.JSONObject(tc, rec, "mttr", &mttr)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, float32(0), mttr)
			},
		},
	}

	e := echo.New()
	a := New(targetsDB{}, test.Options)
	e.GET("/targets/:id/mttr", a.GetTargetMTTR)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestCreateTarget(t *testing.T) {
	newTarget := model.Target{
		Identifier: "example.com",
		Tags:       []string{"mytag"},
	}

	tcs := []test.Case{
		{
			Name:       "CreateTarget",
			RequestURI: "/targets",
			RequestBody: test.RequestBody{
				Payload:     newTarget,
				ContentType: "application/json",
			},
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var target model.Target
				test.JSONObject(tc, rec, "target", &target)

				wantTarget := newTarget
				wantTarget.ID = test.NonExistingID

				assert.Equal(tc, http.StatusCreated, rec.Code)
				assert.Equal(tc, wantTarget, target)
			},
		},
		{
			Name:       "CreateTargetUnprocessableEntity",
			RequestURI: "/targets",
			RequestBody: test.RequestBody{
				Payload:     model.Target{},
				ContentType: "application/json",
			},
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var target model.Target
				test.JSONObject(tc, rec, "target", &target)

				assert.Equal(tc, http.StatusUnprocessableEntity, rec.Code)
				assert.Equal(tc, model.Target{}, target)
			},
		},
		{
			Name:        "CreateTargetBadRequest",
			RequestURI:  "/targets",
			RequestBody: test.RequestBody{},
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var target model.Target
				test.JSONObject(tc, rec, "target", &target)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, model.Target{}, target)
			},
		},
	}

	e := echo.New()
	a := New(targetsDB{}, test.Options)
	e.POST("/targets", a.CreateTarget)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			jsonPayload, err := json.Marshal(tc.RequestBody.Payload)
			if err != nil {
				t.Fatalf("error marshaling test payload: %v", err)
			}

			req := httptest.NewRequest(http.MethodPost, tc.RequestURI, bytes.NewReader(jsonPayload))
			req.Header.Add("Content-Type", tc.RequestBody.ContentType)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}
