/*
Copyright 2021 Adevinta
*/

package middleware

import (
	"errors"
	"net/http"
	"net/url"
	"testing"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	echo "github.com/labstack/echo/v4"
)

var (
	errMockStorage = errors.New("error")
)

// MockAuthorizer is a mock implementation of
// the Authorizer interface which returns the
// inner err when calling its Authorize method.
type mockAuthorizer struct {
	err error
}

func (a *mockAuthorizer) Authorize(r *http.Request) error {
	return a.err
}

type mockResponseWriter struct {
	http.ResponseWriter
	status int
}

func (m *mockResponseWriter) WriteHeader(code int) {
	m.status = code
}

func TestAuthorization(t *testing.T) {
	testCases := []struct {
		name       string
		auth       Authorizer
		wantStatus int
		wantErr    error
	}{
		{
			name:       "Happy path",
			auth:       &mockAuthorizer{nil},
			wantStatus: http.StatusOK,
			wantErr:    nil,
		},
		{
			name:       "Should return 404 Not Found",
			auth:       &mockAuthorizer{errNotFound},
			wantStatus: http.StatusNotFound,
			wantErr:    errNotFound,
		},
		{
			name:       "Should return 401 Unauthorized",
			auth:       &mockAuthorizer{errUnauthorized},
			wantStatus: http.StatusUnauthorized,
			wantErr:    errUnauthorized,
		},
		{
			name:       "Should return 403 Forbidden",
			auth:       &mockAuthorizer{errForbidden},
			wantStatus: http.StatusForbidden,
			wantErr:    errForbidden,
		},
	}

	mockHandlerFunc := func(c echo.Context) (err error) {
		c.Response().WriteHeader(http.StatusOK)
		return nil
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mockRW := &mockResponseWriter{}
			err := Authorization(tc.auth)(mockHandlerFunc)(
				echo.New().NewContext(nil, mockRW),
			)
			if !errors.Is(err, tc.wantErr) {
				t.Fatalf("expected err to be %v, but got %v instead",
					tc.wantErr, err)
			}
			if mockRW.status != tc.wantStatus {
				t.Fatalf("expected response status to be %d, but got %d instead",
					tc.wantStatus, mockRW.status)
			}
		})
	}

}

type mockStorage struct {
	storage.Storage
	findings    map[string]model.FindingExpanded
	findingsErr bool
	targets     map[string]model.Target
	targetsErr  bool
}

func (m *mockStorage) GetFinding(id string) (model.FindingExpanded, error) {
	if m.findingsErr {
		return model.FindingExpanded{}, errMockStorage
	}
	if f, ok := m.findings[id]; ok {
		return f, nil
	}
	return model.FindingExpanded{}, nil // Not found
}

func (m *mockStorage) GetTarget(id string) (model.Target, error) {
	if m.targetsErr {
		return model.Target{}, errMockStorage
	}
	if t, ok := m.targets[id]; ok {
		return t, nil
	}
	return model.Target{}, nil // Not found
}

type mockLogger struct {
	echo.Logger
}

func (l *mockLogger) Errorf(format string, args ...interface{}) {
	// Do nothing logger
}

func TestTagAuthorizer_Authorize(t *testing.T) {
	mockStorage := &mockStorage{
		findings: map[string]model.FindingExpanded{
			"f1": {
				Finding: model.Finding{ID: "f1"},
				Target:  model.Target{Tags: []string{"tagf1"}},
			},
		},
		targets: map[string]model.Target{
			"t1": {
				ID:   "t1",
				Tags: []string{"tagt1"},
			},
		},
	}

	mockLogger := &mockLogger{}

	testCases := []struct {
		name        string
		req         *http.Request
		findingsErr bool
		targetsErr  bool
		wantErr     error
	}{
		{
			name: "Authorization not required for GET",
			req: &http.Request{
				Method: http.MethodGet,
				URL:    &url.URL{Path: "/findings/f1"},
			},
			wantErr: nil,
		},
		{
			name: "Authorization not required for POST",
			req: &http.Request{
				Method: http.MethodPost,
				URL:    &url.URL{Path: "/findings"},
			},
			wantErr: nil,
		},
		{
			name: "Authorized for findings",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=tagf1"},
				},
				URL: &url.URL{Path: "/findings/f1"},
			},
			wantErr: nil,
		},
		{
			name: "Authorized for targets",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=tagt1"},
				},
				URL: &url.URL{Path: "/targets/t1"},
			},
			wantErr: nil,
		},
		{
			name: "Authorized for tags",
			req: &http.Request{
				Method: http.MethodDelete,
				Header: http.Header{
					"Authorization": []string{"TAG tag=tagt1"},
				},
				URL: &url.URL{Path: "/targets/tags/tagt1"},
			},
			wantErr: nil,
		},
		{
			name: "Unauthorized, header doest not match schema",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"giberish"},
				},
				URL: &url.URL{Path: "/findings/f1"},
			},
			wantErr: errUnauthorized,
		},
		{
			name: "Not Found, finding not found",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=giberish"},
				},
				URL: &url.URL{Path: "/findings/giberish"},
			},
			wantErr: errNotFound,
		},
		{
			name: "Not Found, target not found",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=giberish"},
				},
				URL: &url.URL{Path: "/targets/giberish"},
			},
			wantErr: errNotFound,
		},
		{
			name: "Forbidden, tag not found for finding",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=giberish"},
				},
				URL: &url.URL{Path: "/findings/f1"},
			},
			wantErr: errForbidden,
		},
		{
			name: "Forbidden, tag not found for target",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=giberish"},
				},
				URL: &url.URL{Path: "/targets/t1"},
			},
			wantErr: errForbidden,
		},
		{
			name: "Internal error for findings",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=tagf1"},
				},
				URL: &url.URL{Path: "/findings/f1"},
			},
			findingsErr: true,
			wantErr:     errMockStorage,
		},
		{
			name: "Internal error for targets",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=tagt1"},
				},
				URL: &url.URL{Path: "/targets/t1"},
			},
			targetsErr: true,
			wantErr:    errMockStorage,
		},
		{
			name: "Forbidden, auth tag not matched for request tag",
			req: &http.Request{
				Method: http.MethodPut,
				Header: http.Header{
					"Authorization": []string{"TAG tag=giberish"},
				},
				URL: &url.URL{Path: "/targets/tags/t1"},
			},
			wantErr: errForbidden,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Set mock flags for err behavior
			mockStorage.findingsErr = tc.findingsErr
			mockStorage.targetsErr = tc.targetsErr

			auth := NewTagAuthorizer(mockStorage, mockLogger)

			err := auth.Authorize(tc.req)
			if !errors.Is(err, tc.wantErr) {
				t.Fatalf("expected err to be %v, but got %v", tc.wantErr, err)
			}
		})
	}
}
