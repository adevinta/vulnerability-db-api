package middleware

import (
	"errors"
	"net/http"
	"strings"

	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	echo "github.com/labstack/echo"
)

const (
	findingsOpPrefix = "/findings/"
	targetsOpPrefix  = "/targets/"

	tagAuthSchemaPrefix = "TAG tag="
)

var (
	errUnauthorized = errors.New("unauthorized")
	errForbidden    = errors.New("forbidden")
	errNotFound     = errors.New("resource not found")
)

// Authorization returns a new authorization middleware func
// by using the input authorizer.
func Authorization(auth Authorizer) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) (err error) {
			err = auth.Authorize(c.Request())
			if err != nil {
				c.Response().WriteHeader(errToStatus(err))
				return
			}
			return next(c)
		}
	}
}

// Authorizer represents an authorization
// mechanism applied to an HTTP request.
type Authorizer interface {
	Authorize(r *http.Request) error
}

// TagAuthorizer performs authorization based
// on the TAG scheme for the authorization header.
type TagAuthorizer struct {
	db  storage.Storage
	log echo.Logger
}

// NewTagAuthorizer builds a new tag based authorizer.
// This type of authorizer matches the tag passed in through
// the authorization header against the tag associated with the
// resource that the request tries to modify.
func NewTagAuthorizer(db storage.Storage, log echo.Logger) *TagAuthorizer {
	return &TagAuthorizer{
		db,
		log,
	}
}

// Authorize authorizes HTTP request by verifying resource ownership.
// It does so by retrieving the tag included in the http request's
// authorization header and comparing it with the tags associated
// with the resource that the request is trying to modify.
// If request tag is among the ones associated with the resource,
// then action is granted. Otherwise it is denied.
func (a *TagAuthorizer) Authorize(r *http.Request) error {
	if isReadMethod(r.Method) {
		// Read HTTP methods do not
		// require authorization
		return nil
	}

	authTag := parseAuthTag(r.Header)
	if authTag == "" {
		return errUnauthorized
	}

	// Only makes sense to authorize update of
	// Findings and Assets as these are the entities
	// that are related with a team
	if isFindingOp(r.URL.Path) {
		findingID := parseEntityID(r.URL.Path)
		return a.authorizeFindingOp(findingID, authTag)
	}
	if isTargetOp(r.URL.Path) {
		targetID := parseEntityID(r.URL.Path)
		return a.authorizeTargetOp(targetID, authTag)
	}

	// Deny by default
	return errUnauthorized
}

func (a *TagAuthorizer) authorizeFindingOp(findingID, tag string) error {
	f, err := a.db.GetFinding(findingID)
	if err != nil {
		a.log.Errorf("unexpected error authorizing finding op: %v", err)
		return err
	}

	if f.ID == "" {
		return errNotFound
	}

	if !contains(f.Target.Tags, tag) {
		return errForbidden
	}

	return nil
}

func (a *TagAuthorizer) authorizeTargetOp(targetID, tag string) error {
	t, err := a.db.GetTarget(targetID)
	if err != nil {
		a.log.Errorf("unexpected error authorizing target op: %v", err)
		return err
	}

	if t.ID == "" {
		return errNotFound
	}

	if !contains(t.Tags, tag) {
		return errForbidden
	}

	return nil
}

func isFindingOp(path string) bool {
	return strings.HasPrefix(path, findingsOpPrefix)
}

func isTargetOp(path string) bool {
	return strings.HasPrefix(path, targetsOpPrefix)
}

func parseAuthTag(headers http.Header) string {
	authH := headers.Get("authorization")
	if authH == "" {
		return ""
	}
	if !strings.HasPrefix(authH, tagAuthSchemaPrefix) {
		return ""
	}
	return strings.TrimPrefix(authH, tagAuthSchemaPrefix)
}

func parseEntityID(path string) string {
	if pathParts := strings.Split(path, "/"); len(pathParts) > 1 {
		return pathParts[2]
	}
	return ""
}

func errToStatus(err error) int {
	var status int

	if err == nil {
		status = http.StatusOK
	} else if errors.Is(err, errUnauthorized) {
		status = http.StatusUnauthorized
	} else if errors.Is(err, errForbidden) {
		status = http.StatusForbidden
	} else if errors.Is(err, errNotFound) {
		status = http.StatusNotFound
	} else {
		status = http.StatusInternalServerError
	}

	return status
}

func isReadMethod(method string) bool {
	return method == http.MethodGet ||
		method == http.MethodHead ||
		method == http.MethodOptions
}

func contains(slice []string, s string) bool {
	for _, ss := range slice {
		if ss == s {
			return true
		}
	}
	return false
}
