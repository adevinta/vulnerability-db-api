/*
Copyright 2021 Adevinta
*/

package middleware

import (
	"errors"
	"net/http"
	"strings"

	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	echo "github.com/labstack/echo/v4"
)

const (
	findingsOpPrefix = "/findings/"
	targetsOpPrefix  = "/targets/"
	teamOpPrefix     = "/targets/teams/"

	teamAuthSchemaPrefix = "TEAM team="
)

var (
	errUnauthorized = errors.New("unauthorized")
	errForbidden    = errors.New("forbidden")
	errNotFound     = errors.New("resource not found")
)

// Authorization returns a new authorization middleware func
// by using the input authorizer.
func Authorization(auth Authorizer) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) (err error) {
			err = auth.Authorize(c.Request())
			if err != nil {
				c.Response().WriteHeader(errToStatus(err))
				return
			}
			return next(c)
		}
	}
}

// Authorizer represents an authorization
// mechanism applied to an HTTP request.
type Authorizer interface {
	Authorize(r *http.Request) error
}

// TeamAuthorizer performs authorization based
// on the team identifier for the authorization header.
type TeamAuthorizer struct {
	db  storage.Storage
	log echo.Logger
}

// NewTeamAuthorizer builds a new team based authorizer.
// This type of authorizer matches the team passed in through
// the authorization header against the team associated with the
// resource that the request tries to modify.
func NewTeamAuthorizer(db storage.Storage, log echo.Logger) *TeamAuthorizer {
	return &TeamAuthorizer{
		db,
		log,
	}
}

// Authorize authorizes HTTP request by verifying resource ownership.
// It does so by retrieving the team included in the HTTP request
// authorization header and comparing it with the teams associated
// with the resource that the request is trying to modify.
// If the team is among the ones associated with the resource,
// then permission is granted. Otherwise it is denied.
func (a *TeamAuthorizer) Authorize(r *http.Request) error {
	if isReadMethod(r.Method) {
		// Read HTTP methods do not
		// require authorization
		return nil
	}

	entityID := parseEntityID(r.URL.Path)
	if r.Method == http.MethodPost && entityID == "" {
		// Authorize creation operations.
		// E.g.: POST /findings
		return nil
	}

	authTeam := parseAuthTeam(r.Header)
	if authTeam == "" {
		return errUnauthorized
	}

	// Only makes sense to authorize modifications of
	// Findings and Assets as these are the entities
	// that are related with a team
	if isFindingOp(r.URL.Path) {
		return a.authorizeFindingOp(entityID, authTeam)
	}
	if isTeamOp(r.URL.Path) {
		return a.authorizeTeamOp(r.URL.Path, authTeam)
	}
	if isTargetOp(r.URL.Path) {
		return a.authorizeTargetOp(entityID, authTeam)
	}

	// Deny by default
	return errUnauthorized
}

func (a *TeamAuthorizer) authorizeFindingOp(findingID, teamID string) error {
	f, err := a.db.GetFinding(findingID)
	if err != nil {
		a.log.Errorf("unexpected error authorizing finding op: %v", err)
		return err
	}

	if f.ID == "" {
		return errNotFound
	}

	if !contains(f.Target.Teams, teamID) {
		return errForbidden
	}

	return nil
}

func (a *TeamAuthorizer) authorizeTeamOp(path, authTeam string) error {
	reqTeam := strings.TrimPrefix(path, teamOpPrefix)
	if reqTeam != authTeam {
		return errForbidden
	}
	return nil
}

func (a *TeamAuthorizer) authorizeTargetOp(targetID, teamID string) error {
	t, err := a.db.GetTarget(targetID)
	if err != nil {
		a.log.Errorf("unexpected error authorizing target op: %v", err)
		return err
	}

	if t.ID == "" {
		return errNotFound
	}

	if !contains(t.Teams, teamID) {
		return errForbidden
	}

	return nil
}

func isFindingOp(path string) bool {
	return strings.HasPrefix(path, findingsOpPrefix)
}

func isTeamOp(path string) bool {
	return strings.HasPrefix(path, teamOpPrefix)
}

func isTargetOp(path string) bool {
	return strings.HasPrefix(path, targetsOpPrefix)
}

func parseAuthTeam(headers http.Header) string {
	authH := headers.Get("authorization")
	if authH == "" {
		return ""
	}
	if !strings.HasPrefix(authH, teamAuthSchemaPrefix) {
		return ""
	}
	return strings.TrimPrefix(authH, teamAuthSchemaPrefix)
}

func parseEntityID(path string) string {
	if pathParts := strings.Split(path, "/"); len(pathParts) > 2 {
		return pathParts[2]
	}
	return ""
}

func errToStatus(err error) int {
	var status int

	if err == nil {
		status = http.StatusOK
	} else if errors.Is(err, errUnauthorized) {
		status = http.StatusUnauthorized
	} else if errors.Is(err, errForbidden) {
		status = http.StatusForbidden
	} else if errors.Is(err, errNotFound) {
		status = http.StatusNotFound
	} else {
		status = http.StatusInternalServerError
	}

	return status
}

func isReadMethod(method string) bool {
	return method == http.MethodGet ||
		method == http.MethodHead ||
		method == http.MethodOptions
}

func contains(slice []string, s string) bool {
	for _, ss := range slice {
		if ss == s {
			return true
		}
	}
	return false
}
