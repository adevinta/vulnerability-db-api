/*
Copyright 2020 Adevinta
*/

package api

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/adevinta/vulnerability-db-api/pkg/api/test"
	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/labstack/echo"
	"github.com/stretchr/testify/assert"
)

type findingsDB test.MockDB

func (db findingsDB) ListFindings(filter storage.Filter) ([]model.FindingExpanded, storage.Pagination, error) {
	// Filter by status.
	findingsByStatus := []model.FindingExpanded{}
	for _, f := range test.Findings {
		if filter.Status == "" || filter.Status == f.Status {
			findingsByStatus = append(findingsByStatus, buildFindingExpanded(f))
		}
	}

	// Filter by  min score.
	findingsByMinScore := []model.FindingExpanded{}
	if filter.MinScore == 0 {
		findingsByMinScore = findingsByStatus
	} else {
		for _, f := range findingsByStatus {
			if f.Score >= filter.MinScore {
				findingsByMinScore = append(findingsByMinScore, f)
			}
		}
	}

	// Filter by  max score.
	findingsByMaxScore := []model.FindingExpanded{}
	if filter.MaxScore == 10 || filter.MaxScore == 0 {
		findingsByMaxScore = findingsByMinScore
	} else {
		for _, f := range findingsByMinScore {
			if f.Score <= filter.MaxScore {
				findingsByMaxScore = append(findingsByMaxScore, f)
			}
		}
	}

	// Filter by tag.
	findingsByTag := []model.FindingExpanded{}
	if filter.Tag == "" {
		findingsByTag = findingsByMaxScore
	} else {
		for _, f := range findingsByMaxScore {
			for _, t := range test.Targets {
				if f.Target.ID == t.ID {
					for _, ttag := range t.Tags {
						if ttag == filter.Tag {
							findingsByTag = append(findingsByTag, f)
						}
					}
				}
			}
		}
	}

	offset := storage.Offset(filter.Page, filter.Size)
	return findingsByTag, storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(findingsByTag)}, nil
}

func (db findingsDB) GetFinding(id string) (model.FindingExpanded, error) {
	for _, finding := range test.Findings {
		if finding.ID == id {
			return buildFindingExpanded(finding), nil
		}
	}

	return model.FindingExpanded{}, nil
}

func (db findingsDB) ListFindingsByTarget(id string, filter storage.Filter) ([]model.FindingExpanded, storage.Pagination, error) {
	var findings []model.FindingExpanded
	for _, f := range test.Findings {
		if f.TargetID == id {
			if filter.Status == "" || filter.Status == f.Status {
				findings = append(findings, buildFindingExpanded(f))
			}
		}
	}

	offset := storage.Offset(filter.Page, filter.Size)
	return findings, storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(findings)}, nil
}

func (db findingsDB) ListFindingsByIssue(id string, filter storage.Filter) ([]model.FindingExpanded, storage.Pagination, error) {
	var findings []model.FindingExpanded
	for _, f := range test.Findings {
		if f.IssueID == id {
			if filter.Status == "" || filter.Status == f.Status {
				findings = append(findings, buildFindingExpanded(f))
			}
		}
	}

	offset := storage.Offset(filter.Page, filter.Size)
	return findings, storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(findings)}, nil
}

func (db findingsDB) ListFindingsBySource(id string, filter storage.Filter) ([]model.FindingExpanded, storage.Pagination, error) {
	var findings []model.FindingExpanded
	for _, f := range test.Findings {
		if filter.Status == "" || filter.Status == f.Status {
			for _, fe := range test.FindingEvents {
				if fe.FindingID == f.ID && fe.SourceID == id {
					findings = append(findings, buildFindingExpanded(f))
				}
			}
		}
	}

	offset := storage.Offset(filter.Page, filter.Size)
	return findings, storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(findings)}, nil
}

func (db findingsDB) ListFindingEventsByFinding(id string, filter storage.Filter) ([]model.FindingEvent, storage.Pagination, error) {
	var events []model.FindingEvent
	for _, e := range test.FindingEvents {
		if e.FindingID == id {
			if filter.Status == "" {
				events = append(events, e)
			}
		}
	}

	offset := storage.Offset(filter.Page, filter.Size)
	return events, storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(events)}, nil
}

func (db findingsDB) GetFindingFromTargetIssueAndResource(targetID, affectedResource, issueID string) (model.FindingExpanded, error) {
	for _, f := range test.Findings {
		if f.TargetID == targetID && f.IssueID == issueID && f.AffectedResource == affectedResource {
			return buildFindingExpanded(f), nil
		}
	}
	return model.FindingExpanded{}, nil
}

func (db findingsDB) GetFindingMTTR(id string) (float32, error) {
	var ttrSum, count float32 = 0, 0

	for _, exposure := range test.FindingExposures {
		if exposure.FindingID == id {
			ttrSum += exposure.TTR
			count++
		}
	}

	if ttrSum == 0 {
		return 0, nil
	}

	return ttrSum / count, nil
}

func buildFindingExpandedList(ff []model.Finding) []model.FindingExpanded {
	findings := []model.FindingExpanded{}
	for _, f := range ff {
		findings = append(findings, buildFindingExpanded(f))
	}

	return findings
}

func buildFindingExpanded(f model.Finding) model.FindingExpanded {
	fe := model.FindingExpanded{
		Finding: model.Finding{
			ID:            f.ID,
			Details:       f.Details,
			Status:        f.Status,
			Score:         f.Score,
			Resources:     f.Resources,
			OpenFinding:   f.OpenFinding,
			TotalExposure: f.TotalExposure,
		},
	}

	for _, i := range test.Issues {
		if i.ID == f.IssueID {
			fe.Issue = i
			break
		}
	}

	for _, t := range test.Targets {
		if t.ID == f.TargetID {
			fe.Target = t
			break
		}
	}

	return fe
}

func TestGetFinding(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetFinding",
			RequestURI: "/findings/" + test.Findings[0].ID,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var finding model.FindingExpanded
				test.JSONObject(tc, rec, "finding", &finding)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpanded(test.Findings[0]), finding)
			},
		},
		test.Case{
			Name:       "GetFindingNotFound",
			RequestURI: "/findings/" + test.NonExistingID,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var finding model.FindingExpanded
				test.JSONObject(tc, rec, "finding", &finding)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, model.FindingExpanded{}, finding)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/findings/:id", a.GetFinding)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestListFindings(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "ListFindings",
			RequestURI: "/findings",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpandedList(test.Findings), findings)
			},
		},
		test.Case{
			Name:       "ListFindingsWithPagination",
			RequestURI: "/findings?page=1",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpandedList(test.Findings), findings)
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, test.DefaultSize, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsWithPaginationZero",
			RequestURI: "/findings?page=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsWithPaginationOverflown",
			RequestURI: "/findings?page=100",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsWithPaginationMalformed",
			RequestURI: "/findings?page=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsWithStatusFixed",
			RequestURI: "/findings?status=FIXED",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpandedList([]model.Finding{test.Findings[0]}), findings)
				assert.Equal(tc, 1, pagination.Total)
			},
		},
		test.Case{
			Name:       "ListFindingsByTag",
			RequestURI: "/findings?tag=sdrn:adevinta:team:security",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpandedList(test.Findings), findings)
			},
		},
		test.Case{
			Name:       "ListFindingsByNonExistentTag",
			RequestURI: "/findings?tag=thisisanonexistenttag",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, []model.FindingExpanded{}, findings)
			},
		},
		test.Case{
			Name:       "ListFindingsWithMinScore",
			RequestURI: "/findings?minScore=3",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpandedList([]model.Finding{test.Findings[0], test.Findings[3]}), findings)
				assert.Equal(tc, 2, pagination.Total)
			},
		},
		test.Case{
			Name:       "ListFindingsWithMaxScore",
			RequestURI: "/findings?maxScore=2",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpandedList([]model.Finding{test.Findings[1], test.Findings[2], test.Findings[4], test.Findings[5]}), findings)
				assert.Equal(tc, 4, pagination.Total)
			},
		},
		test.Case{
			Name:       "ListFindingsWithMinDateMalformed",
			RequestURI: "/findings?minDate=01-02-2013",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.Finding
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsWithMaxDateMalformed",
			RequestURI: "/findings?maxDate=2019-30-12",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.Finding
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/findings", a.ListFindings)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestListFindingsByTarget(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "ListFindingsByTarget",
			RequestURI: "/targets/" + test.Targets[0].ID + "/findings",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)

				assert.Equal(tc, http.StatusOK, rec.Code)
				for _, f := range findings {
					assert.Equal(tc, test.Targets[0].ID, f.Target.ID)
				}
			},
		},
		test.Case{
			Name:       "ListFindingsByTargetWithPagination",
			RequestURI: "/targets/" + test.Targets[0].ID + "/findings?page=1",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				for _, f := range findings {
					assert.Equal(tc, test.Targets[0].ID, f.Target.ID)
				}
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, test.DefaultSize, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsByTargetWithPaginationZero",
			RequestURI: "/targets/" + test.Targets[0].ID + "/findings?page=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsByTargetWithPaginationOverflown",
			RequestURI: "/targets/" + test.Targets[0].ID + "/findings?page=100",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsByTargetWithPaginationMalformed",
			RequestURI: "/targets/" + test.Targets[0].ID + "/findings?page=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/targets/:id/findings", a.ListFindingsByTarget)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestListFindingsByIssue(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "ListFindingsByIssue",
			RequestURI: "/issues/" + test.Issues[0].ID + "/findings",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)

				assert.Equal(tc, http.StatusOK, rec.Code)
				for _, f := range findings {
					assert.Equal(tc, test.Issues[0].ID, f.Issue.ID)
				}
			},
		},
		test.Case{
			Name:       "ListFindingsByIssueWithPagination",
			RequestURI: "/issues/" + test.Issues[0].ID + "/findings?page=1",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				for _, f := range findings {
					assert.Equal(tc, test.Issues[0].ID, f.Issue.ID)
				}
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, test.DefaultSize, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsByIssueWithPaginationZero",
			RequestURI: "/issues/" + test.Issues[0].ID + "/findings?page=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsByIssueWithPaginationOverflown",
			RequestURI: "/issues/" + test.Issues[0].ID + "/findings?page=100",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsByIssueWithPaginationMalformed",
			RequestURI: "/issues/" + test.Issues[0].ID + "/findings?page=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/issues/:id/findings", a.ListFindingsByIssue)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestListFindingsBySource(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "ListFindingsBySource",
			RequestURI: "/sources/" + test.Sources[0].ID + "/findings",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)

				assert.Equal(tc, http.StatusOK, rec.Code)
				for _, f := range findings {
					found := false
					for _, fe := range test.FindingEvents {
						if fe.FindingID == f.ID && fe.SourceID == test.Sources[0].ID {
							found = true
						}
					}
					assert.True(tc, found)
				}
			},
		},
		test.Case{
			Name:       "ListFindingsBySourceWithPagination",
			RequestURI: "/sources/" + test.Issues[0].ID + "/findings?page=1",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				for _, f := range findings {
					found := false
					for _, fe := range test.FindingEvents {
						if fe.FindingID == f.ID && fe.SourceID == test.Sources[0].ID {
							found = true
						}
					}
					assert.True(tc, found)
				}
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, test.DefaultSize, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsBySourceWithPaginationZero",
			RequestURI: "/sources/" + test.Issues[0].ID + "/findings?page=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsBySourceWithPaginationOverflown",
			RequestURI: "/sources/" + test.Issues[0].ID + "/findings?page=100",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingsBySourceWithPaginationMalformed",
			RequestURI: "/sources/" + test.Issues[0].ID + "/findings?page=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var findings []model.FindingExpanded
				test.JSONObject(tc, rec, "findings", &findings)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(findings))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/sources/:id/findings", a.ListFindingsBySource)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestListFindingEventsByFinding(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "ListFindingEventsByFinding",
			RequestURI: "/findings/" + test.Findings[0].ID + "/events",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var events []model.FindingEvent
				test.JSONObject(tc, rec, "events", &events)

				assert.Equal(tc, http.StatusOK, rec.Code)
				for _, e := range events {
					assert.Equal(tc, test.Findings[0].ID, e.FindingID)
				}
			},
		},
		test.Case{
			Name:       "ListFindingEventsByFindingWithPagination",
			RequestURI: "/findings/" + test.Findings[0].ID + "/events?page=1",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var events []model.FindingEvent
				test.JSONObject(tc, rec, "events", &events)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				for _, e := range events {
					assert.Equal(tc, test.Findings[0].ID, e.FindingID)
				}
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, test.DefaultSize, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingEventsByFindingWithPaginationZero",
			RequestURI: "/findings/" + test.Findings[0].ID + "/events?page=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var events []model.Finding
				test.JSONObject(tc, rec, "events", &events)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(events))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingEventsByFindingWithPaginationOverflown",
			RequestURI: "/findings/" + test.Findings[0].ID + "/events?page=100",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var events []model.Finding
				test.JSONObject(tc, rec, "events", &events)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, 0, len(events))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListFindingEventsByFindingWithPaginationMalformed",
			RequestURI: "/findings/" + test.Findings[0].ID + "/events?page=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var events []model.Finding
				test.JSONObject(tc, rec, "events", &events)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(events))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/findings/:id/events", a.ListFindingEventsByFinding)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestGetFindingFromTargetIssueAndResource(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetFindingFromTargetIssueAndResource",
			RequestURI: "/targets/" + test.Targets[0].ID + "/issues/" + test.Issues[0].ID + "/resources/" + test.Findings[0].AffectedResource,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var finding model.FindingExpanded
				test.JSONObject(tc, rec, "finding", &finding)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpanded(test.Findings[0]), finding)
			},
		},
		test.Case{
			Name:       "GetFindingNotFound",
			RequestURI: "/targets/" + test.NonExistingID + "/issues/" + test.NonExistingID + "/resources/non-existing-resource",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var finding model.FindingExpanded
				test.JSONObject(tc, rec, "finding", &finding)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, model.FindingExpanded{}, finding)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/targets/:target_id/issues/:issue_id/resources/:resource", a.GetFindingFromTargetIssueAndResource)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestGetFindingFromIssueTargetAndResource(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetFindingFromIssueTargetAndResource",
			RequestURI: "/issues/" + test.Issues[0].ID + "/targets/" + test.Targets[0].ID + "/resources/" + test.Findings[0].AffectedResource,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var finding model.FindingExpanded
				test.JSONObject(tc, rec, "finding", &finding)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, buildFindingExpanded(test.Findings[0]), finding)
			},
		},
		test.Case{
			Name:       "GetFindingNotFound",
			RequestURI: "/issues/" + test.NonExistingID + "/targets/" + test.NonExistingID + "/resources/non-existing-resource",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var finding model.FindingExpanded
				test.JSONObject(tc, rec, "finding", &finding)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, model.FindingExpanded{}, finding)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/issues/:issue_id/targets/:target_id/resources/:resource", a.GetFindingFromTargetIssueAndResource)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestGetFindingMTTR(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetFindingMTTROfFixed",
			RequestURI: "/findings/" + test.Findings[0].ID + "/mttr",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var mttr float32
				test.JSONObject(tc, rec, "mttr", &mttr)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, float32(5), mttr)
			},
		},
		test.Case{
			Name:       "GetFindingMTTROfOpen",
			RequestURI: "/findings/" + test.Findings[1].ID + "/mttr",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var mttr float32
				test.JSONObject(tc, rec, "mttr", &mttr)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, float32(0), mttr)
			},
		},
	}

	e := echo.New()
	a := New(findingsDB{}, test.Options)
	e.GET("/findings/:id/mttr", a.GetFindingMTTR)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}
