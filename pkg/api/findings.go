/*
Copyright 2020 Adevinta
*/

package api

import (
	"fmt"
	"net/http"

	"github.com/labstack/echo"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
)

// ListFindings returns a paginated JSON containing findings.
func (api *API) ListFindings(c echo.Context) error {
	filter, err := api.parseFilter(c)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	findings, pagination, err := api.storage.ListFindings(filter)
	if err != nil {
		return err
	}

	return response(c, http.StatusOK, findings, "findings", pagination)
}

// GetFinding returns a JSON containing a specific finding.
func (api *API) GetFinding(c echo.Context) error {
	id := c.Param("id")

	finding, err := api.storage.GetFinding(id)
	if err != nil {
		return err
	}

	if finding.ID == "" {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	return response(c, http.StatusOK, finding, "finding")
}

// PatchFinding updates parts of a finding and returns a
// JSON containing the modified finding.
func (api *API) PatchFinding(c echo.Context) error {
	id := c.Param("id")

	finding, err := api.storage.GetFinding(id)
	if err != nil {
		return err
	}

	if finding.ID == "" {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	payload := new(model.PatchFindingPayload)
	if err := c.Bind(payload); err != nil {
		return err
	}

	if payload.Status != "" {
		if !validFindingStatus(payload.Status) {
			return echo.NewHTTPError(http.StatusUnprocessableEntity, fmt.Sprintf("Invalid status: '%s'", payload.Status))
		}

		if err := validateFindingTransition(finding, *payload); err != nil {
			return err
		}

		finding.Status = payload.Status
	} else {
		// If the user does not provide a value for Status, return Bad Request
		return echo.NewHTTPError(http.StatusBadRequest, "Empty Payload")
	}

	err = api.storage.PatchFinding(id, *payload)
	if err != nil {
		return err
	}

	return response(c, http.StatusOK, finding, "finding")
}

func validateFindingTransition(finding model.FindingExpanded, payload model.PatchFindingPayload) error {
	// Valid transitions:
	//
	// OPEN           -> OPEN
	// FALSE_POSITIVE -> OPEN
	// OPEN           -> FALSE_POSITIVE
	// FALSE_POSITIVE -> FALSE_POSITIVE
	if (finding.Status != "OPEN" && finding.Status != "FALSE_POSITIVE") ||
		(payload.Status != "OPEN" && payload.Status != "FALSE_POSITIVE") {
		return echo.NewHTTPError(http.StatusConflict, fmt.Sprintf("Status transition not allowed: from '%s' to '%s'", finding.Status, payload.Status))
	}
	return nil
}

func validFindingStatus(status string) bool {
	// Set of valid status type
	validStatus := map[string]struct{}{
		"OPEN":           {},
		"FIXED":          {},
		"EXPIRED":        {},
		"FALSE_POSITIVE": {},
	}

	_, existsInSet := validStatus[status]
	return existsInSet
}

// GetFindingFromTargetIssue returns a JSON containing a specific finding
// which is associated to the specified target and issue IDs.
func (api *API) GetFindingFromTargetIssue(c echo.Context) error {
	targetID := c.Param("target_id")
	affectedResource := c.Param("affected_resource")
	issueID := c.Param("issue_id")

	finding, err := api.storage.GetFindingFromTargetIssue(targetID, affectedResource, issueID)
	if err != nil {
		return err
	}

	if finding.ID == "" {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	return response(c, http.StatusOK, finding, "finding")
}

// ListFindingsByTarget returns a paginated JSON containing findings for a specific target.
func (api *API) ListFindingsByTarget(c echo.Context) error {
	id := c.Param("id")

	filter, err := api.parseFilter(c)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	findings, pagination, err := api.storage.ListFindingsByTarget(id, filter)
	if err != nil {
		return err
	}

	return response(c, http.StatusOK, findings, "findings", pagination)
}

// ListFindingsByIssue returns a paginated JSON containing findings for a specific issue.
func (api *API) ListFindingsByIssue(c echo.Context) error {
	id := c.Param("id")

	filter, err := api.parseFilter(c)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	findings, pagination, err := api.storage.ListFindingsByIssue(id, filter)
	if err != nil {
		return err
	}

	return response(c, http.StatusOK, findings, "findings", pagination)
}

// ListFindingsBySource returns a paginated JSON containing findings for a specific source.
func (api *API) ListFindingsBySource(c echo.Context) error {
	id := c.Param("id")

	filter, err := api.parseFilter(c)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	findings, pagination, err := api.storage.ListFindingsBySource(id, filter)
	if err != nil {
		return err
	}

	return response(c, http.StatusOK, findings, "findings", pagination)
}

// GetFindingMTTR returns a JSON containing the mean time to remediate a finding.
func (api *API) GetFindingMTTR(c echo.Context) error {
	id := c.Param("id")

	mttr, err := api.storage.GetFindingMTTR(id)
	if err != nil {
		return err
	}

	if mttr == 0 {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	return response(c, http.StatusOK, mttr, "mttr")
}
