/*
Copyright 2020 Adevinta
*/

package api

import (
	"net/http"

	"github.com/labstack/echo"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
)

// ListFindings returns a paginated JSON containing findings.
func (api *API) ListFindings(c echo.Context) error {
	filter, err := api.parseFilter(c)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	findings, pagination, err := api.storage.ListFindings(filter)
	if err != nil {
		return err
	}

	return response(c, findings, "findings", pagination)
}

// GetFinding returns a JSON containing a specific finding.
func (api *API) GetFinding(c echo.Context) error {
	id := c.Param("id")

	finding, err := api.storage.GetFinding(id)
	if err != nil {
		return err
	}

	if finding.ID == "" {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	return response(c, finding, "finding")
}

// PatchFinding updates parts of a finding and returns a
// JSON containing the modified finding.
func (api *API) PatchFinding(c echo.Context) error {
	id := c.Param("id")

	finding, err := api.storage.GetFinding(id)
	if err != nil {
		return err
	}

	if finding.ID == "" {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	payload := new(model.PatchFindingPayload)
	if err := c.Bind(payload); err != nil {
		return err
	}

	if payload.Status != "" {
		if !validFindingStatus(payload.Status) {
			return echo.NewHTTPError(http.StatusUnprocessableEntity, "Invalid status")
		}
		finding.Status = payload.Status
	}

	err = api.storage.PatchFinding(id, *payload)
	if err != nil {
		return err
	}

	return response(c, finding, "finding")
}

func validFindingStatus(status string) bool {
	// Set of valid status type
	validStatus := map[string]struct{}{
		"OPEN":           struct{}{},
		"FIXED":          struct{}{},
		"EXPIRED":        struct{}{},
		"FALSE_POSITIVE": struct{}{},
	}

	_, existsInSet := validStatus[status]
	return existsInSet
}

// GetFindingFromTargetIssue returns a JSON containing a specific finding
// which is associated to the specified target and issue IDs.
func (api *API) GetFindingFromTargetIssue(c echo.Context) error {
	targetID := c.Param("target_id")
	issueID := c.Param("issue_id")

	finding, err := api.storage.GetFindingFromTargetIssue(targetID, issueID)
	if err != nil {
		return err
	}

	if finding.ID == "" {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	return response(c, finding, "finding")
}

// ListFindingsByTarget returns a paginated JSON containing findings for a specific target.
func (api *API) ListFindingsByTarget(c echo.Context) error {
	id := c.Param("id")

	filter, err := api.parseFilter(c)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	findings, pagination, err := api.storage.ListFindingsByTarget(id, filter)
	if err != nil {
		return err
	}

	return response(c, findings, "findings", pagination)
}

// ListFindingsByIssue returns a paginated JSON containing findings for a specific issue.
func (api *API) ListFindingsByIssue(c echo.Context) error {
	id := c.Param("id")

	filter, err := api.parseFilter(c)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	findings, pagination, err := api.storage.ListFindingsByIssue(id, filter)
	if err != nil {
		return err
	}

	return response(c, findings, "findings", pagination)
}

// ListFindingsBySource returns a paginated JSON containing findings for a specific source.
func (api *API) ListFindingsBySource(c echo.Context) error {
	id := c.Param("id")

	filter, err := api.parseFilter(c)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	findings, pagination, err := api.storage.ListFindingsBySource(id, filter)
	if err != nil {
		return err
	}

	return response(c, findings, "findings", pagination)
}

// GetFindingMTTR returns a JSON containing the mean time to remediate a finding.
func (api *API) GetFindingMTTR(c echo.Context) error {
	id := c.Param("id")

	mttr, err := api.storage.GetFindingMTTR(id)
	if err != nil {
		return err
	}

	if mttr == 0 {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	return response(c, mttr, "mttr")
}
