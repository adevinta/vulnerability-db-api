/*
Copyright 2020 Adevinta
*/

package api

import (
	"errors"
	"reflect"
	"testing"

	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/labstack/echo"
)

type mockContext struct {
	echo.Context
	path   string
	params map[string]string
}

func (m mockContext) QueryParam(paramName string) string {
	return m.params[paramName]
}

func (m mockContext) Path() string {
	return m.path
}

func TestParseFilter(t *testing.T) {
	testCases := []struct {
		name           string
		input          echo.Context
		expectedFilter storage.Filter
		expectedErr    error
	}{
		{
			name: "Open findings",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"status": "OPEN",
				},
			},
			expectedFilter: storage.Filter{
				Status: "OPEN",
				Page:   1,
				Size:   20,
			},
		},
		{
			name: "Fixed findings with pagination",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"status": "FIXED",
					"page":   "2",
					"size":   "50",
				},
			},
			expectedFilter: storage.Filter{
				Status: "FIXED",
				Page:   2,
				Size:   50,
			},
		},
		{
			name: "Issues with min and max score",
			input: mockContext{
				path: "/issues",
				params: map[string]string{
					"minScore": "5",
					"maxScore": "7",
				},
			},
			expectedFilter: storage.Filter{
				MinScore: 5,
				MaxScore: 7,
				Page:     1,
				Size:     20,
			},
		},
		{
			name: "Targets with tag and identifier",
			input: mockContext{
				path: "/targets",
				params: map[string]string{
					"tag":        "sdrn:adevinta:teams:purple",
					"identifier": "vulcan",
				},
			},
			expectedFilter: storage.Filter{
				Tag:        "sdrn:adevinta:teams:purple",
				Identifier: "vulcan",
				Page:       1,
				Size:       20,
			},
		},
		{
			name: "Findings with atDate",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"atDate": "2020-07-01",
				},
			},
			expectedFilter: storage.Filter{
				AtDate: "2020-07-01",
				Page:   1,
				Size:   20,
			},
		},
		{
			name: "Findings with sortBy score asc",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"sortBy": "score",
				},
			},
			expectedFilter: storage.Filter{
				SortBy: storage.SortBy{
					Field: "score",
					Order: "asc",
				},
				Page: 1,
				Size: 20,
			},
		},
		{
			name: "Issues summary with sortBy max_score desc",
			input: mockContext{
				path: "/issues/summary",
				params: map[string]string{
					"sortBy": "-max_score",
				},
			},
			expectedFilter: storage.Filter{
				SortBy: storage.SortBy{
					Field: "max_score",
					Order: "desc",
				},
				Page: 1,
				Size: 20,
			},
		},
		{
			name: "Issues summary with sortBy targets_count desc",
			input: mockContext{
				path: "/issues/summary",
				params: map[string]string{
					"sortBy": "-targets_count",
				},
			},
			expectedFilter: storage.Filter{
				SortBy: storage.SortBy{
					Field: "targets_count",
					Order: "desc",
				},
				Page: 1,
				Size: 20,
			},
		},
		{
			name: "Targets summary with sortBy findings_count asc",
			input: mockContext{
				path: "/targets/summary",
				params: map[string]string{
					"sortBy": "findings_count",
				},
			},
			expectedFilter: storage.Filter{
				SortBy: storage.SortBy{
					Field: "findings_count",
					Order: "asc",
				},
				Page: 1,
				Size: 20,
			},
		},
		{
			name: "Should return err invalid date format for minDate",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"minDate": "01-02-2020",
				},
			},
			expectedErr: ErrDateMalformed,
		},
		{
			name: "Should return err invalid date format for maxDate",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"maxDate": "01-02-2020",
				},
			},
			expectedErr: ErrDateMalformed,
		},
		{
			name: "Should return err invalid date format for atDate",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"atDate": "01-02-2020",
				},
			},
			expectedErr: ErrDateMalformed,
		},
		{
			name: "Should return err invalid filter combination, minDate and atDate",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"atDate":  "2020-01-02",
					"minDate": "2020-01-01",
				},
			},
			expectedErr: ErrInvalidFilter,
		},
		{
			name: "Should return err invalid filter combination, findings with minDate without status",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"minDate": "2020-01-01",
				},
			},
			expectedErr: ErrInvalidFilter,
		},
		{
			name: "Should return err invalid filter combination, findings with maxDate without status",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"maxDate": "2020-01-01",
				},
			},
			expectedErr: ErrInvalidFilter,
		},
		{
			name: "Should return err invalid filter due to invalid sort, invalid field",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"sortBy": "-wrongParam",
				},
			},
			expectedErr: ErrInvalidFilter,
		},
		{
			name: "Should return err invalid filter due to invalid sort, invalid field for endpoint",
			input: mockContext{
				path: "/findings",
				params: map[string]string{
					"sortBy": "findings_count",
				},
			},
			expectedErr: ErrInvalidFilter,
		},
	}

	api := &API{
		Options: Options{
			MaxSize:     100,
			DefaultSize: 20,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			filter, err := api.parseFilter(tc.input)
			if err != nil {
				if !errors.Is(err, tc.expectedErr) {
					t.Fatalf("Error. Expected error to be: %v\nBut got: %v",
						tc.expectedErr, err)
				}
			} else if !reflect.DeepEqual(filter, tc.expectedFilter) {
				t.Fatalf("Error. Expected filter to be: %v\nBut got: %v",
					tc.expectedFilter, filter)
			}
		})
	}
}
