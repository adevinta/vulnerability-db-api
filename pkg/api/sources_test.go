/*
Copyright 2020 Adevinta
*/

package api

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/adevinta/vulnerability-db-api/pkg/api/test"
	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/labstack/echo"
	"github.com/stretchr/testify/assert"
)

type sourcesDB test.MockDB

func (db sourcesDB) ListSources(filter storage.Filter) ([]model.Source, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)
	return test.Sources, storage.Pagination{Limit: filter.Size, Offset: offset, Total: len(test.Sources)}, nil
}

func (db sourcesDB) GetSource(id string) (model.Source, error) {
	for _, source := range test.Sources {
		if source.ID == id {
			return source, nil
		}
	}

	return model.Source{}, nil
}

func (db sourcesDB) GetSourceMTTR(id string) (float32, error) {
	var ttrSum, count float32 = 0, 0

	for _, event := range test.FindingEvents {
		if event.SourceID == id {
			for _, exposure := range test.FindingExposures {
				if exposure.FindingID == event.FindingID {
					ttrSum += exposure.TTR
					count++
				}
			}
		}
	}

	if ttrSum == 0 {
		return 0, nil
	}

	return ttrSum / count, nil
}

func TestGetSource(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetSource",
			RequestURI: "/sources/" + test.Sources[0].ID,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var source model.Source
				test.JSONObject(tc, rec, "source", &source)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Sources[0], source)
			},
		},
		test.Case{
			Name:       "GetSourceNotFound",
			RequestURI: "/sources/" + test.NonExistingID,
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var source model.Source
				test.JSONObject(tc, rec, "source", &source)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, model.Source{}, source)
			},
		},
	}

	e := echo.New()
	a := New(sourcesDB{}, test.Options)
	e.GET("/sources/:id", a.GetSource)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestListSources(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "ListSources",
			RequestURI: "/sources",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var sources []model.Source
				test.JSONObject(tc, rec, "sources", &sources)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Sources, sources)
			},
		},
		test.Case{
			Name:       "ListSourcesWithPagination",
			RequestURI: "/sources?page=1",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var sources []model.Source
				test.JSONObject(tc, rec, "sources", &sources)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, test.Sources, sources)
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, test.DefaultSize, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListSourcesWithPaginationZero",
			RequestURI: "/sources?page=0",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var sources []model.Source
				test.JSONObject(tc, rec, "sources", &sources)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(sources))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListSourcesWithPaginationOverflown",
			RequestURI: "/sources?page=100",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var sources []model.Source
				test.JSONObject(tc, rec, "sources", &sources)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, 0, len(sources))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
		test.Case{
			Name:       "ListSourcesWithPaginationMalformed",
			RequestURI: "/sources?page=malformed",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var sources []model.Source
				test.JSONObject(tc, rec, "sources", &sources)
				var pagination Pagination
				test.JSONObject(tc, rec, "pagination", &pagination)

				assert.Equal(tc, http.StatusBadRequest, rec.Code)
				assert.Equal(tc, 0, len(sources))
				assert.Equal(tc, false, pagination.More)
				assert.Equal(tc, 0, pagination.Limit)
			},
		},
	}

	e := echo.New()
	a := New(sourcesDB{}, test.Options)
	e.GET("/sources", a.ListSources)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}

func TestGetSourceMTTR(t *testing.T) {
	tcs := []test.Case{
		test.Case{
			Name:       "GetSourceMTTROfFixed",
			RequestURI: "/sources/" + test.Sources[1].ID + "/mttr",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var mttr float32
				test.JSONObject(tc, rec, "mttr", &mttr)

				assert.Equal(tc, http.StatusOK, rec.Code)
				assert.Equal(tc, float32(5), mttr)
			},
		},
		test.Case{
			Name:       "GetSourceMTTROfOpen",
			RequestURI: "/sources/" + test.Sources[0].ID + "/mttr",
			Test: func(tc *testing.T, rec *httptest.ResponseRecorder) {
				var mttr float32
				test.JSONObject(tc, rec, "mttr", &mttr)

				assert.Equal(tc, http.StatusNotFound, rec.Code)
				assert.Equal(tc, float32(0), mttr)
			},
		},
	}

	e := echo.New()
	a := New(sourcesDB{}, test.Options)
	e.GET("/sources/:id/mttr", a.GetSourceMTTR)

	for _, tc := range tcs {
		t.Run(tc.Name, func(t *testing.T) {
			req := httptest.NewRequest(http.MethodGet, tc.RequestURI, nil)
			rec := httptest.NewRecorder()
			e.ServeHTTP(rec, req)
			tc.Test(t, rec)
		})
	}
}
