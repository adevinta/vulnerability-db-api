/*
Copyright 2020 Adevinta
*/

package postgresql

import (
	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
)

// ListFindingEvents returns a filtered list of finding events.
func (db DB) ListFindingEvents(filter storage.Filter) ([]model.FindingEvent, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	SELECT * FROM finding_events
	WHERE 1=1
	{{ if .MinScore }} AND score >= :minScore {{ end }}
	{{ if .MaxScore }} AND score <= :maxScore {{ end }}
	{{ if .MinDate }} AND time >= :minDate {{ end }}
	{{ if .MaxDate }} AND time <= :maxDate {{ end }}
	LIMIT :limit OFFSET :offset
	`, filter)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	SELECT COUNT(id) FROM finding_events
	WHERE 1=1
	{{ if .MinScore }} AND score >= :minScore {{ end }}
	{{ if .MaxScore }} AND score <= :maxScore {{ end }}
	{{ if .MinDate }} AND time >= :minDate {{ end }}
	{{ if .MaxDate }} AND time <= :maxDate {{ end }}
	`, filter)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}

	args := map[string]interface{}{
		"status":   filter.Status,
		"minScore": filter.MinScore,
		"maxScore": filter.MaxScore,
		"minDate":  filter.MinDate,
		"maxDate":  filter.MaxDate,
		"limit":    filter.Size,
		"offset":   offset,
	}

	events := []model.FindingEvent{}
	logQuery(db.Logger, "ListEvents", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&events, args)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}

	return events, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// ListFindingEventsByFinding returns a filtered list of finding events for a specific finding.
func (db DB) ListFindingEventsByFinding(id string, filter storage.Filter) ([]model.FindingEvent, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	SELECT * FROM finding_events WHERE finding_id = :findingID
	ORDER BY time DESC
	LIMIT :limit OFFSET :offset
	`, filter)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	SELECT COUNT(*) FROM (
	SELECT DISTINCT finding_id, source_id, time
	FROM finding_events WHERE finding_id = :findingID
	) TMP
	`, filter)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}

	args := map[string]interface{}{
		"findingID": id,
		"status":    filter.Status,
		"limit":     filter.Size,
		"offset":    offset,
	}

	events := []model.FindingEvent{}
	logQuery(db.Logger, "ListFindingEventsByFinding", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&events, args)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.FindingEvent{}, storage.Pagination{}, err
	}

	return events, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}
