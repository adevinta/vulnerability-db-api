/*
Copyright 2021 Adevinta
*/

package postgresql

import (
	"fmt"
	"strings"

	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/lib/pq"
)

// ListLabels returns a filtered list of labels.
func (db DB) ListLabels(filter storage.Filter) ([]string, error) {
	listQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		select finding_id
		  from findings f
		  INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
		  {{ if or .Team .Teams }}
		  INNER JOIN target_teams tt ON tt.target_id = f.target_id
		  {{ end }}
		  {{ if .Identifiers }}
		  INNER JOIN targets t ON f.target_id = t.id
		  {{ end }}
		 where 1=1
			{{ if .Team }}
			AND tt.team_id = :team
			{{ end }}
			{{ if .Teams }}
			AND tt.team_id = ANY (:teams)
			{{ end }}
			{{ if .Identifiers }}
			AND t.identifier = ANY (:identifiers)
			{{ end }}
			{{ if .AtDate }}
				{{ if .Status }}
					{{ if eq .Status "OPEN" }}
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						/* Ignore invalidated findings */
						AND f.status != 'INVALIDATED'
						AND fexp.found_at <= :aDateUpBound
						AND (
							/* 	It is not fixed nor expired,
							   	or was fixed after atDate param,
							   	or was expired after atDate param
							*/
							(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
							OR fexp.fixed_at >= :atDate
							OR fexp.expired_at >= :atDate
						)
					{{ end }}
					{{ if eq .Status "FIXED" }}
						/* Ignore expired findings */
						AND f.status != 'EXPIRED'
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						/* Ignore invalidated findings */
						AND f.status != 'INVALIDATED'
						/* It was fixed before atDate param */
						AND fexp.fixed_at < :aDateUpBound
						/* And there is not a posterior finding_exposure row with found_at before atDate */
						AND NOT EXISTS(
							SELECT finding_id FROM finding_exposures fexp2
							WHERE fexp2.finding_id = fexp.finding_id
							AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :aDateUpBound
						)
					{{ end }}
					{{ if eq .Status "FALSE_POSITIVE" }}
						AND f.status = 'FALSE_POSITIVE'
						AND fexp.found_at <= :aDateUpBound
					{{ end }}
				{{ else }}
					AND fexp.found_at <= :aDateUpBound
				{{ end }}
			{{ else }}
				{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					/* Ignore invalidated findings */
					AND f.status != 'INVALIDATED'
					{{ if .MinDate }}
					AND fexp.fixed_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.fixed_at <= :mxDateUpBound
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :mxDateUpBound
					)
					{{ else }}
					AND fexp.fixed_at IS NOT NULL
					/* Ensure that there are no entries with OPEN status after the current record */
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
					)
					{{ end }}
				{{ end }}
				{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					/* Ignore invalidated findings */
					AND f.status != 'INVALIDATED'
					{{ if .MinDate }}
					AND fexp.found_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.found_at <= :mxDateUpBound
					{{ end }}
				{{ end }}
			{{ end }}
		 group by finding_id
	)
	{{ end }}
	SELECT DISTINCT il.label FROM issue_labels il
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN findings f ON f.issue_id = il.issue_id
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	{{ if and (or .Status .Team .Teams.Identifiers) (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	INNER JOIN findings f ON f.issue_id = il.issue_id
	{{ end }}
	{{ if or .Team .Teams .Identifiers }}
	INNER JOIN targets t ON f.target_id = t.id
	{{ end }}
	{{ if or .Team .Teams }}
	INNER JOIN target_teams tt ON t.id = tt.target_id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .Team }}
	AND tt.team_id = :team
	{{ end }}
	{{ if .Teams }}
	AND tt.team_id = ANY (:teams)
	{{ end }}
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	`, filter)
	if err != nil {
		return []string{}, err
	}

	// Param names can not contain as prefix a previously defined
	// variable name to avoid collisions when processing stmts
	args := map[string]interface{}{
		"status":        filter.Status,
		"team":          filter.Team,
		"teams":         pq.Array(strings.Split(filter.Teams, ",")),
		"minDate":       filter.MinDate,
		"maxDate":       filter.MaxDate,
		"mxDateUpBound": fmt.Sprint(filter.MaxDate, dateUpBoundOffset),
		"atDate":        filter.AtDate,
		"aDateUpBound":  fmt.Sprint(filter.AtDate, dateUpBoundOffset),
		"identifiers":   pq.Array(strings.Split(filter.Identifiers, ",")),
	}

	labels := []string{}
	logQuery(db.Logger, "ListLabels", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []string{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&labels, args)
	if err != nil {
		return []string{}, err
	}

	return labels, nil
}
