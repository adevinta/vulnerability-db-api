/*
Copyright 2020 Adevinta
*/

package postgresql

import (
	"fmt"
	"strings"
	"time"

	"github.com/lib/pq"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
)

const (
	iso8601DateFmt = "2006-01-02"
)

// StatsSize returns statistics about the size of each data set.
func (db DB) StatsSize() (model.StatsSize, error) {
	size := model.StatsSize{}

	query := `
	SELECT
	(SELECT COUNT(id) FROM sources) as sources,
	(SELECT COUNT(id) FROM targets) as targets,
	(SELECT COUNT(id) FROM issues) as issues,
	(SELECT COUNT(id) FROM findings) as findings,
	(SELECT COUNT(id) FROM finding_events) as finding_events
	`
	logQuery(db.Logger, "StatsSize", query)
	err := db.DB.Get(&size, query)
	if err != nil {
		return model.StatsSize{}, err
	}

	return size, nil
}

// StatsOpenIssues returns statistics about the number of OPEN findings for each issue severity.
func (db DB) StatsOpenIssues(filter storage.Filter) (model.StatsIssueSeverity, error) {
	openIssues := model.StatsIssueSeverity{}

	openIssuesQuery, err := filterTemplate(`
	SELECT
	COALESCE(SUM(CASE WHEN score = 0 THEN 1 ELSE 0 END), 0) AS informational,
	COALESCE(SUM(CASE WHEN score > 0 AND score < 4 THEN 1 ELSE 0 END), 0) AS low,
	COALESCE(SUM(CASE WHEN score >= 4 AND score < 7 THEN 1 ELSE 0 END), 0) AS medium,
	COALESCE(SUM(CASE WHEN score >= 7 AND score < 9 THEN 1 ELSE 0 END), 0) AS high,
	COALESCE(SUM(CASE WHEN score >= 9 THEN 1 ELSE 0 END), 0) AS critical
	FROM ( 
		SELECT DISTINCT f.id, f.score as score FROM findings f
		{{ if or .AtDate .MinDate .MaxDate }}
		INNER JOIN finding_exposures fexp ON fexp.finding_id = f.id
		{{ end }}
		{{ if .Identifiers }}
		INNER JOIN targets t ON f.target_id = t.id
		{{ end }}
		{{ if or .Tag .Tags }}
		INNER JOIN target_tags tt ON f.target_id = tt.target_id
		{{ end }}
		{{ if .Labels }}
		INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		{{ end }}
		WHERE 1=1
		/* Ignore findings marked as false positive	*/
		AND f.status != 'FALSE_POSITIVE'
		/* Ignore invalidated findings */
		AND f.status != 'INVALIDATED'
		{{ if .AtDate }}
			AND fexp.found_at <= :aDateUpBound
			AND (
				/* 	It is not fixed nor expired,
					or was fixed after atDate param,
					or was expired after atDate param
				*/ 
				(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL) 
				OR fexp.fixed_at >= :atDate
				OR fexp.expired_at >= :atDate
			)
		{{ else }}
			{{ if and (not .MaxDate) (not .MinDate) }}
			AND f.status = 'OPEN'
			{{ else }}
				{{ if .MaxDate }}
				AND fexp.found_at <= :mxDateUpBound
				{{ end }}
				{{ if .MinDate }}
				AND fexp.found_at >= :minDate
				{{ end }}
			{{ end }}
		{{ end }}
		{{ if .Tag }}
		AND tt.tag = :tag
		{{ end }}
		{{ if .Tags }}
		AND tt.tag = ANY (:tags)
		{{ end }}
		{{ if .Identifiers }}
		AND t.identifier = ANY (:identifiers)
		{{ end }}
		{{ if .Labels }}
		AND il.label = ANY (:labels)
		{{ end }}
		{{ if or .AtDate .MinDate .MaxDate }}
		GROUP BY f.id
		{{ end }}
	) filtered_findings
	`, filter)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}

	// Param names can not contain as prefix a previously defined
	// variable name to avoid collisions when processing stmts
	args := map[string]interface{}{
		"tag":           filter.Tag,
		"tags":          pq.Array(strings.Split(filter.Tags, ",")),
		"minDate":       filter.MinDate,
		"maxDate":       filter.MaxDate,
		"mxDateUpBound": fmt.Sprint(filter.MaxDate, dateUpBoundOffset),
		"atDate":        filter.AtDate,
		"aDateUpBound":  fmt.Sprint(filter.AtDate, dateUpBoundOffset),
		"identifiers":   pq.Array(strings.Split(filter.Identifiers, ",")),
		"labels":        pq.Array(strings.Split(filter.Labels, ",")),
	}

	logQuery(db.Logger, "StatsOpenIssues", openIssuesQuery, args)
	nstmt, err := db.DB.PrepareNamed(openIssuesQuery)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&openIssues, args)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}

	return openIssues, nil
}

// StatsFixedIssues returns statistics about the number of FIXED findings for each issue severity.
func (db DB) StatsFixedIssues(filter storage.Filter) (model.StatsIssueSeverity, error) {
	fixedIssues := model.StatsIssueSeverity{}

	fixedIssuesQuery, err := filterTemplate(`
	SELECT
	COALESCE(SUM(CASE WHEN score = 0 THEN 1 ELSE 0 END), 0) AS informational,
	COALESCE(SUM(CASE WHEN score > 0 AND score < 4 THEN 1 ELSE 0 END), 0) AS low,
	COALESCE(SUM(CASE WHEN score >= 4 AND score < 7 THEN 1 ELSE 0 END), 0) AS medium,
	COALESCE(SUM(CASE WHEN score >= 7 AND score < 9 THEN 1 ELSE 0 END), 0) AS high,
	COALESCE(SUM(CASE WHEN score >= 9 THEN 1 ELSE 0 END), 0) AS critical
	FROM ( 
		SELECT DISTINCT f.id, f.score as score FROM findings f
		{{ if or .AtDate .MinDate .MaxDate }}
		INNER JOIN finding_exposures fexp ON fexp.finding_id = f.id
		{{ end }}
		{{ if .Identifiers }}
		INNER JOIN targets t ON f.target_id = t.id
		{{ end }}
		{{ if or .Tag .Tags }}
		INNER JOIN target_tags tt ON f.target_id = tt.target_id
		{{ end }}
		{{ if .Labels }}
		INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		{{ end }}
		WHERE 1=1
		/* Ignore expired findings */
		AND f.status != 'EXPIRED'
		/* Ignore invalidated findings */
		AND f.status != 'INVALIDATED'
		{{ if or .AtDate .MaxDate .MinDate }}
			{{ if .AtDate }}
				AND fexp.fixed_at < :aDateUpBound
				AND NOT EXISTS(
					SELECT finding_id FROM finding_exposures fexp2 
					WHERE fexp2.finding_id = fexp.finding_id 
					AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :aDateUpBound
				)
			{{ else }}
				AND fexp.fixed_at <= :mxDateUpBound
				AND NOT EXISTS(
					SELECT finding_id FROM finding_exposures fexp2 
					WHERE fexp2.finding_id = fexp.finding_id 
					AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :mxDateUpBound
				)
				{{ if .MinDate }}
				AND fexp.fixed_at >= :minDate
				{{ end }}
			{{ end }}
		{{ else }}
			AND f.status = 'FIXED'
		{{ end }}
		{{ if .Tag }}
		AND tt.tag = :tag
		{{ end }}
		{{ if .Tags }}
		AND tt.tag = ANY (:tags)
		{{ end }}
		{{ if .Identifiers }}
		AND t.identifier = ANY (:identifiers)
		{{ end }}
		{{ if .Labels }}
		AND il.label = ANY (:labels)
		{{ end }}
		{{ if or .AtDate .MinDate .MaxDate }}
		GROUP BY f.id
		{{ end }}
	) filtered_findings
	`, filter)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}

	// If min date is set, but max date is not specified
	// set max date refference to current time.
	if filter.MinDate != "" && filter.MaxDate == "" {
		filter.MaxDate = time.Now().UTC().Format(iso8601DateFmt)
	}

	// Param names can not contain as prefix a previously defined
	// variable name to avoid collisions when processing stmts
	args := map[string]interface{}{
		"tag":           filter.Tag,
		"tags":          pq.Array(strings.Split(filter.Tags, ",")),
		"minDate":       filter.MinDate,
		"maxDate":       filter.MaxDate,
		"mxDateUpBound": fmt.Sprint(filter.MaxDate, dateUpBoundOffset),
		"atDate":        filter.AtDate,
		"aDateUpBound":  fmt.Sprint(filter.AtDate, dateUpBoundOffset),
		"identifiers":   pq.Array(strings.Split(filter.Identifiers, ",")),
		"labels":        pq.Array(strings.Split(filter.Labels, ",")),
	}

	logQuery(db.Logger, "StatsFixedIssues", fixedIssuesQuery, args)
	nstmt, err := db.DB.PrepareNamed(fixedIssuesQuery)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&fixedIssues, args)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}

	return fixedIssues, nil
}

// StatsIssues returns a list of aggregated issues from a set of finding events.
func (db DB) StatsIssues(filter storage.Filter) ([]model.Issue, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)
	listQuery, err := filterTemplate(`
	WITH query as (
		SELECT i.*,
		COUNT(f.id) filter (WHERE f.status='FIXED') AS fixed,
		COUNT(f.status) FILTER (WHERE f.status='OPEN') AS open
		FROM issues i JOIN findings f ON f.issue_id=i.id
		WHERE EXISTS(
			SELECT * FROM sources s JOIN source_issues si ON si.source_id=s.id
			WHERE si.issue_id=f.issue_id AND s.target_id=f.target_id
				{{ if .MinDate }} AND s.time >= :minDate {{ end }}
				{{ if .MaxDate }} AND s.time <= :mxDateUpBound {{ end }}
		)
		{{ if .MinScore }} AND f.score >= :minScore {{ end }}
		{{ if .MaxScore }} AND f.score <= :maxScore {{ end }}
		GROUP BY i.id
	)
	SELECT q.*,t.total as total FROM ( SELECT * FROM query LIMIT :limit OFFSET :offset) q  
	JOIN (SELECT COUNT(*) as total FROM query) AS t  ON true
	`, filter)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}

	// Param names can not contain as prefix a previously defined
	// variable name to avoid collisions when processing stmts
	args := map[string]interface{}{
		"minDate":       filter.MinDate,
		"maxDate":       filter.MaxDate,
		"mxDateUpBound": fmt.Sprint(filter.MaxDate, dateUpBoundOffset),
		"minScore":      filter.MinScore,
		"maxScore":      filter.MaxScore,
		"limit":         filter.Size,
		"offset":        offset,
	}
	type resHolder struct {
		model.Issue
		storage.Pagination
	}
	res := []resHolder{}
	logQuery(db.Logger, "ListIssuesFromFindingEvents", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&res, args)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}

	var size int
	issues := []model.Issue{}
	if len(res) > 0 {
		size = res[0].Total
	}
	for _, r := range res {
		issues = append(issues, r.Issue)
	}

	return issues, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// StatsMTTR returns the mean time to remediate by issue severity.
func (db DB) StatsMTTR(filter storage.Filter) (model.StatsMTTRSeverity, error) {
	mttrQuery, err := filterTemplate(`
	WITH exposures as (
		SELECT fe.ttr as ttr, f.score as score
		FROM finding_exposures fe
		INNER JOIN findings f ON fe.finding_id = f.id
		{{ if or .Tag .Tags }}
		INNER JOIN targets t ON f.target_id = t.id
		INNER JOIN target_tags tt ON t.id = tt.target_id
		{{ end }}
		{{ if .Labels }}
		INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		{{ end }}
		WHERE fe.ttr IS NOT NULL
		{{ if .MinDate }} AND fe.fixed_at >= :minDate {{ end }}
		{{ if .MaxDate }} AND fe.fixed_at <= :mxDateUpBound {{ end }}
		{{ if .Tag }} AND tt.tag = :tag {{ end }}
		{{ if .Tags }} AND tt.tag = ANY (:tags) {{ end }}
		{{ if .Labels }} AND il.label = ANY (:labels) {{ end }}
	)
	SELECT CASE
		WHEN score = 0 THEN 'informational'
		WHEN score > 0 AND score < 4 THEN 'low'
		WHEN score >= 4 AND score < 7 THEN 'medium'
		WHEN score >= 7 AND score < 9 THEN 'high'
		WHEN score >= 9 THEN 'critical'
	END AS severity, AVG(ttr)
	FROM exposures
	GROUP BY severity
	UNION
	SELECT 'total', COALESCE (AVG(ttr), 0)
	FROM exposures
	`, filter)
	if err != nil {
		return model.StatsMTTRSeverity{}, err
	}

	// Param names can not contain as prefix a previously defined
	// variable name to avoid collisions when processing stmts
	args := map[string]interface{}{
		"tag":           filter.Tag,
		"tags":          pq.Array(strings.Split(filter.Tags, ",")),
		"minDate":       filter.MinDate,
		"maxDate":       filter.MaxDate,
		"mxDateUpBound": fmt.Sprint(filter.MaxDate, dateUpBoundOffset),
		"labels":        pq.Array(strings.Split(filter.Labels, ",")),
	}

	logQuery(db.Logger, "StatsMTTR", mttrQuery, args)
	nstmt, err := db.DB.PrepareNamed(mttrQuery)
	if err != nil {
		return model.StatsMTTRSeverity{}, err
	}
	defer nstmt.Close()
	rows, err := nstmt.Queryx(args)
	if err != nil {
		return model.StatsMTTRSeverity{}, err
	}

	mttrStats := model.StatsMTTRSeverity{}

	for rows.Next() {
		var severity string
		var mttr float32

		err = rows.Scan(&severity, &mttr)
		if err != nil {
			return model.StatsMTTRSeverity{}, err
		}

		switch severity {
		case "total":
			mttrStats.Total = mttr
		case "informational":
			mttrStats.Informational = mttr
		case "low":
			mttrStats.Low = mttr
		case "medium":
			mttrStats.Medium = mttr
		case "high":
			mttrStats.High = mttr
		case "critical":
			mttrStats.Critical = mttr
		}
	}

	return mttrStats, nil
}

// StatsExposure returns the exposure times by diferent averages.
func (db DB) StatsExposure(filter storage.Filter) (model.StatsExposure, error) {
	exposureQuery, err := filterTemplate(`
	WITH exposures as (
        SELECT fe.finding_id, SUM(COALESCE (fe.ttr,
        {{ if .AtDate }}
		DATE_PART ('day', COALESCE (fe.expired_at, :atDate)-fe.found_at) * 24 +
		DATE_PART ('hour', COALESCE (fe.expired_at, :atDate)-fe.found_at)
        {{ else }}
		DATE_PART ('day', COALESCE (fe.expired_at, NOW())-fe.found_at) * 24 +
		DATE_PART ('hour', COALESCE (fe.expired_at, NOW())-fe.found_at)
        {{ end }}
        )) AS exposure
        FROM finding_exposures fe
        INNER JOIN findings f ON fe.finding_id = f.id
        {{ if or .Tag .Tags }}
        INNER JOIN targets t ON f.target_id = t.id
        INNER JOIN target_tags tt ON t.id = tt.target_id
        {{ end }} 
        WHERE f.status <> 'FALSE_POSITIVE'
		/* Ignore invalidated findings */
		AND f.status != 'INVALIDATED'
        {{ if .AtDate }}
        AND fe.found_at <= :atDate
        {{ end }}
        {{ if .MinScore }}
        AND f.score >= :minScore
        {{ end }}
        {{ if .MaxScore }}
        AND f.score <= :maxScore
        {{ end }}
        {{ if .Tag }} 
        AND tt.tag = :tag
        {{ end }}
		{{ if .Tags }}
		AND tt.tag = ANY (:tags)
		{{ end }}
        GROUP BY fe.finding_id
    )
	SELECT
	COALESCE (PERCENTILE_CONT (0.10) WITHIN GROUP (ORDER BY exposure), 0) as percentile_10,
	COALESCE (PERCENTILE_CONT (0.25) WITHIN GROUP (ORDER BY exposure), 0) as percentile_25,
	COALESCE (PERCENTILE_CONT (0.50) WITHIN GROUP (ORDER BY exposure), 0) as percentile_50,
	COALESCE (PERCENTILE_CONT (0.75) WITHIN GROUP (ORDER BY exposure), 0) as percentile_75,
	COALESCE (PERCENTILE_CONT (0.90) WITHIN GROUP (ORDER BY exposure), 0) as percentile_90,
	COALESCE (AVG (exposure), 0) as mean
	FROM exposures;
	`, filter)
	if err != nil {
		return model.StatsExposure{}, err
	}

	args := map[string]interface{}{
		"tag":      filter.Tag,
		"tags":     pq.Array(strings.Split(filter.Tags, ",")),
		"atDate":   filter.AtDate,
		"minScore": filter.MinScore,
		"maxScore": filter.MaxScore,
	}

	logQuery(db.Logger, "StatsExposure", exposureQuery, args)
	nstmt, err := db.DB.PrepareNamed(exposureQuery)
	if err != nil {
		return model.StatsExposure{}, err
	}
	defer nstmt.Close()

	exposureStats := model.StatsExposure{}
	err = nstmt.Get(&exposureStats, args)
	if err != nil {
		return model.StatsExposure{}, err
	}

	return exposureStats, nil
}

// StatsCurrentExposure returns the current exposure times by diferent averages.
func (db DB) StatsCurrentExposure(filter storage.Filter) (model.StatsExposure, error) {
	currExposureQuery, err := filterTemplate(`
	WITH exposures as (
        SELECT fe.finding_id,
		DATE_PART ('day', NOW()-fe.found_at) * 24 +
		DATE_PART ('hour', NOW()-fe.found_at)
        AS exposure
        FROM finding_exposures fe
        INNER JOIN findings f ON fe.finding_id = f.id
        {{ if or .Tag .Tags }}
        INNER JOIN targets t ON f.target_id = t.id
        INNER JOIN target_tags tt ON t.id = tt.target_id
        {{ end }}
		{{ if .Labels }}
		INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		{{ end }}
        WHERE f.status <> 'FALSE_POSITIVE'
		/* Ignore invalidated findings */
		AND f.status != 'INVALIDATED'
        AND fe.fixed_at IS NULL
		AND fe.expired_at IS NULL
		{{ if .MinScore }}
        AND f.score >= :minScore
        {{ end }}
        {{ if .MaxScore }}
        AND f.score <= :maxScore
        {{ end }}
        {{ if .Tag }} 
        AND tt.tag = :tag
        {{ end }}
		{{ if .Tags }}
		AND tt.tag = ANY (:tags)
		{{ end }}
		{{ if .Labels }}
		AND il.label = ANY (:labels)
		{{ end }}
    )
	SELECT
	COALESCE (PERCENTILE_CONT (0.10) WITHIN GROUP (ORDER BY exposure), 0) as percentile_10,
	COALESCE (PERCENTILE_CONT (0.25) WITHIN GROUP (ORDER BY exposure), 0) as percentile_25,
	COALESCE (PERCENTILE_CONT (0.50) WITHIN GROUP (ORDER BY exposure), 0) as percentile_50,
	COALESCE (PERCENTILE_CONT (0.75) WITHIN GROUP (ORDER BY exposure), 0) as percentile_75,
	COALESCE (PERCENTILE_CONT (0.90) WITHIN GROUP (ORDER BY exposure), 0) as percentile_90,
	COALESCE (AVG (exposure), 0) as mean
	FROM exposures;
	`, filter)
	if err != nil {
		return model.StatsExposure{}, err
	}

	args := map[string]interface{}{
		"tag":      filter.Tag,
		"tags":     pq.Array(strings.Split(filter.Tags, ",")),
		"minScore": filter.MinScore,
		"maxScore": filter.MaxScore,
		"labels":   pq.Array(strings.Split(filter.Labels, ",")),
	}

	logQuery(db.Logger, "StatsCurrentExposure", currExposureQuery, args)
	nstmt, err := db.DB.PrepareNamed(currExposureQuery)
	if err != nil {
		return model.StatsExposure{}, err
	}
	defer nstmt.Close()

	currExposureStats := model.StatsExposure{}
	err = nstmt.Get(&currExposureStats, args)
	if err != nil {
		return model.StatsExposure{}, err
	}

	return currExposureStats, nil
}

// StatsAssetsPerSeverity returns the number of assets per severity taking into account
// the open vulnerability with highest score from the ones associated with the target.
func (db DB) StatsAssetsPerSeverity(filter storage.Filter) (model.StatsAssetsSeverity, error) {
	assetsPerSeverity := model.StatsAssetsSeverity{}

	assetsPerSeverityQuery, err := filterTemplate(`
	SELECT
	COALESCE(SUM(CASE WHEN ff.score = 0 THEN 1 ELSE 0 END), 0) AS informational,
	COALESCE(SUM(CASE WHEN ff.score > 0 AND score < 4 THEN 1 ELSE 0 END), 0) AS low,
	COALESCE(SUM(CASE WHEN ff.score >= 4 AND score < 7 THEN 1 ELSE 0 END), 0) AS medium,
	COALESCE(SUM(CASE WHEN ff.score >= 7 AND score < 9 THEN 1 ELSE 0 END), 0) AS high,
	COALESCE(SUM(CASE WHEN ff.score >= 9 THEN 1 ELSE 0 END), 0) AS critical,
	COALESCE(MAX(ft.total), 0) AS total /* total value will be the same for every row on join */
	FROM (
		SELECT DISTINCT(f.target_id), MAX(f.score) AS score
		FROM findings f
		{{ if or .Tag .Tags }}
		INNER JOIN target_tags tt ON f.target_id = tt.target_id
		{{ end }}
		{{ if .Identifiers }}
		INNER JOIN targets t ON f.target_id = t.id
		{{ end }}
		{{ if .Labels }}
		INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		{{ end }}
		WHERE
		/* Ignore findings marked as false positive */
		f.status != 'FALSE_POSITIVE'
		/* Ignore invalidated findings */
		AND f.status != 'INVALIDATED'
		{{ if .Tag }}
		AND tt.tag = :tag
		{{ end }}
		{{ if .Tags }}
		AND tt.tag = ANY (:tags)
		{{ end }}
		{{ if .Identifiers }}
		AND t.identifier = ANY (:identifiers)
		{{ end }}
		{{ if .Labels }}
		AND il.label = ANY (:labels)
		{{ end }}
		AND f.status = 'OPEN'
		GROUP BY f.target_id
	) ff
	JOIN
	(
		SELECT COUNT(DISTINCT t.id) as total
		FROM targets t
		{{ if or .Tag .Tags }}
		INNER JOIN target_tags tt ON t.id = tt.target_id
		{{ end }}
		WHERE 1=1
		{{ if .Tag }}
		AND tt.tag = :tag
		{{ end }}
		{{ if .Tags }}
		AND tt.tag = ANY (:tags)
		{{ end }}
		{{ if .Identifiers }}
		AND t.identifier = ANY (:identifiers)
		{{ end }}
	) AS ft ON true
	`, filter)
	if err != nil {
		return model.StatsAssetsSeverity{}, err
	}

	// Param names can not contain as prefix a previously defined
	// variable name to avoid collisions when processing stmts
	args := map[string]interface{}{
		"tag":         filter.Tag,
		"tags":        pq.Array(strings.Split(filter.Tags, ",")),
		"identifiers": pq.Array(strings.Split(filter.Identifiers, ",")),
		"labels":      pq.Array(strings.Split(filter.Labels, ",")),
	}

	logQuery(db.Logger, "StatsAssetsPerSeverity", assetsPerSeverityQuery, args)
	nstmt, err := db.DB.PrepareNamed(assetsPerSeverityQuery)
	if err != nil {
		return model.StatsAssetsSeverity{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&assetsPerSeverity, args)
	if err != nil {
		return model.StatsAssetsSeverity{}, err
	}

	return assetsPerSeverity, nil
}
