/*
Copyright 2020 Adevinta
*/

package postgresql

import (
	"time"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
)

const (
	iso8601DateFmt = "2006-01-02"
)

// StatsSize returns statistics about the size of each data set.
func (db DB) StatsSize() (model.StatsSize, error) {
	size := model.StatsSize{}

	query := `
	SELECT
	(SELECT COUNT(id) FROM sources) as sources,
	(SELECT COUNT(id) FROM targets) as targets,
	(SELECT COUNT(id) FROM issues) as issues,
	(SELECT COUNT(id) FROM findings) as findings,
	(SELECT COUNT(id) FROM finding_events) as finding_events
	`
	logQuery(db.Logger, "StatsSize", query)
	err := db.DB.Get(&size, query)
	if err != nil {
		return model.StatsSize{}, err
	}

	return size, nil
}

// StatsOpenIssues returns statistics about the number of OPEN findings for each issue severity.
func (db DB) StatsOpenIssues(filter storage.Filter) (model.StatsIssueSeverity, error) {
	openIssues := model.StatsIssueSeverity{}

	openIssuesQuery, err := filterTemplate(`
	SELECT
	COALESCE(SUM(CASE WHEN score = 0 THEN 1 ELSE 0 END), 0) AS informational,
	COALESCE(SUM(CASE WHEN score > 0 AND score < 4 THEN 1 ELSE 0 END), 0) AS low,
	COALESCE(SUM(CASE WHEN score >= 4 AND score < 7 THEN 1 ELSE 0 END), 0) AS medium,
	COALESCE(SUM(CASE WHEN score >= 7 AND score < 9 THEN 1 ELSE 0 END), 0) AS high,
	COALESCE(SUM(CASE WHEN score >= 9 THEN 1 ELSE 0 END), 0) AS critical
	FROM ( 
		SELECT f.id, f.score as score FROM findings f
		{{ if or .AtDate .MinDate .MaxDate }}
		INNER JOIN finding_exposures fexp ON fexp.finding_id = f.id
		{{ end }}
		{{ if .Tag }}
		INNER JOIN target_tags tt ON f.target_id = tt.target_id
		{{ end }}
		WHERE 1=1
		/* Ignore findings marked as false positive	*/
		AND f.status != 'FALSE_POSITIVE'
		{{ if .AtDate }}
			AND fexp.found_at <= :atDate
			AND (
				/* 	It is not fixed nor expired,
					or was fixed after atDate param,
					or was expired after atDate param
				*/ 
				(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL) 
				OR fexp.fixed_at >= :atDate
				OR fexp.expired_at >= :atDate
			)
		{{ else }}
			{{ if and (not .MaxDate) (not .MinDate) }}
			AND f.status = 'OPEN'
			{{ else }}
				{{ if .MaxDate }}
				AND fexp.found_at <= :maxDate
				{{ end }}
				{{ if .MinDate }}
				AND fexp.found_at >= :minDate
				{{ end }}
			{{ end }}
		{{ end }}
		{{ if .Tag }}
		AND tt.tag = :tag
		{{ end }}
		{{ if or .AtDate .MinDate .MaxDate }}
		GROUP BY f.id
		{{ end }}
	) filtered_findings
	`, filter)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}

	args := map[string]interface{}{
		"tag":     filter.Tag,
		"minDate": filter.MinDate,
		"maxDate": filter.MaxDate,
		"atDate":  filter.AtDate,
	}

	logQuery(db.Logger, "StatsOpenIssues", openIssuesQuery, args)
	nstmt, err := db.DB.PrepareNamed(openIssuesQuery)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&openIssues, args)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}

	return openIssues, nil
}

// StatsFixedIssues returns statistics about the number of FIXED findings for each issue severity.
func (db DB) StatsFixedIssues(filter storage.Filter) (model.StatsIssueSeverity, error) {
	fixedIssues := model.StatsIssueSeverity{}

	fixedIssuesQuery, err := filterTemplate(`
	SELECT
	COALESCE(SUM(CASE WHEN score = 0 THEN 1 ELSE 0 END), 0) AS informational,
	COALESCE(SUM(CASE WHEN score > 0 AND score < 4 THEN 1 ELSE 0 END), 0) AS low,
	COALESCE(SUM(CASE WHEN score >= 4 AND score < 7 THEN 1 ELSE 0 END), 0) AS medium,
	COALESCE(SUM(CASE WHEN score >= 7 AND score < 9 THEN 1 ELSE 0 END), 0) AS high,
	COALESCE(SUM(CASE WHEN score >= 9 THEN 1 ELSE 0 END), 0) AS critical
	FROM ( 
		SELECT f.id, f.score as score FROM findings f
		{{ if or .AtDate .MinDate .MaxDate }}
		INNER JOIN finding_exposures fexp ON fexp.finding_id = f.id
		{{ end }}
		{{ if .Tag }}
		INNER JOIN target_tags tt ON f.target_id = tt.target_id
		{{ end }}
		WHERE 1=1
		/* Ignore expired findings */
		AND f.status != 'EXPIRED'
		{{ if or .AtDate .MaxDate .MinDate }}
			{{ if .AtDate }}
				AND fexp.fixed_at < :atDate
				AND NOT EXISTS(
					SELECT finding_id FROM finding_exposures fexp2 
					WHERE fexp2.finding_id = fexp.finding_id 
					AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :atDate
				)
			{{ else }}
				AND fexp.fixed_at <= :maxDate
				AND NOT EXISTS(
					SELECT finding_id FROM finding_exposures fexp2 
					WHERE fexp2.finding_id = fexp.finding_id 
					AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :maxDate
				)
				{{ if .MinDate }}
				AND fexp.fixed_at >= :minDate
				{{ end }}
			{{ end }}
		{{ else }}
			AND f.status = 'FIXED'
		{{ end }}
		{{ if .Tag }}
		AND tt.tag = :tag
		{{ end }}
		{{ if or .AtDate .MinDate .MaxDate }}
		GROUP BY f.id
		{{ end }}
	) filtered_findings
	`, filter)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}

	// If min date is set, but max date is not specified
	// set max date refference to current time.
	if filter.MinDate != "" && filter.MaxDate == "" {
		filter.MaxDate = time.Now().UTC().Format(iso8601DateFmt)
	}

	args := map[string]interface{}{
		"tag":     filter.Tag,
		"minDate": filter.MinDate,
		"maxDate": filter.MaxDate,
		"atDate":  filter.AtDate,
	}

	logQuery(db.Logger, "StatsFixedIssues", fixedIssuesQuery, args)
	nstmt, err := db.DB.PrepareNamed(fixedIssuesQuery)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&fixedIssues, args)
	if err != nil {
		return model.StatsIssueSeverity{}, err
	}

	return fixedIssues, nil
}

// StatsIssues returns a list of aggregated issues from a set of finding events.
func (db DB) StatsIssues(filter storage.Filter) ([]model.Issue, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)
	listQuery, err := filterTemplate(`
	WITH query as (
		SELECT i.*,
		COUNT(f.id) filter (WHERE f.status='FIXED') AS fixed,
		COUNT(f.status) FILTER (WHERE f.status='OPEN') AS open
		FROM issues i JOIN findings f ON f.issue_id=i.id
		WHERE EXISTS(
			SELECT * FROM sources s JOIN source_issues si ON si.source_id=s.id
			WHERE si.issue_id=f.issue_id AND s.target_id=f.target_id
				{{ if .MinDate }} AND s.time >= :minDate {{ end }}
				{{ if .MaxDate }} AND s.time <= :maxDate {{ end }}
		)
		{{ if .MinScore }} AND f.score >= :minScore {{ end }}
		{{ if .MaxScore }} AND f.score <= :maxScore {{ end }}
		GROUP BY i.id
	)
	SELECT q.*,t.total as total FROM ( SELECT * FROM query LIMIT :limit OFFSET :offset) q  
	JOIN (SELECT COUNT(*) as total FROM query) AS t  ON true
	`, filter)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}

	args := map[string]interface{}{
		"minDate":  filter.MinDate,
		"maxDate":  filter.MaxDate,
		"minScore": filter.MinScore,
		"maxScore": filter.MaxScore,
		"limit":    filter.Size,
		"offset":   offset,
	}
	type resHolder struct {
		model.Issue
		storage.Pagination
	}
	res := []resHolder{}
	logQuery(db.Logger, "ListIssuesFromFindingEvents", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&res, args)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}

	var size int
	issues := []model.Issue{}
	if len(res) > 0 {
		size = res[0].Total
	}
	for _, r := range res {
		issues = append(issues, r.Issue)
	}

	return issues, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// StatsMTTR returns the mean time to remediate by issue severity.
func (db DB) StatsMTTR(filter storage.Filter) (model.StatsMTTRSeverity, error) {
	mttrQuery, err := filterTemplate(`
	WITH exposures as (
		SELECT fe.ttr as ttr, f.score as score
		FROM finding_exposures fe
		INNER JOIN findings f ON fe.finding_id = f.id
		{{ if .Tag }}
		INNER JOIN targets t ON f.target_id = t.id
		INNER JOIN target_tags tt ON t.id = tt.target_id
		{{ end }}
		WHERE fe.ttr IS NOT NULL
		{{ if .MinDate }} AND fe.fixed_at >= :minDate {{ end }}
		{{ if .MaxDate }} AND fe.fixed_at <= :maxDate {{ end }}
		{{ if .Tag }} AND tt.tag = :tag {{ end }}
	)
	SELECT CASE
		WHEN score = 0 THEN 'informational'
		WHEN score > 0 AND score < 4 THEN 'low'
		WHEN score >= 4 AND score < 7 THEN 'medium'
		WHEN score >= 7 AND score < 9 THEN 'high'
		WHEN score >= 9 THEN 'critical'
	END AS severity, AVG(ttr)
	FROM exposures
	GROUP BY severity
	UNION
	SELECT 'total', COALESCE (AVG(ttr), 0)
	FROM exposures
	`, filter)
	if err != nil {
		return model.StatsMTTRSeverity{}, err
	}

	args := map[string]interface{}{
		"tag":     filter.Tag,
		"minDate": filter.MinDate,
		"maxDate": filter.MaxDate,
	}

	logQuery(db.Logger, "StatsMTTR", mttrQuery, args)
	nstmt, err := db.DB.PrepareNamed(mttrQuery)
	if err != nil {
		return model.StatsMTTRSeverity{}, err
	}
	defer nstmt.Close()
	rows, err := nstmt.Queryx(args)
	if err != nil {
		return model.StatsMTTRSeverity{}, err
	}

	mttrStats := model.StatsMTTRSeverity{}

	for rows.Next() {
		var severity string
		var mttr float32

		err = rows.Scan(&severity, &mttr)
		if err != nil {
			return model.StatsMTTRSeverity{}, err
		}

		switch severity {
		case "total":
			mttrStats.Total = mttr
		case "informational":
			mttrStats.Informational = mttr
		case "low":
			mttrStats.Low = mttr
		case "medium":
			mttrStats.Medium = mttr
		case "high":
			mttrStats.High = mttr
		case "critical":
			mttrStats.Critical = mttr
		}
	}

	return mttrStats, nil
}

// StatsExposure returns the exposure times by diferent averages.
func (db DB) StatsExposure(filter storage.Filter) (model.StatsExposure, error) {
	exposureQuery, err := filterTemplate(`
	WITH exposures as (
        SELECT fe.finding_id, SUM(COALESCE (fe.ttr,
          DATE_PART ('day', COALESCE (fe.expired_at, NOW())-fe.found_at) * 24 +
          DATE_PART ('hour', COALESCE (fe.expired_at, NOW())-fe.found_at)
        )) AS exposure
        FROM finding_exposures fe
        INNER JOIN findings f ON fe.finding_id = f.id
        {{ if .AtDate }}
        INNER JOIN finding_exposures fexp ON fexp.finding_id = f.id
        {{ end }}
        {{ if .Tag }} 
        INNER JOIN targets t ON f.target_id = t.id
        INNER JOIN target_tags tt ON t.id = tt.target_id
        {{ end }} 
        WHERE f.status <> 'FALSE_POSITIVE'
        {{ if .AtDate }}
        AND fexp.found_at <= :atDate
        {{ end }}
        {{ if .MinScore }}
        AND f.score >= :minScore
        {{ end }}
        {{ if .MaxScore }}
        AND f.score <= :maxScore
        {{ end }}
        {{ if .Tag }} 
        AND tt.tag = :tag
        {{ end }}
		GROUP BY fe.finding_id
    )
	SELECT COALESCE (PERCENTILE_CONT (0.10) WITHIN GROUP (ORDER BY exposure), 0) as percentile_10,
	COALESCE (PERCENTILE_CONT (0.25) WITHIN GROUP (ORDER BY exposure), 0) as percentile_25,
	COALESCE (PERCENTILE_CONT (0.50) WITHIN GROUP (ORDER BY exposure), 0) as percentile_50,
	COALESCE (PERCENTILE_CONT (0.75) WITHIN GROUP (ORDER BY exposure), 0) as percentile_75,
	COALESCE (PERCENTILE_CONT (0.90) WITHIN GROUP (ORDER BY exposure), 0) as percentile_90,
	COALESCE (AVG (exposure), 0) as mean
	FROM exposures;
	`, filter)
	if err != nil {
		return model.StatsExposure{}, err
	}

	args := map[string]interface{}{
		"tag":      filter.Tag,
		"atDate":   filter.AtDate,
		"minScore": filter.MinScore,
		"maxScore": filter.MaxScore,
	}

	logQuery(db.Logger, "StatsExposure", exposureQuery, args)
	nstmt, err := db.DB.PrepareNamed(exposureQuery)
	if err != nil {
		return model.StatsExposure{}, err
	}
	defer nstmt.Close()

	exposureStats := model.StatsExposure{}
	err = nstmt.Get(&exposureStats, args)
	if err != nil {
		return model.StatsExposure{}, err
	}

	return exposureStats, nil
}
