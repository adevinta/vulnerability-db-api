/*
Copyright 2020 Adevinta
*/

package postgresql

import (
	"database/sql"
	"strings"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/lib/pq"
)

// ListIssues returns a filtered list of issues.
func (db DB) ListIssues(filter storage.Filter) ([]model.Issue, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	SELECT * FROM issues
	LIMIT :limit OFFSET :offset
	`, filter)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	SELECT COUNT(id) FROM issues
	`, filter)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}

	args := map[string]interface{}{
		"limit":  filter.Size,
		"offset": offset,
	}

	issues := []model.Issue{}
	logQuery(db.Logger, "ListIssues", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&issues, args)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}
	for i, issue := range issues {
		labels, err := db.getIssueLabels(issue.ID)
		if err != nil {
			return []model.Issue{}, storage.Pagination{}, err
		}
		issues[i].Labels = labels
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.Issue{}, storage.Pagination{}, err
	}

	return issues, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// GetIssue returns a specific issue.
func (db DB) GetIssue(id string) (model.Issue, error) {
	var issue model.Issue
	query := "SELECT * FROM issues WHERE id = $1"
	logQuery(db.Logger, "GetIssue", query, id)
	err := db.DB.Get(&issue, query, id)
	if err == sql.ErrNoRows {
		return model.Issue{}, nil
	}
	if err != nil {
		return model.Issue{}, err
	}

	labels, err := db.getIssueLabels(issue.ID)
	if err != nil {
		return model.Issue{}, err
	}
	issue.Labels = labels

	return issue, nil
}

func (db DB) getIssueLabels(id string) ([]string, error) {
	var labels []string
	query := "SELECT label FROM issue_labels WHERE issue_id = $1"
	logQuery(db.Logger, "getIssueLabels", query, id)
	err := db.DB.Select(&labels, query, id)
	return labels, err
}

// GetIssueMTTR returns the mean time to remediate a specific issue.
func (db DB) GetIssueMTTR(id string) (float32, error) {
	var mttr float32
	query := `
	SELECT COALESCE(AVG(fe.ttr), 0)
	FROM finding_exposures fe
	INNER JOIN findings f
	ON f.id = fe.finding_id
	WHERE f.issue_id = $1
	AND fe.ttr IS NOT NULL
	`
	logQuery(db.Logger, "GetIssueMTTR", query, id)
	err := db.DB.Get(&mttr, query, id)
	if err == sql.ErrNoRows {
		return 0, nil
	}
	if err != nil {
		return 0, err
	}

	return mttr, nil
}

// IssuesSummary returns a filtered list of issues.
func (db DB) IssuesSummary(filter storage.Filter) ([]model.IssueSummary, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		select finding_id
		from findings f
		INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
		{{ if .Tag }}
		INNER JOIN target_tags tt ON f.target_id = tt.target_id
		{{ end }}
		{{ if .Identifiers }}
		INNER JOIN targets t ON f.target_id = t.id
		{{ end }}
		where 1=1
			{{ if .Tag }}
			AND tt.tag = :tag
			{{ end }}
			{{ if .TargetID }}
			AND f.target_id = :targetID
			{{ end }}
			{{ if .Identifiers }}
			AND t.identifier = ANY (:identifiers)
			{{ end }}
			{{ if .AtDate }}
				{{ if .Status }}
					{{ if eq .Status "OPEN" }}
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						AND fexp.found_at <= :atDate
						AND (
							/* 	It is not fixed nor expired,
								or was fixed after atDate param,
								or was expired after atDate param
							*/ 
							(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL) 
							OR fexp.fixed_at >= :atDate
							OR fexp.expired_at >= :atDate
						)
					{{ end }}
					{{ if eq .Status "FIXED" }}
						/* Ignore expired findings */
						AND f.status != 'EXPIRED'
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						/* It was fixed before atDate param */
						AND fexp.fixed_at < :atDate
						/* And there is not a posterior finding_exposure row with found_at before atDate */
						AND NOT EXISTS(
							SELECT finding_id FROM finding_exposures fexp2
							WHERE fexp2.finding_id = fexp.finding_id
							AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :atDate
						)
					{{ end }}
					{{ if eq .Status "FALSE_POSITIVE" }}
						AND f.status = 'FALSE_POSITIVE'
						AND fexp.found_at <= :atDate
					{{ end }}
				{{ else }}
					AND fexp.found_at <= :atDate
				{{ end }}
			{{ else }}
				{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.fixed_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.fixed_at <= :maxDate
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :maxDate
					)
					{{ else }}
					AND fexp.fixed_at IS NOT NULL
					/* Ensure that there are no entries with OPEN status after the current record */
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
					)
					{{ end }}
				{{ end }}
				{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.found_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.found_at <= :maxDate
					{{ end }}
				{{ end }}
			{{ end }}
		group by finding_id
	)
	{{ end }}
	SELECT i.id as issue_id, i.summary as summary,
	count(distinct t.id) as targets_count, max(f.score) as max_score
	FROM issues i
	INNER JOIN findings f ON f.issue_id = i.id
	INNER JOIN targets t ON f.target_id = t.id
	{{ if .Tag }}
	INNER JOIN target_tags tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .TargetID }}
	AND f.target_id = :targetID
	{{ end }}	
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	group by i.id, i.summary
	{{ if .SortBy.Field }}
	ORDER BY {{ .SortBy.Field}} {{ .SortBy.Order }}, i.id
	{{ else }}
	ORDER BY max_score desc, targets_count desc, summary asc, i.id
	{{ end }}
	LIMIT :limit
	OFFSET :offset
	`, filter)
	if err != nil {
		return []model.IssueSummary{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		select finding_id
		from findings f
			INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
			{{ if .Tag }}
			INNER JOIN target_tags tt ON f.target_id = tt.target_id
			{{ end }}
			{{ if .Identifiers }}
			INNER JOIN targets t ON f.target_id = t.id
			{{ end }}
		where 1=1
			{{ if .Tag }}
			AND tt.tag = :tag
			{{ end}}
			{{ if .TargetID }}
			AND f.target_id = :targetID
			{{ end }}
			{{ if .Identifiers }}
			AND t.identifier = ANY (:identifiers)
			{{ end }}
			{{ if .AtDate }}
				{{ if .Status }}
					{{ if eq .Status "OPEN" }}
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						AND fexp.found_at <= :atDate
						AND (
							/* 	It is not fixed nor expired,
								or was fixed after atDate param,
								or was expired after atDate param
							*/ 
							(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL) 
							OR fexp.fixed_at >= :atDate
							OR fexp.expired_at >= :atDate
						)
					{{ end }}
					{{ if eq .Status "FIXED" }}
						/* Ignore expired findings */
						AND f.status != 'EXPIRED'
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						/* It was fixed before atDate param */
						AND fexp.fixed_at < :atDate
						/* And there is not a posterior finding_exposure row with found_at before atDate */
						AND NOT EXISTS(
							SELECT * FROM finding_exposures fexp2
							WHERE fexp2.finding_id = fexp.finding_id
							AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :atDate
						)
					{{ end }}
					{{ if eq .Status "FALSE_POSITIVE" }}
						AND f.status = 'FALSE_POSITIVE'
						AND fexp.found_at <= :atDate
					{{ end }}
				{{ else }}
					AND fexp.found_at <= :atDate
				{{ end }}
			{{ else }}
				{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.fixed_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.fixed_at <= :maxDate
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :maxDate
					)
					{{ else }}
					AND fexp.fixed_at IS NOT NULL
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at IS NOT NULL
					)
					{{ end }}
				{{ end }}
				{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.found_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.found_at <= :maxDate
					{{ end }}
				{{ end }}
			{{ end }}
		group by finding_id
	)
	{{ end }}
	SELECT count(distinct i.id)
	FROM issues i
	INNER JOIN findings f ON f.issue_id = i.id
	{{ if .Tag }}
	INNER JOIN targets t ON f.target_id = t.id
	INNER JOIN target_tags tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .TargetID }}
	AND f.target_id = :targetID
	{{ end }}
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end}}
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	`, filter)
	if err != nil {
		return []model.IssueSummary{}, storage.Pagination{}, err
	}

	args := map[string]interface{}{
		"status":      filter.Status,
		"tag":         filter.Tag,
		"limit":       filter.Size,
		"offset":      offset,
		"minDate":     filter.MinDate,
		"maxDate":     filter.MaxDate,
		"atDate":      filter.AtDate,
		"targetID":    filter.TargetID,
		"identifiers": pq.Array(strings.Split(filter.Identifiers, ",")),
	}

	issues := []model.IssueSummary{}
	logQuery(db.Logger, "IssuesSummary", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.IssueSummary{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&issues, args)
	if err != nil {
		return []model.IssueSummary{}, storage.Pagination{}, err
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.IssueSummary{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.IssueSummary{}, storage.Pagination{}, err
	}

	return issues, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}
