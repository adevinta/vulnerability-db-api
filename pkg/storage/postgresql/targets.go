/*
Copyright 2020 Adevinta
*/

package postgresql

import (
	"database/sql"
	"fmt"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
)

const (
	// likeCmpFmt is the comparison fmt
	// for an SQL LIKE query.
	likeCmpFmt = "%%%s%%"
)

// ListTargets returns a paginated list of targets.
func (db DB) ListTargets(filter storage.Filter) ([]model.Target, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	SELECT t.id, t.identifier FROM targets t
	{{ if .Tag }}
	INNER JOIN target_tags tt
	ON t.id = tt.target_id
	{{ end }}
	WHERE 1=1
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .Identifier }}
		{{ if .IdentifierMatch }}
		AND t.identifier = :identifier
		{{ else }}
		AND t.identifier LIKE :identifier
		{{ end}}
	{{ end }}
	LIMIT :limit OFFSET :offset
	`, filter)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	SELECT COUNT(*) FROM targets t
	{{ if .Tag }}
	INNER JOIN target_tags tt
	ON t.id = tt.target_id
	{{ end }}
	WHERE 1=1
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .Identifier }}
		{{ if .IdentifierMatch }}
		AND t.identifier = :identifier
		{{ else }}
		AND t.identifier LIKE :identifier
		{{ end}}
	{{ end }}
	`, filter)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	// Only build SQL LIKE cmp if
	// identifier filter is set.
	var identifierCmp string
	if filter.Identifier != "" {
		if filter.IdentifierMatch {
			identifierCmp = filter.Identifier
		} else {
			identifierCmp = fmt.Sprintf(likeCmpFmt, filter.Identifier)
		}
	}

	args := map[string]interface{}{
		"tag":             filter.Tag,
		"status":          filter.Status,
		"identifier":      identifierCmp,
		"identifiermatch": filter.IdentifierMatch,
		"limit":           filter.Size,
		"offset":          offset,
	}

	targets := []model.Target{}
	logQuery(db.Logger, "ListTargets", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&targets, args)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	for i, t := range targets {
		tags, err := db.getTargetTags(t.ID)
		if err != nil {
			return []model.Target{}, storage.Pagination{}, err
		}
		targets[i].Tags = tags
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	return targets, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// GetTarget returns a specific target.
func (db DB) GetTarget(id string) (model.Target, error) {
	var target model.Target
	query := "SELECT * FROM targets WHERE id = $1"
	logQuery(db.Logger, "GetTarget", query, id)
	err := db.DB.Get(&target, query, id)
	if err == sql.ErrNoRows {
		return model.Target{}, nil
	}
	if err != nil {
		return model.Target{}, err
	}

	tags, err := db.getTargetTags(target.ID)
	if err != nil {
		return model.Target{}, err
	}
	target.Tags = tags

	return target, nil
}

// GetTargetMTTR returns the mean time to remediate findings in a specific target.
func (db DB) GetTargetMTTR(id string) (float32, error) {
	var mttr float32
	query := `
	SELECT COALESCE(AVG(fe.ttr), 0)
	FROM finding_exposures fe
	INNER JOIN findings f ON fe.finding_id = f.id
	WHERE f.target_id = $1
	AND fe.ttr IS NOT NULL`
	logQuery(db.Logger, "GetTargetMTTR", query, id)
	err := db.DB.Get(&mttr, query, id)
	if err == sql.ErrNoRows {
		return 0, nil
	}
	if err != nil {
		return 0, err
	}

	return mttr, nil
}

func (db DB) getTargetTags(id string) ([]string, error) {
	var tags []string
	query := "SELECT tag FROM target_tags WHERE target_id = $1"
	logQuery(db.Logger, "getTargetTags", query, id)
	err := db.DB.Select(&tags, query, id)
	return tags, err
}

// TargetsSummary returns a filtered list of issues.
func (db DB) TargetsSummary(filter storage.Filter) ([]model.TargetSummary, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		select finding_id
			from findings f
			INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
			{{ if .Tag }}
			INNER JOIN target_tags tt ON f.target_id = tt.target_id
			{{ end }}
		where 1=1
		{{ if .Tag }}
		AND tt.tag = :tag
		{{ end }}
		{{ if .AtDate }}
			{{ if .Status }}
				{{ if eq .Status "OPEN" }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					AND fexp.found_at <= :atDate
					AND (
						/* 	It is not fixed nor expired,
							or was fixed after atDate param,
							or was expired after atDate param
						*/
						(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
						OR fexp.fixed_at >= :atDate
						OR fexp.expired_at >= :atDate
					)
				{{ end }}
				{{ if eq .Status "FIXED" }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					/* It was fixed before atDate param */
					AND fexp.fixed_at < :atDate
					/* And there is not a posterior finding_exposure row with found_at before atDate */
					AND NOT EXISTS(
						SELECT finding_id FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :atDate
					)
				{{ end }}
			{{ else }}
				AND fexp.found_at <= :atDate
			{{ end }}
		{{ else }}
			{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
				/* Ignore expired findings */
				AND f.status != 'EXPIRED'
				/* Ignore findings marked as false positive */
				AND f.status != 'FALSE_POSITIVE'				
				{{ if .MinDate }}
				AND fexp.fixed_at >= :minDate
				{{ end }}
				{{ if .MaxDate }}
				AND fexp.fixed_at <= :maxDate
				AND NOT EXISTS(
					SELECT * FROM finding_exposures fexp2
					WHERE fexp2.finding_id = fexp.finding_id
					AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :maxDate
				)
				{{ else }}
				AND fexp.fixed_at IS NOT NULL
				/* Ensure that there are no entries with OPEN status after the current record */
				AND NOT EXISTS(
					SELECT * FROM finding_exposures fexp2
					WHERE fexp2.finding_id = fexp.finding_id
					AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
				)
				{{ end }}
			{{ end }}
			{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
				/* Ignore findings marked as false positive */
				AND f.status != 'FALSE_POSITIVE'
				{{ if .MinDate }}
				AND fexp.found_at >= :minDate
				{{ end }}
				{{ if .MaxDate }}
				AND fexp.found_at <= :maxDate
				{{ end }}
			{{ end }}
		{{ end }}
		group by finding_id
	)
	{{ end }}
	SELECT t.id as target_id, t.identifier as identifier,
	count(distinct f.id) as findings_count, max(f.score) as max_score
	FROM targets t
	INNER JOIN findings f ON f.target_id = t.id
	{{ if .Tag }}
	INNER JOIN target_tags tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	group by t.id, identifier
	ORDER BY max_score desc, findings_count desc, identifier asc
	LIMIT :limit
    OFFSET :offset
	`, filter)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		select finding_id
			from findings f
			INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
			{{ if .Tag }}
			INNER JOIN target_tags tt ON f.target_id = tt.target_id
			{{ end }}
		where 1=1
			{{ if .Tag }}
			AND tt.tag = :tag
			{{ end }}
			{{ if .AtDate }}
				{{ if .Status }}
					{{ if eq .Status "OPEN" }}
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						AND fexp.found_at <= :atDate
						AND (
							/* 	It is not fixed nor expired,
								or was fixed after atDate param,
								or was expired after atDate param
							*/
							(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
							OR fexp.fixed_at >= :atDate
							OR fexp.expired_at >= :atDate
						)
					{{ end }}
					{{ if eq .Status "FIXED" }}
						/* Ignore expired findings */
						AND f.status != 'EXPIRED'
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'						
						/* It was fixed before atDate param */
						AND fexp.fixed_at < :atDate
						/* And there is not a posterior finding_exposure row with found_at before atDate */
						AND NOT EXISTS(
							SELECT finding_id FROM finding_exposures fexp2
							WHERE fexp2.finding_id = fexp.finding_id
							AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :atDate
						)
					{{ end }}
				{{ else }}
					AND fexp.found_at <= :atDate
				{{ end }}
			{{ else }}
				{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'					
					{{ if .MinDate }}
					AND fexp.fixed_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.fixed_at <= :maxDate
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :maxDate
					)
					{{ else }}
					AND fexp.fixed_at IS NOT NULL
					/* Ensure that there are no entries with OPEN status after the current record */
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
					)
					{{ end }}
				{{ end }}
				{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.found_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.found_at <= :maxDate
					{{ end }}
				{{ end }}
			{{ end }}
		group by finding_id
	)
	{{ end }}
	SELECT COUNT(DISTINCT t.id)
	FROM targets t
	INNER JOIN findings f ON f.target_id = t.id
	{{ if .Tag }}
	INNER JOIN target_tags tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	`, filter)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	args := map[string]interface{}{
		"status":  filter.Status,
		"tag":     filter.Tag,
		"limit":   filter.Size,
		"offset":  offset,
		"minDate": filter.MinDate,
		"maxDate": filter.MaxDate,
		"atDate":  filter.AtDate,
	}

	assets := []model.TargetSummary{}
	logQuery(db.Logger, "TargetsSummary", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&assets, args)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	return assets, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// DeleteTargetTag deletes the association between a target and a tag.
func (db DB) DeleteTargetTag(targetID, tag string) error {
	query := "DELETE FROM target_tags WHERE target_id = $1 AND tag = $2"
	logQuery(db.Logger, "deleteTargetTag", query, targetID, tag)
	res, err := db.DB.Exec(query, targetID, tag)
	if err != nil {
		return err
	}
	nrows, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if nrows == 0 {
		return sql.ErrNoRows
	}
	return nil
}

// DeleteTag deletes all target associations for a tag.
func (db DB) DeleteTag(tag string) error {
	query := "DELETE FROM target_tags WHERE tag = $1"
	logQuery(db.Logger, "deleteTag", query, tag)
	res, err := db.DB.Exec(query, tag)
	if err != nil {
		return err
	}
	nrows, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if nrows == 0 {
		return sql.ErrNoRows
	}
	return nil
}
