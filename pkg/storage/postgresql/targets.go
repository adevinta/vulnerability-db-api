/*
Copyright 2020 Adevinta
*/

package postgresql

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

const (
	// likeCmpFmt is the comparison fmt
	// for an SQL LIKE query.
	likeCmpFmt = "%%%s%%"
)

// ListTargets returns a paginated list of targets.
func (db DB) ListTargets(filter storage.Filter) ([]model.Target, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	SELECT t.id, t.identifier FROM targets t
	{{ if .Tag }}
	INNER JOIN target_tags tt
	ON t.id = tt.target_id
	{{ end }}
	WHERE 1=1
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .Identifier }}
		{{ if .IdentifierMatch }}
		AND t.identifier = :identifier
		{{ else }}
		AND t.identifier LIKE :identifier
		{{ end}}
	{{ end }}
	LIMIT :limit OFFSET :offset
	`, filter)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	SELECT COUNT(*) FROM targets t
	{{ if .Tag }}
	INNER JOIN target_tags tt
	ON t.id = tt.target_id
	{{ end }}
	WHERE 1=1
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .Identifier }}
		{{ if .IdentifierMatch }}
		AND t.identifier = :identifier
		{{ else }}
		AND t.identifier LIKE :identifier
		{{ end}}
	{{ end }}
	`, filter)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	// Only build SQL LIKE cmp if
	// identifier filter is set.
	var identifierCmp string
	if filter.Identifier != "" {
		if filter.IdentifierMatch {
			identifierCmp = filter.Identifier
		} else {
			identifierCmp = fmt.Sprintf(likeCmpFmt, filter.Identifier)
		}
	}

	args := map[string]interface{}{
		"tag":             filter.Tag,
		"status":          filter.Status,
		"identifier":      identifierCmp,
		"identifiermatch": filter.IdentifierMatch,
		"limit":           filter.Size,
		"offset":          offset,
	}

	targets := []model.Target{}
	logQuery(db.Logger, "ListTargets", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&targets, args)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	for i, t := range targets {
		tags, err := db.getTargetTags(t.ID)
		if err != nil {
			return []model.Target{}, storage.Pagination{}, err
		}
		targets[i].Tags = tags
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	return targets, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// GetTarget returns a specific target.
func (db DB) GetTarget(id string) (model.Target, error) {
	var target model.Target
	query := "SELECT * FROM targets WHERE id = $1"
	logQuery(db.Logger, "GetTarget", query, id)
	err := db.DB.Get(&target, query, id)
	if err == sql.ErrNoRows {
		return model.Target{}, nil
	}
	if err != nil {
		return model.Target{}, err
	}

	tags, err := db.getTargetTags(target.ID)
	if err != nil {
		return model.Target{}, err
	}
	target.Tags = tags

	return target, nil
}

// GetTargetMTTR returns the mean time to remediate findings in a specific target.
func (db DB) GetTargetMTTR(id string) (float32, error) {
	var mttr float32
	query := `
	SELECT COALESCE(AVG(fe.ttr), 0)
	FROM finding_exposures fe
	INNER JOIN findings f ON fe.finding_id = f.id
	WHERE f.target_id = $1
	AND fe.ttr IS NOT NULL`
	logQuery(db.Logger, "GetTargetMTTR", query, id)
	err := db.DB.Get(&mttr, query, id)
	if err == sql.ErrNoRows {
		return 0, nil
	}
	if err != nil {
		return 0, err
	}

	return mttr, nil
}

func (db DB) getTargetTags(id string) ([]string, error) {
	var tags []string
	query := "SELECT tag FROM target_tags WHERE target_id = $1"
	logQuery(db.Logger, "getTargetTags", query, id)
	err := db.DB.Select(&tags, query, id)
	return tags, err
}

// CreateTarget creates the given target. If the target contains
// tags associated, these are created as part of the same transaction.
// If target or associated tags already exist, no error is returned.
func (db DB) CreateTarget(t model.Target) (model.Target, error) {
	tx, err := db.DB.BeginTxx(context.Background(), nil)
	if err != nil {
		return model.Target{}, err
	}

	var created model.Target
	var tags []uint8

	query := `
	WITH target_exists AS (
		SELECT t.*,
		(
			SELECT ARRAY_AGG(tt.tag)
			FROM target_tags tt
			WHERE t.id = tt.target_id
		) tags
		FROM targets t
		WHERE t.identifier = $1
	),
	creation_query AS (
		INSERT INTO targets (identifier)
		SELECT $1
		WHERE NOT EXISTS (SELECT 1 FROM target_exists)
		RETURNING *, ARRAY[]::text[] AS tags
	)
	SELECT * FROM target_exists
    UNION ALL
	SELECT * FROM creation_query`
	err = tx.QueryRow(query, t.Identifier).Scan(
		&created.ID, &created.Identifier, &tags,
	)
	if err != nil {
		tx.Rollback()
		return model.Target{}, err
	}

	created.Tags = []string{}
	created.Tags = append(created.Tags, t.Tags...)
	created.Tags = append(created.Tags, parseStringArray(tags)...)

	// Create associated tags if any
	if len(t.Tags) > 0 {
		for _, tag := range t.Tags {
			err = db.createTargetTag(tx, created.ID, tag)
			if err != nil {
				tx.Rollback()
				return model.Target{}, err
			}
		}
	}

	return created, tx.Commit()
}

func (db DB) createTargetTag(tx *sqlx.Tx, targetID, tag string) error {
	query := `
	WITH tag_exists AS (
		SELECT * FROM target_tags
		WHERE target_id = $1 AND tag = $2
	)
	INSERT INTO target_tags (target_id, tag)
	SELECT $1, $2
    WHERE NOT EXISTS (SELECT 1 FROM tag_exists)`
	_, err := tx.Exec(query, targetID, tag)
	return err
}

// TargetsSummary returns a filtered list of issues.
func (db DB) TargetsSummary(filter storage.Filter) ([]model.TargetSummary, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		select finding_id
			from findings f
			INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
			{{ if .Tag }}
			INNER JOIN target_tags tt ON f.target_id = tt.target_id
			{{ end }}
			{{ if .Identifiers }}
			INNER JOIN targets t ON f.target_id = t.id
			{{ end }}
		where 1=1
		{{ if .Tag }}
		AND tt.tag = :tag
		{{ end }}
		{{ if .Identifiers }}
		AND t.identifier = ANY (:identifiers)
		{{ end }}
		{{ if .AtDate }}
			{{ if .Status }}
				{{ if eq .Status "OPEN" }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					AND fexp.found_at <= :atDate
					AND (
						/* 	It is not fixed nor expired,
							or was fixed after atDate param,
							or was expired after atDate param
						*/
						(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
						OR fexp.fixed_at >= :atDate
						OR fexp.expired_at >= :atDate
					)
				{{ end }}
				{{ if eq .Status "FIXED" }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					/* It was fixed before atDate param */
					AND fexp.fixed_at < :atDate
					/* And there is not a posterior finding_exposure row with found_at before atDate */
					AND NOT EXISTS(
						SELECT finding_id FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :atDate
					)
				{{ end }}
				{{ if eq .Status "FALSE_POSITIVE" }}
					AND f.status = 'FALSE_POSITIVE'
					AND fexp.found_at <= :atDate
				{{ end }}
			{{ else }}
				AND fexp.found_at <= :atDate
			{{ end }}
		{{ else }}
			{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
				/* Ignore expired findings */
				AND f.status != 'EXPIRED'
				/* Ignore findings marked as false positive */
				AND f.status != 'FALSE_POSITIVE'				
				{{ if .MinDate }}
				AND fexp.fixed_at >= :minDate
				{{ end }}
				{{ if .MaxDate }}
				AND fexp.fixed_at <= :maxDate
				AND NOT EXISTS(
					SELECT * FROM finding_exposures fexp2
					WHERE fexp2.finding_id = fexp.finding_id
					AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :maxDate
				)
				{{ else }}
				AND fexp.fixed_at IS NOT NULL
				/* Ensure that there are no entries with OPEN status after the current record */
				AND NOT EXISTS(
					SELECT * FROM finding_exposures fexp2
					WHERE fexp2.finding_id = fexp.finding_id
					AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
				)
				{{ end }}
			{{ end }}
			{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
				/* Ignore findings marked as false positive */
				AND f.status != 'FALSE_POSITIVE'
				{{ if .MinDate }}
				AND fexp.found_at >= :minDate
				{{ end }}
				{{ if .MaxDate }}
				AND fexp.found_at <= :maxDate
				{{ end }}
			{{ end }}
		{{ end }}
		group by finding_id
	)
	{{ end }}
	SELECT t.id as target_id, t.identifier as identifier,
	count(distinct f.id) as findings_count, max(f.score) as max_score
	FROM targets t
	INNER JOIN findings f ON f.target_id = t.id
	{{ if .Tag }}
	INNER JOIN target_tags tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	group by t.id, identifier
	ORDER BY max_score desc, findings_count desc, identifier asc, t.id
	LIMIT :limit
    OFFSET :offset
	`, filter)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		select finding_id
			from findings f
			INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
			{{ if .Tag }}
			INNER JOIN target_tags tt ON f.target_id = tt.target_id
			{{ end }}
			{{ if .Identifiers }}
			INNER JOIN targets t ON f.target_id = t.id
			{{ end }}
		where 1=1
			{{ if .Tag }}
			AND tt.tag = :tag
			{{ end }}
			{{ if .Identifiers }}
			AND t.identifier = ANY (:identifiers)
			{{ end }}
			{{ if .AtDate }}
				{{ if .Status }}
					{{ if eq .Status "OPEN" }}
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						AND fexp.found_at <= :atDate
						AND (
							/* 	It is not fixed nor expired,
								or was fixed after atDate param,
								or was expired after atDate param
							*/
							(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
							OR fexp.fixed_at >= :atDate
							OR fexp.expired_at >= :atDate
						)
					{{ end }}
					{{ if eq .Status "FIXED" }}
						/* Ignore expired findings */
						AND f.status != 'EXPIRED'
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'						
						/* It was fixed before atDate param */
						AND fexp.fixed_at < :atDate
						/* And there is not a posterior finding_exposure row with found_at before atDate */
						AND NOT EXISTS(
							SELECT finding_id FROM finding_exposures fexp2
							WHERE fexp2.finding_id = fexp.finding_id
							AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :atDate
						)
					{{ end }}
					{{ if eq .Status "FALSE_POSITIVE" }}
						AND f.status = 'FALSE_POSITIVE'
						AND fexp.found_at <= :atDate
					{{ end }}
				{{ else }}
					AND fexp.found_at <= :atDate
				{{ end }}
			{{ else }}
				{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'					
					{{ if .MinDate }}
					AND fexp.fixed_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.fixed_at <= :maxDate
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :maxDate
					)
					{{ else }}
					AND fexp.fixed_at IS NOT NULL
					/* Ensure that there are no entries with OPEN status after the current record */
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
					)
					{{ end }}
				{{ end }}
				{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.found_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.found_at <= :maxDate
					{{ end }}
				{{ end }}
			{{ end }}
		group by finding_id
	)
	{{ end }}
	SELECT COUNT(DISTINCT t.id)
	FROM targets t
	INNER JOIN findings f ON f.target_id = t.id
	{{ if .Tag }}
	INNER JOIN target_tags tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	`, filter)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	args := map[string]interface{}{
		"status":      filter.Status,
		"tag":         filter.Tag,
		"limit":       filter.Size,
		"offset":      offset,
		"minDate":     filter.MinDate,
		"maxDate":     filter.MaxDate,
		"atDate":      filter.AtDate,
		"identifiers": pq.Array(strings.Split(filter.Identifiers, ",")),
	}

	assets := []model.TargetSummary{}
	logQuery(db.Logger, "TargetsSummary", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&assets, args)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	return assets, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// DeleteTargetTag deletes the association between a target and a tag.
func (db DB) DeleteTargetTag(targetID, tag string) error {
	query := "DELETE FROM target_tags WHERE target_id = $1 AND tag = $2"
	logQuery(db.Logger, "deleteTargetTag", query, targetID, tag)
	res, err := db.DB.Exec(query, targetID, tag)
	if err != nil {
		return err
	}
	nrows, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if nrows == 0 {
		return sql.ErrNoRows
	}
	return nil
}

// DeleteTag deletes all target associations for a tag.
func (db DB) DeleteTag(tag string) error {
	query := "DELETE FROM target_tags WHERE tag = $1"
	logQuery(db.Logger, "deleteTag", query, tag)
	res, err := db.DB.Exec(query, tag)
	if err != nil {
		return err
	}
	nrows, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if nrows == 0 {
		return sql.ErrNoRows
	}
	return nil
}
