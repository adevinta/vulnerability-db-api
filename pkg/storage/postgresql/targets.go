/*
Copyright 2020 Adevinta
*/

package postgresql

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

const (
	// likeCmpFmt is the comparison fmt
	// for an SQL LIKE query.
	likeCmpFmt = "%%%s%%"
)

// ListTargets returns a paginated list of targets.
func (db DB) ListTargets(filter storage.Filter) ([]model.Target, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	SELECT t.id, t.identifier FROM targets t
	{{ if .Team }}
	INNER JOIN target_teams tt
	ON t.id = tt.target_id
	{{ end }}
	WHERE 1=1
	{{ if .Team }}
	AND tt.team_id = :team
	{{ end }}
	{{ if .Identifier }}
		{{ if .IdentifierMatch }}
		AND t.identifier = :identifier
		{{ else }}
		AND t.identifier LIKE :identifier
		{{ end}}
	{{ end }}
	LIMIT :limit OFFSET :offset
	`, filter)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	SELECT COUNT(*) FROM targets t
	{{ if .Team }}
	INNER JOIN target_teams tt
	ON t.id = tt.target_id
	{{ end }}
	WHERE 1=1
	{{ if .Team }}
	AND tt.team_id = :team
	{{ end }}
	{{ if .Identifier }}
		{{ if .IdentifierMatch }}
		AND t.identifier = :identifier
		{{ else }}
		AND t.identifier LIKE :identifier
		{{ end}}
	{{ end }}
	`, filter)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	// Only build SQL LIKE cmp if
	// identifier filter is set.
	var identifierCmp string
	if filter.Identifier != "" {
		if filter.IdentifierMatch {
			identifierCmp = filter.Identifier
		} else {
			identifierCmp = fmt.Sprintf(likeCmpFmt, filter.Identifier)
		}
	}

	args := map[string]interface{}{
		"team":            filter.Team,
		"status":          filter.Status,
		"identifier":      identifierCmp,
		"identifiermatch": filter.IdentifierMatch,
		"limit":           filter.Size,
		"offset":          offset,
	}

	targets := []model.Target{}
	logQuery(db.Logger, "ListTargets", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&targets, args)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	for i, t := range targets {
		teams, err := db.getTargetTeams(t.ID)
		if err != nil {
			return []model.Target{}, storage.Pagination{}, err
		}
		targets[i].Teams = teams
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.Target{}, storage.Pagination{}, err
	}

	return targets, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// GetTarget returns a specific target.
func (db DB) GetTarget(id string) (model.Target, error) {
	var target model.Target
	query := "SELECT * FROM targets WHERE id = $1"
	logQuery(db.Logger, "GetTarget", query, id)
	err := db.DB.Get(&target, query, id)
	if err == sql.ErrNoRows {
		return model.Target{}, nil
	}
	if err != nil {
		return model.Target{}, err
	}

	teams, err := db.getTargetTeams(target.ID)
	if err != nil {
		return model.Target{}, err
	}
	target.Teams = teams

	return target, nil
}

// GetTargetMTTR returns the mean time to remediate findings in a specific target.
func (db DB) GetTargetMTTR(id string) (float32, error) {
	var mttr float32
	query := `
	SELECT COALESCE(AVG(fe.ttr), 0)
	FROM finding_exposures fe
	INNER JOIN findings f ON fe.finding_id = f.id
	WHERE f.target_id = $1
	AND fe.ttr IS NOT NULL`
	logQuery(db.Logger, "GetTargetMTTR", query, id)
	err := db.DB.Get(&mttr, query, id)
	if err == sql.ErrNoRows {
		return 0, nil
	}
	if err != nil {
		return 0, err
	}

	return mttr, nil
}

func (db DB) getTargetTeams(id string) ([]string, error) {
	var teams []string
	query := "SELECT team_id FROM target_teams WHERE target_id = $1"
	logQuery(db.Logger, "getTargetTeams", query, id)
	err := db.DB.Select(&teams, query, id)
	return teams, err
}

// CreateTarget creates the given target. If the target contains
// teams associated, these are created as part of the same transaction.
// If target or associated teams already exist, no error is returned.
func (db DB) CreateTarget(t model.Target) (model.Target, error) {
	tx, err := db.DB.BeginTxx(context.Background(), nil)
	if err != nil {
		return model.Target{}, err
	}

	var created model.Target
	var teams []uint8

	query := `
	WITH target_exists AS (
		SELECT t.*,
		(
			SELECT ARRAY_AGG(tt.team_id)
			FROM target_teams tt
			WHERE t.id = tt.target_id
		) teams,
		FROM targets t
		WHERE t.identifier = $1
	),
	creation_query AS (
		INSERT INTO targets (identifier)
		SELECT $1
		WHERE NOT EXISTS (SELECT 1 FROM target_exists)
		RETURNING *, ARRAY[]::text[] AS teams
	)
	SELECT * FROM target_exists
    UNION ALL
	SELECT * FROM creation_query`
	err = tx.QueryRow(query, t.Identifier).Scan(
		&created.ID, &created.Identifier, &teams,
	)
	if err != nil {
		tx.Rollback()
		return model.Target{}, err
	}

	// Create associated teams if any.
	created.Teams = []string{}
	created.Teams = append(created.Teams, t.Teams...)
	created.Teams = append(created.Teams, parseStringArray(teams)...)
	if len(t.Teams) > 0 {
		for _, team := range t.Teams {
			err = db.createTargetTeam(tx, created.ID, team)
			if err != nil {
				tx.Rollback()
				return model.Target{}, err
			}
		}
	}

	return created, tx.Commit()
}

func (db DB) createTargetTeam(tx *sqlx.Tx, targetID, teamID string) error {
	query := `
	WITH team_exists AS (
		SELECT * FROM target_teams
		WHERE target_id = $1 AND team_id = $2
	)
	INSERT INTO target_teams (target_id, team_id)
	SELECT $1, $2
    WHERE NOT EXISTS (SELECT 1 FROM team_exists)`
	_, err := tx.Exec(query, targetID, teamID)
	return err
}

// TargetsSummary returns a filtered list of issues.
func (db DB) TargetsSummary(filter storage.Filter) ([]model.TargetSummary, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		SELECT DISTINCT finding_id
		FROM findings f
		INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
		{{ if .Team }}
		INNER JOIN target_teams tt ON f.target_id = tt.target_id
		{{ end }}
		{{ if .Identifiers }}
		INNER JOIN targets t ON f.target_id = t.id
		{{ end }}
		{{ if .Labels }}
		INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		{{ end }}
		WHERE 1=1
		{{ if .IssueID }}
		AND f.issue_id = :issueID
		{{ end }}	
		{{ if .Team }}
		AND tt.team_id = :team
		{{ end }}
		{{ if .Identifiers }}
		AND t.identifier = ANY (:identifiers)
		{{ end }}
		{{ if .Labels }}
		AND il.label = ANY (:labels)
		{{ end }}
		{{ if .AtDate }}
			{{ if .Status }}
				{{ if eq .Status "OPEN" }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					/* Ignore invalidated findings */
					AND f.status != 'INVALIDATED'
					AND fexp.found_at <= :aDateUpBound
					AND (
						/* 	It is not fixed nor expired,
							or was fixed after atDate param,
							or was expired after atDate param
						*/
						(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
						OR fexp.fixed_at >= :atDate
						OR fexp.expired_at >= :atDate
					)
				{{ end }}
				{{ if eq .Status "FIXED" }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					/* Ignore invalidated findings */
					AND f.status != 'INVALIDATED'
					/* It was fixed before atDate param */
					AND fexp.fixed_at < :aDateUpBound
					/* And there is not a posterior finding_exposure row with found_at before atDate */
					AND NOT EXISTS(
						SELECT finding_id FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :aDateUpBound
					)
				{{ end }}
				{{ if eq .Status "FALSE_POSITIVE" }}
					AND f.status = 'FALSE_POSITIVE'
					AND fexp.found_at <= :aDateUpBound
				{{ end }}
			{{ else }}
				AND fexp.found_at <= :aDateUpBound
			{{ end }}
		{{ else }}
			{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
				/* Ignore expired findings */
				AND f.status != 'EXPIRED'
				/* Ignore findings marked as false positive */
				AND f.status != 'FALSE_POSITIVE'
				/* Ignore invalidated findings */
				AND f.status != 'INVALIDATED'				
				{{ if .MinDate }}
				AND fexp.fixed_at >= :minDate
				{{ end }}
				{{ if .MaxDate }}
				AND fexp.fixed_at <= :mxDateUpBound
				AND NOT EXISTS(
					SELECT * FROM finding_exposures fexp2
					WHERE fexp2.finding_id = fexp.finding_id
					AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :mxDateUpBound
				)
				{{ else }}
				AND fexp.fixed_at IS NOT NULL
				/* Ensure that there are no entries with OPEN status after the current record */
				AND NOT EXISTS(
					SELECT * FROM finding_exposures fexp2
					WHERE fexp2.finding_id = fexp.finding_id
					AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
				)
				{{ end }}
			{{ end }}
			{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
				/* Ignore findings marked as false positive */
				AND f.status != 'FALSE_POSITIVE'
				/* Ignore invalidated findings */
				AND f.status != 'INVALIDATED'
				{{ if .MinDate }}
				AND fexp.found_at >= :minDate
				{{ end }}
				{{ if .MaxDate }}
				AND fexp.found_at <= :mxDateUpBound
				{{ end }}
			{{ end }}
		{{ end }}
		group by finding_id
	)
	{{ end }}
	SELECT DISTINCT t.id as target_id, t.identifier as identifier,
	COUNT(DISTINCT f.id) as findings_count,
	COUNT(DISTINCT f.issue_id) as issues_count,
	max(f.score) as max_score
	FROM targets t
	INNER JOIN findings f ON f.target_id = t.id
	{{ if .Team }}
	INNER JOIN target_teams tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	{{ if .Labels }}
	INNER JOIN issue_labels il ON f.issue_id = il.issue_id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .IssueID }}
	AND f.issue_id = :issueID
	{{ end }}
	{{ if .Team }}
	AND tt.team_id = :team
	{{ end }}
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	{{ if .Labels }}
	AND il.label = ANY (:labels)
	{{ end }}
	GROUP by t.id, identifier
	{{ if .SortBy.Field }}
	ORDER BY {{ .SortBy.Field}} {{ .SortBy.Order }}, t.id
	{{ else }}
	ORDER BY max_score desc, findings_count desc, identifier asc, t.id
	{{ end }}
	LIMIT :limit
    OFFSET :offset
	`, filter)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		SELECT DISTINCT finding_id
		FROM findings f
		INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
		{{ if .Team }}
		INNER JOIN target_teams tt ON f.target_id = tt.target_id
		{{ end }}
		{{ if .Identifiers }}
		INNER JOIN targets t ON f.target_id = t.id
		{{ end }}
		{{ if .Labels }}
		INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		{{ end }}
		WHERE 1=1
			{{ if .IssueID }}
			AND f.issue_id = :issueID
			{{ end }}	
			{{ if .Team }}
			AND tt.team_id = :team
			{{ end }}
			{{ if .Identifiers }}
			AND t.identifier = ANY (:identifiers)
			{{ end }}
			{{ if .Labels }}
			AND il.label = ANY (:labels)
			{{ end }}
			{{ if .AtDate }}
				{{ if .Status }}
					{{ if eq .Status "OPEN" }}
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						/* Ignore invalidated findings */
						AND f.status != 'INVALIDATED'
						AND fexp.found_at <= :aDateUpBound
						AND (
							/* 	It is not fixed nor expired,
								or was fixed after atDate param,
								or was expired after atDate param
							*/
							(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
							OR fexp.fixed_at >= :atDate
							OR fexp.expired_at >= :atDate
						)
					{{ end }}
					{{ if eq .Status "FIXED" }}
						/* Ignore expired findings */
						AND f.status != 'EXPIRED'
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						/* Ignore invalidated findings */
						AND f.status != 'INVALIDATED'						
						/* It was fixed before atDate param */
						AND fexp.fixed_at < :aDateUpBound
						/* And there is not a posterior finding_exposure row with found_at before atDate */
						AND NOT EXISTS(
							SELECT finding_id FROM finding_exposures fexp2
							WHERE fexp2.finding_id = fexp.finding_id
							AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :aDateUpBound
						)
					{{ end }}
					{{ if eq .Status "FALSE_POSITIVE" }}
						AND f.status = 'FALSE_POSITIVE'
						AND fexp.found_at <= :aDateUpBound
					{{ end }}
				{{ else }}
					AND fexp.found_at <= :aDateUpBound
				{{ end }}
			{{ else }}
				{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					/* Ignore invalidated findings */
					AND f.status != 'INVALIDATED'					
					{{ if .MinDate }}
					AND fexp.fixed_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.fixed_at <= :mxDateUpBound
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at <= :mxDateUpBound
					)
					{{ else }}
					AND fexp.fixed_at IS NOT NULL
					/* Ensure that there are no entries with OPEN status after the current record */
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
					)
					{{ end }}
				{{ end }}
				{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					/* Ignore invalidated findings */
					AND f.status != 'INVALIDATED'
					{{ if .MinDate }}
					AND fexp.found_at >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.found_at <= :mxDateUpBound
					{{ end }}
				{{ end }}
			{{ end }}
	)
	{{ end }}
	SELECT COUNT(DISTINCT t.id)
	FROM targets t
	INNER JOIN findings f ON f.target_id = t.id
	{{ if .Team }}
	INNER JOIN target_teams tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	{{ if .Labels }}
	INNER JOIN issue_labels il ON f.issue_id = il.issue_id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .IssueID }}
	AND f.issue_id = :issueID
	{{ end }}
	{{ if .Team }}
	AND tt.team_id = :team
	{{ end }}
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	{{ if .Labels }}
	AND il.label = ANY (:labels)
	{{ end }}
	`, filter)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	args := map[string]interface{}{
		"status":        filter.Status,
		"team":          filter.Team,
		"limit":         filter.Size,
		"offset":        offset,
		"minDate":       filter.MinDate,
		"maxDate":       filter.MaxDate,
		"mxDateUpBound": fmt.Sprint(filter.MaxDate, dateUpBoundOffset),
		"atDate":        filter.AtDate,
		"aDateUpBound":  fmt.Sprint(filter.AtDate, dateUpBoundOffset),
		"issueID":       filter.IssueID,
		"identifiers":   pq.Array(strings.Split(filter.Identifiers, ",")),
		"labels":        pq.Array(strings.Split(filter.Labels, ",")),
	}

	assets := []model.TargetSummary{}
	logQuery(db.Logger, "TargetsSummary", listQuery, args)
	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Select(&assets, args)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.TargetSummary{}, storage.Pagination{}, err
	}

	return assets, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// DeleteTargetTeam deletes the association between a target and a team.
func (db DB) DeleteTargetTeam(targetID, teamID string) error {
	query := "DELETE FROM target_teams WHERE target_id = $1 AND team_id = $2"
	logQuery(db.Logger, "deleteTargetTeam", query, targetID, teamID)
	res, err := db.DB.Exec(query, targetID, teamID)
	if err != nil {
		return err
	}
	nrows, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if nrows == 0 {
		return sql.ErrNoRows
	}
	return nil
}

// DeleteTeam deletes all target associations for a team.
func (db DB) DeleteTeam(teamID string) error {
	query := "DELETE FROM target_teams WHERE team_id = $1"
	logQuery(db.Logger, "deleteTeam", query, teamID)
	res, err := db.DB.Exec(query, teamID)
	if err != nil {
		return err
	}
	nrows, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if nrows == 0 {
		return sql.ErrNoRows
	}
	return nil
}
