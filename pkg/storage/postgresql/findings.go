/*
Copyright 2020 Adevinta
*/

package postgresql

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/adevinta/vulnerability-db-api/pkg/model"
	"github.com/adevinta/vulnerability-db-api/pkg/storage"
	"github.com/lib/pq"
)

var (
	// ErrParsingFinding indicates an error when parsing finding data retrieved from database.
	ErrParsingFinding = errors.New("Error parsing finding data")
)

const (
	statusOpen          = "OPEN"
	statusFixed         = "FIXED"
	statusExpired       = "EXPIRED"
	statusFalsePositive = "FALSE_POSITIVE"

	dateFmt     = "2006-01-02"
	dateTimeFmt = "2006-01-02 15:04:05"
)

// ListFindings returns a filtered list of findings.
func (db DB) ListFindings(filter storage.Filter) ([]model.FindingExpanded, storage.Pagination, error) {
	offset := storage.Offset(filter.Page, filter.Size)

	listQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		SELECT DISTINCT finding_id
		  FROM findings f
		  INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
		  {{ if .Tag }}
		  INNER JOIN target_tags tt ON tt.target_id = f.target_id
		  {{ end }}
		  {{ if .Identifiers }}
		  INNER JOIN targets t ON f.target_id = t.id
		  {{ end }}
		  {{ if .Labels }}
		  INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		  {{ end }}
		 WHERE 1=1
			{{ if .TargetID }}
			AND f.target_id = :targetID
			{{ end }}
			{{ if .IssueID }}
			AND f.issue_id = :issueID
			{{ end }}
			{{ if .Tag }}
			AND tt.tag = :tag
			{{ end }}
			{{ if .Identifiers }}
			AND t.identifier = ANY (:identifiers)
			{{ end }}
			{{ if .Labels }}
			AND il.label = ANY (:labels)
			{{ end }}
			{{ if .AtDate }}
				{{ if .Status }}
					{{ if eq .Status "OPEN" }}
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						AND fexp.found_at::date <= :atDate
						AND (
							/* 	It is not fixed nor expired,
							   	or was fixed after atDate param,
							   	or was expired after atDate param
							*/
							(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
							OR fexp.fixed_at::date >= :atDate
							OR fexp.expired_at::date >= :atDate
						)
					{{ end }}
					{{ if eq .Status "FIXED" }}
						/* Ignore expired findings */
						AND f.status != 'EXPIRED'
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						/* It was fixed before atDate param */
						AND fexp.fixed_at::date < :atDate
						/* And there is not a posterior finding_exposure row with found_at before atDate */
						AND NOT EXISTS(
							SELECT finding_id FROM finding_exposures fexp2
							WHERE fexp2.finding_id = fexp.finding_id
							AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at::date <= :atDate
						)
					{{ end }}
					{{ if eq .Status "FALSE_POSITIVE" }}
						AND f.status = 'FALSE_POSITIVE'
						AND fexp.found_at::date <= :atDate
					{{ end }}
				{{ else }}
					AND fexp.found_at::date <= :atDate
				{{ end }}
			{{ else }}
				{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.fixed_at::date >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.fixed_at::date <= :maxDate
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at::date <= :maxDate
					)
					{{ else }}
					AND fexp.fixed_at IS NOT NULL
					/* Ensure that there are no entries with OPEN status after the current record */
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.fixed_at IS NULL
					)
					{{ end }}
				{{ end }}
				{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.found_at::date >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.found_at::date <= :maxDate
					{{ end }}
				{{ end }}
			{{ end }}
	)
	{{ end }}
	SELECT DISTINCT f.id AS finding_id, s.id AS source_id,
	f.issue_id, f.target_id, f.affected_resource, f.status, f.details, f.impact_details, f.resources, f.score,
	s.name, s.component, s.instance, s.options, s.time,
	i.*, t.*,
	(SELECT ARRAY_AGG(tt.tag) FROM target_tags tt WHERE t.id = tt.target_id) tags,
	(SELECT ARRAY_AGG(found_at) FROM finding_exposures WHERE finding_id = f.id) as found_at,
	(SELECT ARRAY_AGG(fixed_at) FROM finding_exposures WHERE finding_id = f.id) as fixed_at,
	(SELECT ARRAY_AGG(expired_at) FROM finding_exposures WHERE finding_id = f.id) as expired_at,
	(SELECT ARRAY_AGG(il.label) FROM issue_labels il WHERE il.issue_id = f.issue_id) labels
	FROM findings f
	INNER JOIN issues i ON f.issue_id = i.id
	INNER JOIN targets t ON f.target_id = t.id
	{{ if .Tag }}
	INNER JOIN target_tags tt ON t.id = tt.target_id
	{{ end }}
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	INNER JOIN last_sources ls ON f.id = ls.finding_id
	INNER JOIN sources s ON s.id = ls.source_id
	{{ if .SourceID }}
	INNER JOIN finding_events fe_source
	        ON fe_source.finding_id = f.id
	       AND fe_source.source_id = :sourceID
	{{ end }}
	{{ if .Labels }}
	INNER JOIN issue_labels il ON i.id = il.issue_id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	{{ if .Identifier }}
		{{ if .IdentifierMatch }}
		AND t.identifier = :identifier
		{{ else }}
		AND t.identifier LIKE :identifier
		{{ end}}
	{{ end }}
	{{ if .MinScore }}
	AND f.score >= :minScore
	{{ end }}
	{{ if .MaxScore }}
	AND f.score <= :maxScore
	{{ end }}
	{{ if .TargetID }}
	AND f.target_id = :targetID
	{{ end }}
	{{ if .IssueID }}
	AND f.issue_id = :issueID
	{{ end }}
	{{ if .Labels }}
	AND il.label = ANY (:labels)
	{{ end }}
	ORDER BY 
	{{ if .SortBy.Field }}
		{{ .SortBy.Field}} {{ .SortBy.Order }},
	{{ end }}
	f.id
	LIMIT :limit OFFSET :offset
	`, filter)
	if err != nil {
		return []model.FindingExpanded{}, storage.Pagination{}, err
	}

	sizeQuery, err := filterTemplate(`
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	WITH fexp as (
		SELECT DISTINCT finding_id
		FROM findings f
		  INNER JOIN finding_exposures fexp ON f.id = fexp.finding_id
		  {{ if .Tag }}
		  INNER JOIN target_tags tt ON tt.target_id = f.target_id
		  {{ end }}
		  {{ if .Identifiers }}
		  INNER JOIN targets t ON f.target_id = t.id
		  {{ end }}
		  {{ if .Labels }}
		  INNER JOIN issue_labels il ON f.issue_id = il.issue_id
		  {{ end }}
		 WHERE 1=1
			{{ if .TargetID }}
			AND f.target_id = :targetID
			{{ end }}
			{{ if .IssueID }}
			AND f.issue_id = :issueID
			{{ end }}
			{{ if .Tag }}
			AND tt.tag = :tag
			{{ end }}
			{{ if .Identifiers }}
			AND t.identifier = ANY (:identifiers)
			{{ end }}
			{{ if .AtDate }}
				{{ if .Status }}
					{{ if eq .Status "OPEN" }}
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						AND fexp.found_at::date <= :atDate
						AND (
							/* 	It is not fixed nor expired,
								or was fixed after atDate param,
								or was expired after atDate param
							*/
							(fexp.fixed_at IS NULL AND fexp.expired_at IS NULL)
							OR fexp.fixed_at::date >= :atDate
							OR fexp.expired_at::date >= :atDate
						)
					{{ end }}
					{{ if eq .Status "FIXED" }}
						/* Ignore expired findings */
						AND f.status != 'EXPIRED'
						/* Ignore findings marked as false positive */
						AND f.status != 'FALSE_POSITIVE'
						/* It was fixed before atDate param */
						AND fexp.fixed_at::date < :atDate
						/* And there is not a posterior finding_exposure row with found_at before atDate */
						AND NOT EXISTS(
							SELECT * FROM finding_exposures fexp2
							WHERE fexp2.finding_id = fexp.finding_id
							AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at::date <= :atDate
						)
					{{ end }}
					{{ if eq .Status "FALSE_POSITIVE" }}
						AND f.status = 'FALSE_POSITIVE'
						AND fexp.found_at::date <= :atDate
					{{ end }}
				{{ else }}
					AND fexp.found_at::date <= :atDate
				{{ end }}
			{{ else }}
				{{ if and (eq .Status "FIXED") (or .MinDate .MaxDate) }}
					/* Ignore expired findings */
					AND f.status != 'EXPIRED'
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.fixed_at::date >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.fixed_at::date <= :maxDate
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at::date <= :maxDate
					)
					{{ else }}
					AND fexp.fixed_at IS NOT NULL
					AND NOT EXISTS(
						SELECT * FROM finding_exposures fexp2
						WHERE fexp2.finding_id = fexp.finding_id
						AND fexp2.found_at > fexp.fixed_at AND fexp2.found_at IS NOT NULL
					)
					{{ end }}
				{{ end }}
				{{ if and (eq .Status "OPEN") (or .MinDate .MaxDate) }}
					/* Ignore findings marked as false positive */
					AND f.status != 'FALSE_POSITIVE'
					{{ if .MinDate }}
					AND fexp.found_at::date >= :minDate
					{{ end }}
					{{ if .MaxDate }}
					AND fexp.found_at::date <= :maxDate
					{{ end }}
				{{ end }}
			{{ end }}
	)
	{{ end }}
	SELECT COUNT(DISTINCT f.id) FROM findings f
	{{ if or .AtDate (or (and .Status .MinDate) (and .Status .MaxDate)) }}
	INNER JOIN fexp ON fexp.finding_id = f.id
	{{ end }}
	INNER JOIN targets t ON f.target_id = t.id
	{{ if .Tag }}
	INNER JOIN target_tags tt ON t.id = tt.target_id
	{{ end }}
	{{ if .SourceID }}
	INNER JOIN finding_events fe_source
			ON fe_source.finding_id = f.id
			AND fe_source.source_id = :sourceID
	{{ end }}
	{{ if .Labels }}
	INNER JOIN issue_labels il ON f.issue_id = il.issue_id
	{{ end }}
	WHERE 1=1
	{{ if and .Status (and (not .AtDate) (not .MinDate) (not .MaxDate)) }}
	AND f.status = :status
	{{ end }}
	{{ if .Tag }}
	AND tt.tag = :tag
	{{ end }}
	{{ if .Identifiers }}
	AND t.identifier = ANY (:identifiers)
	{{ end }}
	{{ if .Identifier }}
		{{ if .IdentifierMatch }}
		AND t.identifier = :identifier
		{{ else }}
		AND t.identifier LIKE :identifier
		{{ end}}
	{{ end }}
	{{ if .MinScore }}
	AND f.score >= :minScore
	{{ end }}
	{{ if .MaxScore }}
	AND f.score <= :maxScore
	{{ end }}
	{{ if .TargetID }}
	AND f.target_id = :targetID
	{{ end }}
	{{ if .IssueID }}
	AND f.issue_id = :issueID
	{{ end }}
	{{ if .Labels }}
	AND il.label = ANY (:labels)
	{{ end }}
	`, filter)
	if err != nil {
		return []model.FindingExpanded{}, storage.Pagination{}, err
	}

	// Only build SQL LIKE cmp if
	// identifier filter is set.
	var identifierCmp string
	if filter.Identifier != "" {
		if filter.IdentifierMatch {
			identifierCmp = filter.Identifier
		} else {
			identifierCmp = fmt.Sprintf(likeCmpFmt, filter.Identifier)
		}
	}

	args := map[string]interface{}{
		"status":          filter.Status,
		"tag":             filter.Tag,
		"minScore":        filter.MinScore,
		"maxScore":        filter.MaxScore,
		"minDate":         filter.MinDate,
		"maxDate":         filter.MaxDate,
		"atDate":          filter.AtDate,
		"targetID":        filter.TargetID,
		"identifier":      identifierCmp,
		"identifiermatch": filter.IdentifierMatch,
		"identifiers":     pq.Array(strings.Split(filter.Identifiers, ",")),
		"issueID":         filter.IssueID,
		"sourceID":        filter.SourceID,
		"labels":          pq.Array(strings.Split(filter.Labels, ",")),
		"limit":           filter.Size,
		"offset":          offset,
	}

	logQuery(db.Logger, "ListFindings", listQuery, args)

	nstmt, err := db.DB.PrepareNamed(listQuery)
	if err != nil {
		return []model.FindingExpanded{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	rows, err := nstmt.Queryx(args)
	if err != nil {
		return []model.FindingExpanded{}, storage.Pagination{}, err
	}

	var timeRef time.Time
	if filter.AtDate != "" {
		timeRef, err = time.Parse(dateFmt, filter.AtDate)
		if err != nil {
			return []model.FindingExpanded{}, storage.Pagination{}, err
		}
	} else {
		timeRef = time.Now().UTC()
	}

	findings := []model.FindingExpanded{}
	for rows.Next() {
		row := make(map[string]interface{})
		err = rows.MapScan(row)
		if err != nil {
			return []model.FindingExpanded{}, storage.Pagination{}, err
		}
		f, err := buildFindingExpandedAtTime(row, timeRef)
		if err != nil {
			return []model.FindingExpanded{}, storage.Pagination{}, err
		}
		findings = append(findings, f)
	}

	var size int
	nstmt, err = db.DB.PrepareNamed(sizeQuery)
	if err != nil {
		return []model.FindingExpanded{}, storage.Pagination{}, err
	}
	defer nstmt.Close()
	err = nstmt.Get(&size, args)
	if err != nil {
		return []model.FindingExpanded{}, storage.Pagination{}, err
	}

	return findings, storage.Pagination{Limit: filter.Size, Offset: offset, Total: size}, nil
}

// GetFinding returns a specific finding.
func (db DB) GetFinding(id string) (model.FindingExpanded, error) {
	query := `SELECT f.id AS finding_id, s.id AS source_id,
	f.issue_id, f.target_id, f.affected_resource, f.status, f.details, f.impact_details, f.resources, f.score,
	s.name, s.component, s.instance, s.options, s.time,
	i.*, t.*,
	(SELECT ARRAY_AGG(tt.tag) FROM target_tags tt WHERE t.id = tt.target_id) tags,
	(SELECT ARRAY_AGG(fexp.found_at) FROM finding_exposures fexp WHERE fexp.finding_id = f.id) as found_at,
	(SELECT ARRAY_AGG(fexp.fixed_at) FROM finding_exposures fexp WHERE fexp.finding_id = f.id) as fixed_at,
	(SELECT ARRAY_AGG(fexp.expired_at) FROM finding_exposures fexp WHERE fexp.finding_id = f.id) as expired_at,
	(SELECT ARRAY_AGG(il.label) FROM issue_labels il WHERE il.issue_id = f.issue_id) labels
	FROM findings f
	INNER JOIN issues i ON f.issue_id = i.id
	INNER JOIN targets t ON f.target_id = t.id
	INNER JOIN finding_events fe ON fe.finding_id = f.id
	INNER JOIN sources s ON fe.source_id = s.id
	WHERE f.id = $1 AND fe.id IN (
		SELECT id FROM finding_events
		WHERE finding_id = f.id ORDER BY time DESC LIMIT 1
	)`

	logQuery(db.Logger, "GetFinding", query, id)
	row := make(map[string]interface{})
	err := db.DB.QueryRowx(query, id).MapScan(row)
	if err == sql.ErrNoRows {
		return model.FindingExpanded{}, nil
	}
	if err != nil {
		return model.FindingExpanded{}, err
	}
	return buildFindingExpanded(row)
}

// GetFinding returns a specific finding.
func (db DB) PatchFinding(id string, payload model.PatchFindingPayload) error {
	query := `UPDATE findings SET status=$1 WHERE id=$2`

	logQuery(db.Logger, "PatchFinding", query, payload.Status, id)
	_, err := db.DB.Exec(query, payload.Status, id)
	return err
}

// ListFindingsByTarget returns a filtered list of findings for a specific target.
func (db DB) ListFindingsByTarget(id string, filter storage.Filter) ([]model.FindingExpanded, storage.Pagination, error) {
	filter.TargetID = id
	return db.ListFindings(filter)
}

// ListFindingsByIssue returns a paginated list of findings for a specific issue for a given status.
func (db DB) ListFindingsByIssue(id string, filter storage.Filter) ([]model.FindingExpanded, storage.Pagination, error) {
	filter.IssueID = id
	return db.ListFindings(filter)
}

// ListFindingsBySource returns a paginated list of findings for a specific source for a given status.
func (db DB) ListFindingsBySource(id string, filter storage.Filter) ([]model.FindingExpanded, storage.Pagination, error) {
	filter.SourceID = id
	return db.ListFindings(filter)
}

// GetFindingFromTargetIssueAndResource returns a concrete finding specified by the given
// target ID, issue ID and affected resource.
func (db DB) GetFindingFromTargetIssueAndResource(targetID, affectedResource, issueID string) (model.FindingExpanded, error) {
	query := `
	SELECT f.id AS finding_id, s.id AS source_id,
	f.issue_id, f.target_id, f.affected_resource, f.status, f.details, f.impact_details, f.resources, f.score,
	s.name, s.component, s.instance, s.options, s.time,
	i.*, t.*,
	(SELECT ARRAY_AGG(tt.tag) FROM target_tags tt WHERE t.id = tt.target_id) tags,
	(SELECT ARRAY_AGG(fexp.found_at) FROM finding_exposures fexp WHERE fexp.finding_id = f.id) as found_at,
	(SELECT ARRAY_AGG(fexp.fixed_at) FROM finding_exposures fexp WHERE fexp.finding_id = f.id) as fixed_at,
	(SELECT ARRAY_AGG(fexp.expired_at) FROM finding_exposures fexp WHERE fexp.finding_id = f.id) as expired_at,
	(SELECT ARRAY_AGG(il.label) FROM issue_labels il WHERE il.issue_id = f.issue_id) labels
	FROM findings f
	INNER JOIN issues i ON f.issue_id = i.id
	INNER JOIN targets t ON f.target_id = t.id
	INNER JOIN finding_events fe ON fe.finding_id = f.id
	INNER JOIN sources s ON fe.source_id = s.id
	WHERE f.target_id = $1 AND f.affected_resource = $2 AND f.issue_id = $3 AND fe.id IN (
		SELECT id FROM finding_events
		WHERE finding_id = f.id ORDER BY time DESC LIMIT 1
	)`

	logQuery(db.Logger, "GetFindingFromTargetIssueAndResource", query, targetID, issueID)
	row := make(map[string]interface{})
	err := db.DB.QueryRowx(query, targetID, affectedResource, issueID).MapScan(row)
	if err == sql.ErrNoRows {
		return model.FindingExpanded{}, nil
	}
	if err != nil {
		return model.FindingExpanded{}, err
	}

	return buildFindingExpanded(row)
}

// GetFindingMTTR returns the mean time to rememdiate a specific finding.
func (db DB) GetFindingMTTR(id string) (float32, error) {
	var mttr float32
	query := `
	SELECT COALESCE(AVG(ttr), 0)
	FROM finding_exposures
	WHERE finding_id = $1
	AND ttr IS NOT NULL`
	logQuery(db.Logger, "GetFindingMTTR", query, id)
	err := db.DB.Get(
		&mttr,
		query,
		id,
	)
	if err == sql.ErrNoRows {
		return 0, nil
	}
	if err != nil {
		return 0, err
	}

	return mttr, nil
}

func buildFindingExpanded(row map[string]interface{}) (model.FindingExpanded, error) {
	return buildFindingExpandedAtTime(row, time.Now().UTC())
}

// buildFindingExpandedAtTime builds the expanded finding calculating its status and exposure
// at the time specified by atTime input parameter.
func buildFindingExpandedAtTime(row map[string]interface{}, atTime time.Time) (model.FindingExpanded, error) {
	var f model.FindingExpanded

	findingID, ok := row["finding_id"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.ID = findingID

	issueID, ok := row["issue_id"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Issue.ID = issueID

	summary, ok := row["summary"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Issue.Summary = summary

	CWEID, ok := row["cwe_id"].(int64)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Issue.CWEID = int(CWEID)

	description, ok := row["description"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Issue.Description = description

	recommendations, err := parseStringArrayNotNil(row["recommendations"])
	if err != nil {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Issue.Recommendations = recommendations

	referenceLinks, err := parseStringArrayNotNil(row["reference_links"])
	if err != nil {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Issue.ReferenceLinks = referenceLinks

	labels, ok := row["labels"]
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	if labels != nil {
		labels, ok := row["labels"].([]uint8)
		if !ok {
			return model.FindingExpanded{}, ErrParsingFinding
		}
		f.Issue.Labels = parseStringArray(labels)
	}

	targetID, ok := row["target_id"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Target.ID = targetID

	affectedResource, ok := row["affected_resource"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.AffectedResource = affectedResource

	identifier, ok := row["identifier"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Target.Identifier = identifier

	tags, ok := row["tags"]
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	if tags != nil {
		tags, ok := row["tags"].([]uint8)
		if !ok {
			return model.FindingExpanded{}, ErrParsingFinding
		}
		f.Target.Tags = parseStringArray(tags)
	}

	sourceID, ok := row["source_id"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Source.ID = sourceID

	name, ok := row["name"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Source.Name = name

	component, ok := row["component"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Source.Component = component

	instance, ok := row["instance"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Source.Instance = instance

	options, ok := row["options"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Source.Options = options

	time, ok := row["time"].(time.Time)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Source.Time = time.String()

	details, ok := row["details"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Details = details

	impactDetails, ok := row["impact_details"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.ImpactDetails = impactDetails

	status, ok := row["status"].(string)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Status = status

	score, ok := row["score"].(float64)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	f.Score = float32(score)

	var resourcesContent []byte
	if row["resources"] != nil {
		var ok bool
		resourcesContent, ok = row["resources"].([]byte)
		if !ok {
			return model.FindingExpanded{}, errors.New("unexpected resources type")
		}
	}
	resources, err := parseFindingResources(resourcesContent)
	if err != nil {
		return model.FindingExpanded{}, err
	}
	f.Resources = resources

	found, ok := row["found_at"].([]uint8)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	foundAt := parseStringArray(found)

	fixed, ok := row["fixed_at"].([]uint8)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	fixedAt := parseStringArray(fixed)

	expired, ok := row["expired_at"].([]uint8)
	if !ok {
		return model.FindingExpanded{}, ErrParsingFinding
	}
	expiredAt := parseStringArray(expired)

	// Don't calculate finding exposure if the finding was marked as a FALSE POSITIVE.
	// A finding marked as false positive must not impact metrics.
	if f.Status != statusFalsePositive {
		err = fillFindingExposures(&f, foundAt, fixedAt, expiredAt, atTime)
		if err != nil {
			return model.FindingExpanded{}, err
		}
	}

	return f, nil
}

// fillFindingExposures calculates and modifies finding exposures for input finding
// at the time specified by atTime parameter.
func fillFindingExposures(f *model.FindingExpanded, foundAt, fixedAt, expiredAt []string, atTime time.Time) error {
	if f == nil {
		return errors.New("the finding to fill the exposure can not be nil")
	}
	if len(foundAt) != len(fixedAt) {
		return fmt.Errorf("finding exposures time bounds expected to have the same len: %w",
			storage.ErrInvalidData)
	}

	var (
		total   float64
		current float64
	)

	for i, found := range foundAt {
		// Parse found time.
		foundT, err := parseDBTime(found)
		if err != nil {
			return err
		}
		if foundT.After(atTime) {
			// If found time is after reference time
			// do not process this entry.
			continue
		}

		// Parse fixed time.
		var fixedT time.Time
		if fixedAt[i] != "NULL" {
			fixedT, err = parseDBTime(fixedAt[i])
			if err != nil {
				return err
			}
		}

		// Parse expired time.
		var expiredT time.Time
		if expiredAt[i] != "NULL" {
			expiredT, err = parseDBTime(expiredAt[i])
			if err != nil {
				return err
			}
		}

		// If finding is expired and time reference is
		// posterior to expiration date, set current
		// exposure to -1 and do not add to total exposure.
		if !expiredT.IsZero() && atTime.After(expiredT) {
			current = -1
			continue
		}

		// If finding is expired and time reference is before
		// expiration date, or finding is open, or finding is
		// fixed but was fixed after time reference, then only
		// count exposure up to time reference.
		if (!expiredT.IsZero() && atTime.Before(expiredT)) ||
			(expiredT.IsZero() && (fixedT.IsZero() || fixedT.After(atTime))) {
			fixedT = atTime
			current = fixedT.Sub(foundT).Hours()
		}

		// Add to total exposure.
		total = total + fixedT.Sub(foundT).Hours()
	}

	f.TotalExposure = int64(total)
	if current > 0 {
		f.Status = statusOpen
		f.OpenFinding = &model.OpenFinding{
			CurrentExposure: int64(current),
		}
	} else if current == -1 {
		f.Status = statusExpired
	} else {
		f.Status = statusFixed
	}

	return nil
}

// parseDBTime parses a datetime string retrieved from DB.
func parseDBTime(dbTime string) (time.Time, error) {
	return time.Parse(dateTimeFmt, strings.Replace(dbTime, "\"", "", -1))
}

func parseStringArrayNotNil(row interface{}) ([]string, error) {
	if row == nil {
		return nil, nil
	}
	safe, ok := row.([]uint8)
	if !ok {
		return nil, ErrParsingFinding
	}
	return parseStringArray(safe), nil
}

// parseStringArray parses a string array retrieved from database
// stripping the initial and trailing brackets and splitting elements
// separated by comma.
func parseStringArray(array []uint8) []string {
	// Void array case.
	if len(array) <= 2 {
		return []string{}
	}

	// Remove JSON brackets first.
	auxString := string(array[1 : len(array)-1])

	var splitter string
	if len(auxString) > 2 && auxString[0] == '"' &&
		!strings.Contains(auxString, "NULL") {
		// Strings are separated by "\",\""
		// so remove first and last quote and
		// split by it.
		auxString = auxString[1 : len(auxString)-1]
		splitter = "\",\""
	} else {
		// Strings are separated by ',' with
		// no quotes between them, or it's a string
		// like: ""2019-01-01",NULL".
		splitter = ","
	}
	return strings.Split(auxString, splitter)
}

func parseFindingResources(content []byte) (model.Resources, error) {
	var resources = make([]model.ResourceGroup, 0)
	if content == nil {
		return resources, nil
	}
	err := json.Unmarshal(content, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}
